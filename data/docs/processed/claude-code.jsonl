
{"source":"github","repo":"claude-code","path":"CHANGELOG.md","content":"# Changelog\n\n## 2.0.65\n\n- Added ability to switch models while writing a prompt using alt+p (linux, windows), option+p (macos).\n- Added context window information to status line input\n- Added `fileSuggestion` setting for custom `@` file search commands\n- Added `CLAUDE_CODE_SHELL` environment variable to override automatic shell detection (useful when login shell differs from actual working shell)\n- Fixed prompt not being saved to history when aborting a query with Escape\n- Fixed Read tool image handling to identify format from bytes instead of file extension\n\n## 2.0.64\n\n- Made auto-compacting instant\n- Agents and bash commands can run asynchronously and send messages to wake up the main agent\n- /stats now provides users with interesting CC stats, such as favorite model, usage graph, usage streak\n- Added named session support: use `/rename` to name sessions, `/resume <name>` in REPL or `claude --resume <name>` from the terminal to resume them\n- Added support for .claude/rules/`.  See https://code.claude.com/docs/en/memory for details.\n- Added image dimension metadata when images are resized, enabling accurate coordinate mappings for large images\n- Fixed auto-loading .env when using native installer\n- Fixed `--system-prompt` being ignored when using `--continue` or `--resume` flags\n- Improved `/resume` screen with grouped forked sessions and keyboard shortcuts for preview (P) and rename (R)\n- VSCode: Added copy-to-clipboard button on code blocks and bash tool inputs\n- VSCode: Fixed extension not working on Windows ARM64 by falling back to x64 binary via emulation\n- Bedrock: Improve efficiency of token counting\n- Unshipped AgentOutputTool and BashOutputTool, in favor of a new unified TaskOutputTool\n\n## 2.0.62\n\n- Added \"(Recommended)\" indicator for multiple-choice questions, with the recommended option moved to the top of the list\n- Added `attribution` setting to customize commit and PR bylines (deprecates `includeCoAuthoredBy`)\n- Fixed duplicate slash commands appearing when ~/.claude is symlinked to a project directory\n- Fixed slash command selection not working when multiple commands share the same name\n- Fixed an issue where skill files inside symlinked skill directories could become circular symlinks\n- Fixed running versions getting removed because lock file incorrectly going stale\n- Fixed IDE diff tab not closing when rejecting file changes\n\n## 2.0.61\n\n- Reverted VSCode support for multiple terminal clients due to responsiveness issues.\n\n## 2.0.60\n\n- Added background agent support. Agents run in the background while you work\n- Added --disable-slash-commands CLI flag to disable all slash commands\n- Added model name to \"Co-Authored-By\" commit messages\n- Enabled \"/mcp enable [server-name]\" or \"/mcp disable [server-name]\" to quickly toggle all servers\n- Updated Fetch to skip summarization for pre-approved websites\n- VSCode: Added support for multiple terminal clients connecting to the IDE server simultaneously\n\n## 2.0.59\n\n- Added --agent CLI flag to override the agent setting for the current session\n- Added `agent` setting to configure main thread with a specific agent's system prompt, tool restrictions, and model\n- VS Code: Fixed .claude.json config file being read from incorrect location\n\n## 2.0.58\n\n- Pro users now have access to Opus 4.5 as part of their subscription!\n- Fixed timer duration showing \"11m 60s\" instead of \"12m 0s\"\n- Windows: Managed settings now prefer `C:\\Program Files\\ClaudeCode` if it exists. Support for `C:\\ProgramData\\ClaudeCode` will be removed in a future version.\n\n## 2.0.57\n\n- Added feedback input when rejecting plans, allowing users to tell Claude what to change\n- VSCode: Added streaming message support for real-time response display\n\n## 2.0.56\n\n- Added setting to enable/disable terminal progress bar (OSC 9;4)\n- VSCode Extension: Added support for VS Code's secondary sidebar (VS Code 1.97+), allowing Claude Code to be displayed in the right sidebar while keeping the file explorer on the left. Requires setting sidebar as Preferred Location in the config.\n\n## 2.0.55\n\n- Fixed proxy DNS resolution being forced on by default. Now opt-in via `CLAUDE_CODE_PROXY_RESOLVES_HOSTS=true` environment variable\n- Fixed keyboard navigation becoming unresponsive when holding down arrow keys in memory location selector\n- Improved AskUserQuestion tool to auto-submit single-select questions on the last question, eliminating the extra review screen for simple question flows\n- Improved fuzzy matching for `@` file suggestions with faster, more accurate results\n\n## 2.0.54\n\n- Hooks: Enable PermissionRequest hooks to process 'always allow' suggestions and apply permission updates\n- Fix issue with excessive iTerm notifications\n\n## 2.0.52\n\n- Fixed duplicate message display when starting Claude with a command line argument\n- Fixed `/usage` command progress bars to fill up as usage increases (instead of showing remaining percentage)\n- Fixed image pasting not working on Linux systems running Wayland (now falls back to wl-paste when xclip is unavailable)\n- Permit some uses of `$!` in bash commands\n\n## 2.0.51\n\n- Added Opus 4.5! https://www.anthropic.com/news/claude-opus-4-5\n- Introducing Claude Code for Desktop: https://claude.com/download\n- To give you room to try out our new model, we've updated usage limits for Claude Code users. See the Claude Opus 4.5 blog for full details\n- Pro users can now purchase extra usage for access to Opus 4.5 in Claude Code\n- Plan Mode now builds more precise plans and executes more thoroughly\n- Usage limit notifications now easier to understand\n- Switched `/usage` back to \"% used\"\n- Fixed handling of thinking errors\n- Fixed performance regression\n\n## 2.0.50\n\n- Fixed bug preventing calling MCP tools that have nested references in their input schemas\n- Silenced a noisy but harmless error during upgrades\n- Improved ultrathink text display\n- Improved clarity of 5-hour session limit warning message\n\n## 2.0.49\n\n- Added readline-style ctrl-y for pasting deleted text\n- Improved clarity of usage limit warning message\n- Fixed handling of subagent permissions\n\n## 2.0.47\n\n- Improved error messages and validation for `claude --teleport`\n- Improved error handling in `/usage`\n- Fixed race condition with history entry not getting logged at exit\n- Fixed Vertex AI configuration not being applied from `settings.json`\n\n## 2.0.46\n\n- Fixed image files being reported with incorrect media type when format cannot be detected from metadata\n\n## 2.0.45\n\n- Added support for Microsoft Foundry! See https://code.claude.com/docs/en/azure-ai-foundry\n- Added `PermissionRequest` hook to automatically approve or deny tool permission requests with custom logic\n- Send background tasks to Claude Code on the web by starting a message with `&`\n\n## 2.0.43\n\n- Added `permissionMode` field for custom agents\n- Added `tool_use_id` field to `PreToolUseHookInput` and `PostToolUseHookInput` types\n- Added skills frontmatter field to declare skills to auto-load for subagents\n- Added the `SubagentStart` hook event\n- Fixed nested `CLAUDE.md` files not loading when @-mentioning files\n- Fixed duplicate rendering of some messages in the UI\n- Fixed some visual flickers\n- Fixed NotebookEdit tool inserting cells at incorrect positions when cell IDs matched the pattern `cell-N`\n\n## 2.0.42\n\n- Added `agent_id` and `agent_transcript_path` fields to `SubagentStop` hooks.\n\n## 2.0.41\n\n- Added `model` parameter to prompt-based stop hooks, allowing users to specify a custom model for hook evaluation\n- Fixed slash commands from user settings being loaded twice, which could cause rendering issues\n- Fixed incorrect labeling of user settings vs project settings in command descriptions\n- Fixed crash when plugin command hooks timeout during execution\n- Fixed: Bedrock users no longer see duplicate Opus entries in the /model picker when using `--model haiku`\n- Fixed broken security documentation links in trust dialogs and onboarding\n- Fixed issue where pressing ESC to close the diff modal would also interrupt the model\n- ctrl-r history search landing on a slash command no longer cancels the search\n- SDK: Support custom timeouts for hooks\n- Allow more safe git commands to run without approval\n- Plugins: Added support for sharing and installing output styles\n- Teleporting a session from web will automatically set the upstream branch\n\n## 2.0.37\n\n- Fixed how idleness is computed for notifications\n- Hooks: Added matcher values for Notification hook events\n- Output Styles: Added `keep-coding-instructions` option to frontmatter\n\n## 2.0.36\n\n- Fixed: DISABLE_AUTOUPDATER environment variable now properly disables package manager update notifications\n- Fixed queued messages being incorrectly executed as bash commands\n- Fixed input being lost when typing while a queued message is processed\n\n## 2.0.35\n\n- Improve fuzzy search results when searching commands\n- Improved VS Code extension to respect `chat.fontSize` and `chat.fontFamily` settings throughout the entire UI, and apply font changes immediately without requiring reload\n- Added `CLAUDE_CODE_EXIT_AFTER_STOP_DELAY` environment variable to automatically exit SDK mode after a specified idle duration, useful for automated workflows and scripts\n- Migrated `ignorePatterns` from project config to deny permissions in the localSettings.\n- Fixed menu navigation getting stuck on items with empty string or other falsy values (e.g., in the `/hooks` menu)\n\n## 2.0.34\n\n- VSCode Extension: Added setting to configure the initial permission mode for new conversations\n- Improved file path suggestion performance with native Rust-based fuzzy finder\n- Fixed infinite token refresh loop that caused MCP servers with OAuth (e.g., Slack) to hang during connection\n- Fixed memory crash when reading or writing large files (especially base64-encoded images)\n\n## 2.0.33\n\n- Native binary installs now launch quicker.\n- Fixed `claude doctor` incorrectly detecting Homebrew vs npm-global installations by properly resolving symlinks\n- Fixed `claude mcp serve` exposing tools with incompatible outputSchemas\n\n## 2.0.32\n\n- Un-deprecate output styles based on community feedback\n- Added `companyAnnouncements` setting for displaying announcements on startup\n- Fixed hook progress messages not updating correctly during PostToolUse hook execution\n\n## 2.0.31\n\n- Windows: native installation uses shift+tab as shortcut for mode switching, instead of alt+m\n- Vertex: add support for Web Search on supported models\n- VSCode: Adding the respectGitIgnore configuration to include .gitignored files in file searches (defaults to true)\n- Fixed a bug with subagents and MCP servers related to \"Tool names must be unique\" error\n- Fixed issue causing `/compact` to fail with `prompt_too_long` by making it respect existing compact boundaries\n- Fixed plugin uninstall not removing plugins\n\n## 2.0.30\n\n- Added helpful hint to run `security unlock-keychain` when encountering API key errors on macOS with locked keychain\n- Added `allowUnsandboxedCommands` sandbox setting to disable the dangerouslyDisableSandbox escape hatch at policy level\n- Added `disallowedTools` field to custom agent definitions for explicit tool blocking\n- Added prompt-based stop hooks\n- VSCode: Added respectGitIgnore configuration to include .gitignored files in file searches (defaults to true)\n- Enabled SSE MCP servers on native build\n- Deprecated output styles. Review options in `/output-style` and use --system-prompt-file, --system-prompt, --append-system-prompt, CLAUDE.md, or plugins instead\n- Removed support for custom ripgrep configuration, resolving an issue where Search returns no results and config discovery fails\n- Fixed Explore agent creating unwanted .md investigation files during codebase exploration\n- Fixed a bug where `/context` would sometimes fail with \"max_tokens must be greater than thinking.budget_tokens\" error message\n- Fixed `--mcp-config` flag to correctly override file-based MCP configurations\n- Fixed bug that saved session permissions to local settings\n- Fixed MCP tools not being available to sub-agents\n- Fixed hooks and plugins not executing when using --dangerously-skip-permissions flag\n- Fixed delay when navigating through typeahead suggestions with arrow keys\n- VSCode: Restored selection indicator in input footer showing current file or code selection status\n\n## 2.0.28\n\n- Plan mode: introduced new Plan subagent\n- Subagents: claude can now choose to resume subagents\n- Subagents: claude can dynamically choose the model used by its subagents\n- SDK: added --max-budget-usd flag\n- Discovery of custom slash commands, subagents, and output styles no longer respects .gitignore\n- Stop `/terminal-setup` from adding backslash to `Shift + Enter` in VS Code\n- Add branch and tag support for git-based plugins and marketplaces using fragment syntax (e.g., `owner/repo#branch`)\n- Fixed a bug where macOS permission prompts would show up upon initial launch when launching from home directory\n- Various other bug fixes\n\n## 2.0.27\n\n- New UI for permission prompts\n- Added current branch filtering and search to session resume screen for easier navigation\n- Fixed directory @-mention causing \"No assistant message found\" error\n- VSCode Extension: Add config setting to include .gitignored files in file searches\n- VSCode Extension: Bug fixes for unrelated 'Warmup' conversations, and configuration/settings occasionally being reset to defaults\n\n## 2.0.25\n\n- Removed legacy SDK entrypoint. Please migrate to @anthropic-ai/claude-agent-sdk for future SDK updates: https://platform.claude.com/docs/en/agent-sdk/migration-guide\n\n## 2.0.24\n\n- Fixed a bug where project-level skills were not loading when --setting-sources 'project' was specified\n- Claude Code Web: Support for Web -> CLI teleport\n- Sandbox: Releasing a sandbox mode for the BashTool on Linux & Mac\n- Bedrock: Display awsAuthRefresh output when auth is required\n\n## 2.0.22\n\n- Fixed content layout shift when scrolling through slash commands\n- IDE: Add toggle to enable/disable thinking.\n- Fix bug causing duplicate permission prompts with parallel tool calls\n- Add support for enterprise managed MCP allowlist and denylist\n\n## 2.0.21\n\n- Support MCP `structuredContent` field in tool responses\n- Added an interactive question tool\n- Claude will now ask you questions more often in plan mode\n- Added Haiku 4.5 as a model option for Pro users\n- Fixed an issue where queued commands don't have access to previous messages' output\n\n## 2.0.20\n\n- Added support for Claude Skills\n\n## 2.0.19\n\n- Auto-background long-running bash commands instead of killing them. Customize with BASH_DEFAULT_TIMEOUT_MS\n- Fixed a bug where Haiku was unnecessarily called in print mode\n\n## 2.0.17\n\n- Added Haiku 4.5 to model selector!\n- Haiku 4.5 automatically uses Sonnet in plan mode, and Haiku for execution (i.e. SonnetPlan by default)\n- 3P (Bedrock and Vertex) are not automatically upgraded yet. Manual upgrading can be done through setting `ANTHROPIC_DEFAULT_HAIKU_MODEL`\n- Introducing the Explore subagent. Powered by Haiku it'll search through your codebase efficiently to save context!\n- OTEL: support HTTP_PROXY and HTTPS_PROXY\n- `CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC` now disables release notes fetching\n\n## 2.0.15\n\n- Fixed bug with resuming where previously created files needed to be read again before writing\n- Fixed bug with `-p` mode where @-mentioned files needed to be read again before writing\n\n## 2.0.14\n\n- Fix @-mentioning MCP servers to toggle them on/off\n- Improve permission checks for bash with inline env vars\n- Fix ultrathink + thinking toggle\n- Reduce unnecessary logins\n- Document --system-prompt\n- Several improvements to rendering\n- Plugins UI polish\n\n## 2.0.13\n\n- Fixed `/plugin` not working on native build\n\n## 2.0.12\n\n- **Plugin System Released**: Extend Claude Code with custom commands, agents, hooks, and MCP servers from marketplaces\n- `/plugin install`, `/plugin enable/disable`, `/plugin marketplace` commands for plugin management\n- Repository-level plugin configuration via `extraKnownMarketplaces` for team collaboration\n- `/plugin validate` command for validating plugin structure and configuration\n- Plugin announcement blog post at https://www.anthropic.com/news/claude-code-plugins\n- Plugin documentation available at https://code.claude.com/docs/en/plugins\n- Comprehensive error messages and diagnostics via `/doctor` command\n- Avoid flickering in `/model` selector\n- Improvements to `/help`\n- Avoid mentioning hooks in `/resume` summaries\n- Changes to the \"verbose\" setting in `/config` now persist across sessions\n\n## 2.0.11\n\n- Reduced system prompt size by 1.4k tokens\n- IDE: Fixed keyboard shortcuts and focus issues for smoother interaction\n- Fixed Opus fallback rate limit errors appearing incorrectly\n- Fixed /add-dir command selecting wrong default tab\n\n## 2.0.10\n\n- Rewrote terminal renderer for buttery smooth UI\n- Enable/disable MCP servers by @mentioning, or in /mcp\n- Added tab completion for shell commands in bash mode\n- PreToolUse hooks can now modify tool inputs\n- Press Ctrl-G to edit your prompt in your system's configured text editor\n- Fixes for bash permission checks with environment variables in the command\n\n## 2.0.9\n\n- Fix regression where bash backgrounding stopped working\n\n## 2.0.8\n\n- Update Bedrock default Sonnet model to `global.anthropic.claude-sonnet-4-5-20250929-v1:0`\n- IDE: Add drag-and-drop support for files and folders in chat\n- /context: Fix counting for thinking blocks\n- Improve message rendering for users with light themes on dark terminals\n- Remove deprecated .claude.json allowedTools, ignorePatterns, env, and todoFeatureEnabled config options (instead, configure these in your settings.json)\n\n## 2.0.5\n\n- IDE: Fix IME unintended message submission with Enter and Tab\n- IDE: Add \"Open in Terminal\" link in login screen\n- Fix unhandled OAuth expiration 401 API errors\n- SDK: Added SDKUserMessageReplay.isReplay to prevent duplicate messages\n\n## 2.0.1\n\n- Skip Sonnet 4.5 default model setting change for Bedrock and Vertex\n- Various bug fixes and presentation improvements\n\n## 2.0.0\n\n- New native VS Code extension\n- Fresh coat of paint throughout the whole app\n- /rewind a conversation to undo code changes\n- /usage command to see plan limits\n- Tab to toggle thinking (sticky across sessions)\n- Ctrl-R to search history\n- Unshipped claude config command\n- Hooks: Reduced PostToolUse 'tool_use' ids were found without 'tool_result' blocks errors\n- SDK: The Claude Code SDK is now the Claude Agent SDK\n- Add subagents dynamically with `--agents` flag\n\n## 1.0.126\n\n- Enable /context command for Bedrock and Vertex\n- Add mTLS support for HTTP-based OpenTelemetry exporters\n\n## 1.0.124\n\n- Set `CLAUDE_BASH_NO_LOGIN` environment variable to 1 or true to to skip login shell for BashTool\n- Fix Bedrock and Vertex environment variables evaluating all strings as truthy\n- No longer inform Claude of the list of allowed tools when permission is denied\n- Fixed security vulnerability in Bash tool permission checks\n- Improved VSCode extension performance for large files\n\n## 1.0.123\n\n- Bash permission rules now support output redirections when matching (e.g., `Bash(python:*)` matches `python script.py > output.txt`)\n- Fixed thinking mode triggering on negation phrases like \"don't think\"\n- Fixed rendering performance degradation during token streaming\n- Added SlashCommand tool, which enables Claude to invoke your slash commands. https://code.claude.com/docs/en/slash-commands#SlashCommand-tool\n- Enhanced BashTool environment snapshot logging\n- Fixed a bug where resuming a conversation in headless mode would sometimes enable thinking unnecessarily\n- Migrated --debug logging to a file, to enable easy tailing & filtering\n\n## 1.0.120\n\n- Fix input lag during typing, especially noticeable with large prompts\n- Improved VSCode extension command registry and sessions dialog user experience\n- Enhanced sessions dialog responsiveness and visual feedback\n- Fixed IDE compatibility issue by removing worktree support check\n- Fixed security vulnerability where Bash tool permission checks could be bypassed using prefix matching\n\n## 1.0.119\n\n- Fix Windows issue where process visually freezes on entering interactive mode\n- Support dynamic headers for MCP servers via headersHelper configuration\n- Fix thinking mode not working in headless sessions\n- Fix slash commands now properly update allowed tools instead of replacing them\n\n## 1.0.117\n\n- Add Ctrl-R history search to recall previous commands like bash/zsh\n- Fix input lag while typing, especially on Windows\n- Add sed command to auto-allowed commands in acceptEdits mode\n- Fix Windows PATH comparison to be case-insensitive for drive letters\n- Add permissions management hint to /add-dir output\n\n## 1.0.115\n\n- Improve thinking mode display with enhanced visual effects\n- Type /t to temporarily disable thinking mode in your prompt\n- Improve path validation for glob and grep tools\n- Show condensed output for post-tool hooks to reduce visual clutter\n- Fix visual feedback when loading state completes\n- Improve UI consistency for permission request dialogs\n\n## 1.0.113\n\n- Deprecated piped input in interactive mode\n- Move Ctrl+R keybinding for toggling transcript to Ctrl+O\n\n## 1.0.112\n\n- Transcript mode (Ctrl+R): Added the model used to generate each assistant message\n- Addressed issue where some Claude Max users were incorrectly recognized as Claude Pro users\n- Hooks: Added systemMessage support for SessionEnd hooks\n- Added `spinnerTipsEnabled` setting to disable spinner tips\n- IDE: Various improvements and bug fixes\n\n## 1.0.111\n\n- /model now validates provided model names\n- Fixed Bash tool crashes caused by malformed shell syntax parsing\n\n## 1.0.110\n\n- /terminal-setup command now supports WezTerm\n- MCP: OAuth tokens now proactively refresh before expiration\n- Fixed reliability issues with background Bash processes\n\n## 1.0.109\n\n- SDK: Added partial message streaming support via `--include-partial-messages` CLI flag\n\n## 1.0.106\n\n- Windows: Fixed path permission matching to consistently use POSIX format (e.g., `Read(//c/Users/...)`)\n\n## 1.0.97\n\n- Settings: /doctor now validates permission rule syntax and suggests corrections\n\n## 1.0.94\n\n- Vertex: add support for global endpoints for supported models\n- /memory command now allows direct editing of all imported memory files\n- SDK: Add custom tools as callbacks\n- Added /todos command to list current todo items\n\n## 1.0.93\n\n- Windows: Add alt + v shortcut for pasting images from clipboard\n- Support NO_PROXY environment variable to bypass proxy for specified hostnames and IPs\n\n## 1.0.90\n\n- Settings file changes take effect immediately - no restart required\n\n## 1.0.88\n\n- Fixed issue causing \"OAuth authentication is currently not supported\"\n- Status line input now includes `exceeds_200k_tokens`\n- Fixed incorrect usage tracking in /cost.\n- Introduced `ANTHROPIC_DEFAULT_SONNET_MODEL` and `ANTHROPIC_DEFAULT_OPUS_MODEL` for controlling model aliases opusplan, opus, and sonnet.\n- Bedrock: Updated default Sonnet model to Sonnet 4\n\n## 1.0.86\n\n- Added /context to help users self-serve debug context issues\n- SDK: Added UUID support for all SDK messages\n- SDK: Added `--replay-user-messages` to replay user messages back to stdout\n\n## 1.0.85\n\n- Status line input now includes session cost info\n- Hooks: Introduced SessionEnd hook\n\n## 1.0.84\n\n- Fix tool_use/tool_result id mismatch error when network is unstable\n- Fix Claude sometimes ignoring real-time steering when wrapping up a task\n- @-mention: Add ~/.claude/\\* files to suggestions for easier agent, output style, and slash command editing\n- Use built-in ripgrep by default; to opt out of this behavior, set USE_BUILTIN_RIPGREP=0\n\n## 1.0.83\n\n- @-mention: Support files with spaces in path\n- New shimmering spinner\n\n## 1.0.82\n\n- SDK: Add request cancellation support\n- SDK: New additionalDirectories option to search custom paths, improved slash command processing\n- Settings: Validation prevents invalid fields in .claude/settings.json files\n- MCP: Improve tool name consistency\n- Bash: Fix crash when Claude tries to automatically read large files\n\n## 1.0.81\n\n- Released output styles, including new built-in educational output styles \"Explanatory\" and \"Learning\". Docs: https://code.claude.com/docs/en/output-styles\n- Agents: Fix custom agent loading when agent files are unparsable\n\n## 1.0.80\n\n- UI improvements: Fix text contrast for custom subagent colors and spinner rendering issues\n\n## 1.0.77\n\n- Bash tool: Fix heredoc and multiline string escaping, improve stderr redirection handling\n- SDK: Add session support and permission denial tracking\n- Fix token limit errors in conversation summarization\n- Opus Plan Mode: New setting in `/model` to run Opus only in plan mode, Sonnet otherwise\n\n## 1.0.73\n\n- MCP: Support multiple config files with `--mcp-config file1.json file2.json`\n- MCP: Press Esc to cancel OAuth authentication flows\n- Bash: Improved command validation and reduced false security warnings\n- UI: Enhanced spinner animations and status line visual hierarchy\n- Linux: Added support for Alpine and musl-based distributions (requires separate ripgrep installation)\n\n## 1.0.72\n\n- Ask permissions: have Claude Code always ask for confirmation to use specific tools with /permissions\n\n## 1.0.71\n\n- Background commands: (Ctrl-b) to run any Bash command in the background so Claude can keep working (great for dev servers, tailing logs, etc.)\n- Customizable status line: add your terminal prompt to Claude Code with /statusline\n\n## 1.0.70\n\n- Performance: Optimized message rendering for better performance with large contexts\n- Windows: Fixed native file search, ripgrep, and subagent functionality\n- Added support for @-mentions in slash command arguments\n\n## 1.0.69\n\n- Upgraded Opus to version 4.1\n\n## 1.0.68\n\n- Fix incorrect model names being used for certain commands like `/pr-comments`\n- Windows: improve permissions checks for allow / deny tools and project trust. This may create a new project entry in `.claude.json` - manually merge the history field if desired.\n- Windows: improve sub-process spawning to eliminate \"No such file or directory\" when running commands like pnpm\n- Enhanced /doctor command with CLAUDE.md and MCP tool context for self-serve debugging\n- SDK: Added canUseTool callback support for tool confirmation\n- Added `disableAllHooks` setting\n- Improved file suggestions performance in large repos\n\n## 1.0.65\n\n- IDE: Fixed connection stability issues and error handling for diagnostics\n- Windows: Fixed shell environment setup for users without .bashrc files\n\n## 1.0.64\n\n- Agents: Added model customization support - you can now specify which model an agent should use\n- Agents: Fixed unintended access to the recursive agent tool\n- Hooks: Added systemMessage field to hook JSON output for displaying warnings and context\n- SDK: Fixed user input tracking across multi-turn conversations\n- Added hidden files to file search and @-mention suggestions\n\n## 1.0.63\n\n- Windows: Fixed file search, @agent mentions, and custom slash commands functionality\n\n## 1.0.62\n\n- Added @-mention support with typeahead for custom agents. @<your-custom-agent> to invoke it\n- Hooks: Added SessionStart hook for new session initialization\n- /add-dir command now supports typeahead for directory paths\n- Improved network connectivity check reliability\n\n## 1.0.61\n\n- Transcript mode (Ctrl+R): Changed Esc to exit transcript mode rather than interrupt\n- Settings: Added `--settings` flag to load settings from a JSON file\n- Settings: Fixed resolution of settings files paths that are symlinks\n- OTEL: Fixed reporting of wrong organization after authentication changes\n- Slash commands: Fixed permissions checking for allowed-tools with Bash\n- IDE: Added support for pasting images in VSCode MacOS using âŒ˜+V\n- IDE: Added `CLAUDE_CODE_AUTO_CONNECT_IDE=false` for disabling IDE auto-connection\n- Added `CLAUDE_CODE_SHELL_PREFIX` for wrapping Claude and user-provided shell commands run by Claude Code\n\n## 1.0.60\n\n- You can now create custom subagents for specialized tasks! Run /agents to get started\n\n## 1.0.59\n\n- SDK: Added tool confirmation support with canUseTool callback\n- SDK: Allow specifying env for spawned process\n- Hooks: Exposed PermissionDecision to hooks (including \"ask\")\n- Hooks: UserPromptSubmit now supports additionalContext in advanced JSON output\n- Fixed issue where some Max users that specified Opus would still see fallback to Sonnet\n\n## 1.0.58\n\n- Added support for reading PDFs\n- MCP: Improved server health status display in 'claude mcp list'\n- Hooks: Added CLAUDE_PROJECT_DIR env var for hook commands\n\n## 1.0.57\n\n- Added support for specifying a model in slash commands\n- Improved permission messages to help Claude understand allowed tools\n- Fix: Remove trailing newlines from bash output in terminal wrapping\n\n## 1.0.56\n\n- Windows: Enabled shift+tab for mode switching on versions of Node.js that support terminal VT mode\n- Fixes for WSL IDE detection\n- Fix an issue causing awsRefreshHelper changes to .aws directory not to be picked up\n\n## 1.0.55\n\n- Clarified knowledge cutoff for Opus 4 and Sonnet 4 models\n- Windows: fixed Ctrl+Z crash\n- SDK: Added ability to capture error logging\n- Add --system-prompt-file option to override system prompt in print mode\n\n## 1.0.54\n\n- Hooks: Added UserPromptSubmit hook and the current working directory to hook inputs\n- Custom slash commands: Added argument-hint to frontmatter\n- Windows: OAuth uses port 45454 and properly constructs browser URL\n- Windows: mode switching now uses alt + m, and plan mode renders properly\n- Shell: Switch to in-memory shell snapshot to fix file-related errors\n\n## 1.0.53\n\n- Updated @-mention file truncation from 100 lines to 2000 lines\n- Add helper script settings for AWS token refresh: awsAuthRefresh (for foreground operations like aws sso login) and awsCredentialExport (for background operation with STS-like response).\n\n## 1.0.52\n\n- Added support for MCP server instructions\n\n## 1.0.51\n\n- Added support for native Windows (requires Git for Windows)\n- Added support for Bedrock API keys through environment variable AWS_BEARER_TOKEN_BEDROCK\n- Settings: /doctor can now help you identify and fix invalid setting files\n- `--append-system-prompt` can now be used in interactive mode, not just --print/-p.\n- Increased auto-compact warning threshold from 60% to 80%\n- Fixed an issue with handling user directories with spaces for shell snapshots\n- OTEL resource now includes os.type, os.version, host.arch, and wsl.version (if running on Windows Subsystem for Linux)\n- Custom slash commands: Fixed user-level commands in subdirectories\n- Plan mode: Fixed issue where rejected plan from sub-task would get discarded\n\n## 1.0.48\n\n- Fixed a bug in v1.0.45 where the app would sometimes freeze on launch\n- Added progress messages to Bash tool based on the last 5 lines of command output\n- Added expanding variables support for MCP server configuration\n- Moved shell snapshots from /tmp to ~/.claude for more reliable Bash tool calls\n- Improved IDE extension path handling when Claude Code runs in WSL\n- Hooks: Added a PreCompact hook\n- Vim mode: Added c, f/F, t/T\n\n## 1.0.45\n\n- Redesigned Search (Grep) tool with new tool input parameters and features\n- Disabled IDE diffs for notebook files, fixing \"Timeout waiting after 1000ms\" error\n- Fixed config file corruption issue by enforcing atomic writes\n- Updated prompt input undo to Ctrl+\\_ to avoid breaking existing Ctrl+U behavior, matching zsh's undo shortcut\n- Stop Hooks: Fixed transcript path after /clear and fixed triggering when loop ends with tool call\n- Custom slash commands: Restored namespacing in command names based on subdirectories. For example, .claude/commands/frontend/component.md is now /frontend:component, not /component.\n\n## 1.0.44\n\n- New /export command lets you quickly export a conversation for sharing\n- MCP: resource_link tool results are now supported\n- MCP: tool annotations and tool titles now display in /mcp view\n- Changed Ctrl+Z to suspend Claude Code. Resume by running `fg`. Prompt input undo is now Ctrl+U.\n\n## 1.0.43\n\n- Fixed a bug where the theme selector was saving excessively\n- Hooks: Added EPIPE system error handling\n\n## 1.0.42\n\n- Added tilde (`~`) expansion support to `/add-dir` command\n\n## 1.0.41\n\n- Hooks: Split Stop hook triggering into Stop and SubagentStop\n- Hooks: Enabled optional timeout configuration for each command\n- Hooks: Added \"hook_event_name\" to hook input\n- Fixed a bug where MCP tools would display twice in tool list\n- New tool parameters JSON for Bash tool in `tool_decision` event\n\n## 1.0.40\n\n- Fixed a bug causing API connection errors with UNABLE_TO_GET_ISSUER_CERT_LOCALLY if `NODE_EXTRA_CA_CERTS` was set\n\n## 1.0.39\n\n- New Active Time metric in OpenTelemetry logging\n\n## 1.0.38\n\n- Released hooks. Special thanks to community input in https://github.com/anthropics/claude-code/issues/712. Docs: https://code.claude.com/docs/en/hooks\n\n## 1.0.37\n\n- Remove ability to set `Proxy-Authorization` header via ANTHROPIC_AUTH_TOKEN or apiKeyHelper\n\n## 1.0.36\n\n- Web search now takes today's date into context\n- Fixed a bug where stdio MCP servers were not terminating properly on exit\n\n## 1.0.35\n\n- Added support for MCP OAuth Authorization Server discovery\n\n## 1.0.34\n\n- Fixed a memory leak causing a MaxListenersExceededWarning message to appear\n\n## 1.0.33\n\n- Improved logging functionality with session ID support\n- Added prompt input undo functionality (Ctrl+Z and vim 'u' command)\n- Improvements to plan mode\n\n## 1.0.32\n\n- Updated loopback config for litellm\n- Added forceLoginMethod setting to bypass login selection screen\n\n## 1.0.31\n\n- Fixed a bug where ~/.claude.json would get reset when file contained invalid JSON\n\n## 1.0.30\n\n- Custom slash commands: Run bash output, @-mention files, enable thinking with thinking keywords\n- Improved file path autocomplete with filename matching\n- Added timestamps in Ctrl-r mode and fixed Ctrl-c handling\n- Enhanced jq regex support for complex filters with pipes and select\n\n## 1.0.29\n\n- Improved CJK character support in cursor navigation and rendering\n\n## 1.0.28\n\n- Slash commands: Fix selector display during history navigation\n- Resizes images before upload to prevent API size limit errors\n- Added XDG_CONFIG_HOME support to configuration directory\n- Performance optimizations for memory usage\n- New attributes (terminal.type, language) in OpenTelemetry logging\n\n## 1.0.27\n\n- Streamable HTTP MCP servers are now supported\n- Remote MCP servers (SSE and HTTP) now support OAuth\n- MCP resources can now be @-mentioned\n- /resume slash command to switch conversations within Claude Code\n\n## 1.0.25\n\n- Slash commands: moved \"project\" and \"user\" prefixes to descriptions\n- Slash commands: improved reliability for command discovery\n- Improved support for Ghostty\n- Improved web search reliability\n\n## 1.0.24\n\n- Improved /mcp output\n- Fixed a bug where settings arrays got overwritten instead of merged\n\n## 1.0.23\n\n- Released TypeScript SDK: import @anthropic-ai/claude-code to get started\n- Released Python SDK: pip install claude-code-sdk to get started\n\n## 1.0.22\n\n- SDK: Renamed `total_cost` to `total_cost_usd`\n\n## 1.0.21\n\n- Improved editing of files with tab-based indentation\n- Fix for tool_use without matching tool_result errors\n- Fixed a bug where stdio MCP server processes would linger after quitting Claude Code\n\n## 1.0.18\n\n- Added --add-dir CLI argument for specifying additional working directories\n- Added streaming input support without require -p flag\n- Improved startup performance and session storage performance\n- Added CLAUDE_BASH_MAINTAIN_PROJECT_WORKING_DIR environment variable to freeze working directory for bash commands\n- Added detailed MCP server tools display (/mcp)\n- MCP authentication and permission improvements\n- Added auto-reconnection for MCP SSE connections on disconnect\n- Fixed issue where pasted content was lost when dialogs appeared\n\n## 1.0.17\n\n- We now emit messages from sub-tasks in -p mode (look for the parent_tool_use_id property)\n- Fixed crashes when the VS Code diff tool is invoked multiple times quickly\n- MCP server list UI improvements\n- Update Claude Code process title to display \"claude\" instead of \"node\"\n\n## 1.0.11\n\n- Claude Code can now also be used with a Claude Pro subscription\n- Added /upgrade for smoother switching to Claude Max plans\n- Improved UI for authentication from API keys and Bedrock/Vertex/external auth tokens\n- Improved shell configuration error handling\n- Improved todo list handling during compaction\n\n## 1.0.10\n\n- Added markdown table support\n- Improved streaming performance\n\n## 1.0.8\n\n- Fixed Vertex AI region fallback when using CLOUD_ML_REGION\n- Increased default otel interval from 1s -> 5s\n- Fixed edge cases where MCP_TIMEOUT and MCP_TOOL_TIMEOUT weren't being respected\n- Fixed a regression where search tools unnecessarily asked for permissions\n- Added support for triggering thinking non-English languages\n- Improved compacting UI\n\n## 1.0.7\n\n- Renamed /allowed-tools -> /permissions\n- Migrated allowedTools and ignorePatterns from .claude.json -> settings.json\n- Deprecated claude config commands in favor of editing settings.json\n- Fixed a bug where --dangerously-skip-permissions sometimes didn't work in --print mode\n- Improved error handling for /install-github-app\n- Bugfixes, UI polish, and tool reliability improvements\n\n## 1.0.6\n\n- Improved edit reliability for tab-indented files\n- Respect CLAUDE_CONFIG_DIR everywhere\n- Reduced unnecessary tool permission prompts\n- Added support for symlinks in @file typeahead\n- Bugfixes, UI polish, and tool reliability improvements\n\n## 1.0.4\n\n- Fixed a bug where MCP tool errors weren't being parsed correctly\n\n## 1.0.1\n\n- Added `DISABLE_INTERLEAVED_THINKING` to give users the option to opt out of interleaved thinking.\n- Improved model references to show provider-specific names (Sonnet 3.7 for Bedrock, Sonnet 4 for Console)\n- Updated documentation links and OAuth process descriptions\n\n## 1.0.0\n\n- Claude Code is now generally available\n- Introducing Sonnet 4 and Opus 4 models\n\n## 0.2.125\n\n- Breaking change: Bedrock ARN passed to `ANTHROPIC_MODEL` or `ANTHROPIC_SMALL_FAST_MODEL` should no longer contain an escaped slash (specify `/` instead of `%2F`)\n- Removed `DEBUG=true` in favor of `ANTHROPIC_LOG=debug`, to log all requests\n\n## 0.2.117\n\n- Breaking change: --print JSON output now returns nested message objects, for forwards-compatibility as we introduce new metadata fields\n- Introduced settings.cleanupPeriodDays\n- Introduced CLAUDE_CODE_API_KEY_HELPER_TTL_MS env var\n- Introduced --debug mode\n\n## 0.2.108\n\n- You can now send messages to Claude while it works to steer Claude in real-time\n- Introduced BASH_DEFAULT_TIMEOUT_MS and BASH_MAX_TIMEOUT_MS env vars\n- Fixed a bug where thinking was not working in -p mode\n- Fixed a regression in /cost reporting\n- Deprecated MCP wizard interface in favor of other MCP commands\n- Lots of other bugfixes and improvements\n\n## 0.2.107\n\n- CLAUDE.md files can now import other files. Add @path/to/file.md to ./CLAUDE.md to load additional files on launch\n\n## 0.2.106\n\n- MCP SSE server configs can now specify custom headers\n- Fixed a bug where MCP permission prompt didn't always show correctly\n\n## 0.2.105\n\n- Claude can now search the web\n- Moved system & account status to /status\n- Added word movement keybindings for Vim\n- Improved latency for startup, todo tool, and file edits\n\n## 0.2.102\n\n- Improved thinking triggering reliability\n- Improved @mention reliability for images and folders\n- You can now paste multiple large chunks into one prompt\n\n## 0.2.100\n\n- Fixed a crash caused by a stack overflow error\n- Made db storage optional; missing db support disables --continue and --resume\n\n## 0.2.98\n\n- Fixed an issue where auto-compact was running twice\n\n## 0.2.96\n\n- Claude Code can now also be used with a Claude Max subscription (https://claude.ai/upgrade)\n\n## 0.2.93\n\n- Resume conversations from where you left off from with \"claude --continue\" and \"claude --resume\"\n- Claude now has access to a Todo list that helps it stay on track and be more organized\n\n## 0.2.82\n\n- Added support for --disallowedTools\n- Renamed tools for consistency: LSTool -> LS, View -> Read, etc.\n\n## 0.2.75\n\n- Hit Enter to queue up additional messages while Claude is working\n- Drag in or copy/paste image files directly into the prompt\n- @-mention files to directly add them to context\n- Run one-off MCP servers with `claude --mcp-config <path-to-file>`\n- Improved performance for filename auto-complete\n\n## 0.2.74\n\n- Added support for refreshing dynamically generated API keys (via apiKeyHelper), with a 5 minute TTL\n- Task tool can now perform writes and run bash commands\n\n## 0.2.72\n\n- Updated spinner to indicate tokens loaded and tool usage\n\n## 0.2.70\n\n- Network commands like curl are now available for Claude to use\n- Claude can now run multiple web queries in parallel\n- Pressing ESC once immediately interrupts Claude in Auto-accept mode\n\n## 0.2.69\n\n- Fixed UI glitches with improved Select component behavior\n- Enhanced terminal output display with better text truncation logic\n\n## 0.2.67\n\n- Shared project permission rules can be saved in .claude/settings.json\n\n## 0.2.66\n\n- Print mode (-p) now supports streaming output via --output-format=stream-json\n- Fixed issue where pasting could trigger memory or bash mode unexpectedly\n\n## 0.2.63\n\n- Fixed an issue where MCP tools were loaded twice, which caused tool call errors\n\n## 0.2.61\n\n- Navigate menus with vim-style keys (j/k) or bash/emacs shortcuts (Ctrl+n/p) for faster interaction\n- Enhanced image detection for more reliable clipboard paste functionality\n- Fixed an issue where ESC key could crash the conversation history selector\n\n## 0.2.59\n\n- Copy+paste images directly into your prompt\n- Improved progress indicators for bash and fetch tools\n- Bugfixes for non-interactive mode (-p)\n\n## 0.2.54\n\n- Quickly add to Memory by starting your message with '#'\n- Press ctrl+r to see full output for long tool results\n- Added support for MCP SSE transport\n\n## 0.2.53\n\n- New web fetch tool lets Claude view URLs that you paste in\n- Fixed a bug with JPEG detection\n\n## 0.2.50\n\n- New MCP \"project\" scope now allows you to add MCP servers to .mcp.json files and commit them to your repository\n\n## 0.2.49\n\n- Previous MCP server scopes have been renamed: previous \"project\" scope is now \"local\" and \"global\" scope is now \"user\"\n\n## 0.2.47\n\n- Press Tab to auto-complete file and folder names\n- Press Shift + Tab to toggle auto-accept for file edits\n- Automatic conversation compaction for infinite conversation length (toggle with /config)\n\n## 0.2.44\n\n- Ask Claude to make a plan with thinking mode: just say 'think' or 'think harder' or even 'ultrathink'\n\n## 0.2.41\n\n- MCP server startup timeout can now be configured via MCP_TIMEOUT environment variable\n- MCP server startup no longer blocks the app from starting up\n\n## 0.2.37\n\n- New /release-notes command lets you view release notes at any time\n- `claude config add/remove` commands now accept multiple values separated by commas or spaces\n\n## 0.2.36\n\n- Import MCP servers from Claude Desktop with `claude mcp add-from-claude-desktop`\n- Add MCP servers as JSON strings with `claude mcp add-json <n> <json>`\n\n## 0.2.34\n\n- Vim bindings for text input - enable with /vim or /config\n\n## 0.2.32\n\n- Interactive MCP setup wizard: Run \"claude mcp add\" to add MCP servers with a step-by-step interface\n- Fix for some PersistentShell issues\n\n## 0.2.31\n\n- Custom slash commands: Markdown files in .claude/commands/ directories now appear as custom slash commands to insert prompts into your conversation\n- MCP debug mode: Run with --mcp-debug flag to get more information about MCP server errors\n\n## 0.2.30\n\n- Added ANSI color theme for better terminal compatibility\n- Fixed issue where slash command arguments weren't being sent properly\n- (Mac-only) API keys are now stored in macOS Keychain\n\n## 0.2.26\n\n- New /approved-tools command for managing tool permissions\n- Word-level diff display for improved code readability\n- Fuzzy matching for slash commands\n\n## 0.2.21\n\n- Fuzzy matching for /commands\n"}
{"source":"github","repo":"claude-code","path":".claude/commands/commit-push-pr.md","content":"---\nallowed-tools: Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)\ndescription: Commit, push, and open a PR\n---\n\n## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls.\n"}
{"source":"github","repo":"claude-code","path":".claude/commands/oncall-triage.md","content":"---\nallowed-tools: Bash(gh issue list:*), Bash(gh issue view:*), Bash(gh issue edit:*), TodoWrite\ndescription: Triage GitHub issues and label critical ones for oncall\n---\n\nYou're an oncall triage assistant for GitHub issues. Your task is to identify critical issues that require immediate oncall attention and apply the \"oncall\" label.\n\nRepository: anthropics/claude-code\n\nTask overview:\n\n1. First, get all open bugs updated in the last 3 days with at least 50 engagements:\n   ```bash\n   gh issue list --repo anthropics/claude-code --state open --label bug --limit 1000 --json number,title,updatedAt,comments,reactions | jq -r '.[] | select((.updatedAt >= (now - 259200 | strftime(\"%Y-%m-%dT%H:%M:%SZ\"))) and ((.comments | length) + ([.reactions[].content] | length) >= 50)) | \"\\(.number)\"'\n   ```\n\n2. Save the list of issue numbers and create a TODO list with ALL of them. This ensures you process every single one.\n\n3. For each issue in your TODO list:\n   - Use `gh issue view <number> --repo anthropics/claude-code --json title,body,labels,comments` to get full details\n   - Read and understand the full issue content and comments to determine actual user impact\n   - Evaluate: Is this truly blocking users from using Claude Code?\n     - Consider: \"crash\", \"stuck\", \"frozen\", \"hang\", \"unresponsive\", \"cannot use\", \"blocked\", \"broken\"\n     - Does it prevent core functionality? Can users work around it?\n   - Be conservative - only flag issues that truly prevent users from getting work done\n\n4. For issues that are truly blocking and don't already have the \"oncall\" label:\n   - Use `gh issue edit <number> --repo anthropics/claude-code --add-label \"oncall\"`\n   - Mark the issue as complete in your TODO list\n\n5. After processing all issues, provide a summary:\n   - List each issue number that received the \"oncall\" label\n   - Include the issue title and brief reason why it qualified\n   - If no issues qualified, state that clearly\n\nImportant:\n- Process ALL issues in your TODO list systematically\n- Don't post any comments to issues\n- Only add the \"oncall\" label, never remove it\n- Use individual `gh issue view` commands instead of bash for loops to avoid approval prompts\n"}
{"source":"github","repo":"claude-code","path":".claude/commands/dedupe.md","content":"---\nallowed-tools: Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh api:*), Bash(gh issue comment:*)\ndescription: Find duplicate GitHub issues\n---\n\nFind up to 3 likely duplicate issues for a given GitHub issue.\n\nTo do this, follow these steps precisely:\n\n1. Use an agent to check if the Github issue (a) is closed, (b) does not need to be deduped (eg. because it is broad product feedback without a specific solution, or positive feedback), or (c) already has a duplicates comment that you made earlier. If so, do not proceed.\n2. Use an agent to view a Github issue, and ask the agent to return a summary of the issue\n3. Then, launch 5 parallel agents to search Github for duplicates of this issue, using diverse keywords and search approaches, using the summary from #1\n4. Next, feed the results from #1 and #2 into another agent, so that it can filter out false positives, that are likely not actually duplicates of the original issue. If there are no duplicates remaining, do not proceed.\n5. Finally, comment back on the issue with a list of up to three duplicate issues (or zero, if there are no likely duplicates)\n\nNotes (be sure to tell this to your agents, too):\n\n- Use `gh` to interact with Github, rather than web fetch\n- Do not use other tools, beyond `gh` (eg. don't use other MCP servers, file edit, etc.)\n- Make a todo list first\n- For your comment, follow the following format precisely (assuming for this example that you found 3 suspected duplicates):\n\n---\n\nFound 3 possible duplicate issues:\n\n1. <link to issue>\n2. <link to issue>\n3. <link to issue>\n\nThis issue will be automatically closed as a duplicate in 3 days.\n\n- If your issue is a duplicate, please close it and ðŸ‘ the existing issue instead\n- To prevent auto-closure, add a comment or ðŸ‘Ž this comment\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n---\n"}
{"source":"github","repo":"claude-code","path":"SECURITY.md","content":"# Security Policy\nThank you for helping us keep Claude Code secure!\n\n## Reporting Security Issues\n\nThe security of our systems and user data is Anthropic's top priority. We appreciate the work of security researchers acting in good faith in identifying and reporting potential vulnerabilities.\n\nOur security program is managed on HackerOne and we ask that any validated vulnerability in this functionality be reported through their [submission form](https://hackerone.com/anthropic-vdp/reports/new?type=team&report_type=vulnerability).\n\n## Vulnerability Disclosure Program\n\nOur Vulnerability Program Guidelines are defined on our [HackerOne program page](https://hackerone.com/anthropic-vdp).\n"}
{"source":"github","repo":"claude-code","path":"plugins/pr-review-toolkit/agents/silent-failure-hunter.md","content":"---\nname: silent-failure-hunter\ndescription: Use this agent when reviewing code changes in a pull request to identify silent failures, inadequate error handling, and inappropriate fallback behavior. This agent should be invoked proactively after completing a logical chunk of work that involves error handling, catch blocks, fallback logic, or any code that could potentially suppress errors. Examples:\\n\\n<example>\\nContext: Daisy has just finished implementing a new feature that fetches data from an API with fallback behavior.\\nDaisy: \"I've added error handling to the API client. Can you review it?\"\\nAssistant: \"Let me use the silent-failure-hunter agent to thoroughly examine the error handling in your changes.\"\\n<Task tool invocation to launch silent-failure-hunter agent>\\n</example>\\n\\n<example>\\nContext: Daisy has created a PR with changes that include try-catch blocks.\\nDaisy: \"Please review PR #1234\"\\nAssistant: \"I'll use the silent-failure-hunter agent to check for any silent failures or inadequate error handling in this PR.\"\\n<Task tool invocation to launch silent-failure-hunter agent>\\n</example>\\n\\n<example>\\nContext: Daisy has just refactored error handling code.\\nDaisy: \"I've updated the error handling in the authentication module\"\\nAssistant: \"Let me proactively use the silent-failure-hunter agent to ensure the error handling changes don't introduce silent failures.\"\\n<Task tool invocation to launch silent-failure-hunter agent>\\n</example>\nmodel: inherit\ncolor: yellow\n---\n\nYou are an elite error handling auditor with zero tolerance for silent failures and inadequate error handling. Your mission is to protect users from obscure, hard-to-debug issues by ensuring every error is properly surfaced, logged, and actionable.\n\n## Core Principles\n\nYou operate under these non-negotiable rules:\n\n1. **Silent failures are unacceptable** - Any error that occurs without proper logging and user feedback is a critical defect\n2. **Users deserve actionable feedback** - Every error message must tell users what went wrong and what they can do about it\n3. **Fallbacks must be explicit and justified** - Falling back to alternative behavior without user awareness is hiding problems\n4. **Catch blocks must be specific** - Broad exception catching hides unrelated errors and makes debugging impossible\n5. **Mock/fake implementations belong only in tests** - Production code falling back to mocks indicates architectural problems\n\n## Your Review Process\n\nWhen examining a PR, you will:\n\n### 1. Identify All Error Handling Code\n\nSystematically locate:\n- All try-catch blocks (or try-except in Python, Result types in Rust, etc.)\n- All error callbacks and error event handlers\n- All conditional branches that handle error states\n- All fallback logic and default values used on failure\n- All places where errors are logged but execution continues\n- All optional chaining or null coalescing that might hide errors\n\n### 2. Scrutinize Each Error Handler\n\nFor every error handling location, ask:\n\n**Logging Quality:**\n- Is the error logged with appropriate severity (logError for production issues)?\n- Does the log include sufficient context (what operation failed, relevant IDs, state)?\n- Is there an error ID from constants/errorIds.ts for Sentry tracking?\n- Would this log help someone debug the issue 6 months from now?\n\n**User Feedback:**\n- Does the user receive clear, actionable feedback about what went wrong?\n- Does the error message explain what the user can do to fix or work around the issue?\n- Is the error message specific enough to be useful, or is it generic and unhelpful?\n- Are technical details appropriately exposed or hidden based on the user's context?\n\n**Catch Block Specificity:**\n- Does the catch block catch only the expected error types?\n- Could this catch block accidentally suppress unrelated errors?\n- List every type of unexpected error that could be hidden by this catch block\n- Should this be multiple catch blocks for different error types?\n\n**Fallback Behavior:**\n- Is there fallback logic that executes when an error occurs?\n- Is this fallback explicitly requested by the user or documented in the feature spec?\n- Does the fallback behavior mask the underlying problem?\n- Would the user be confused about why they're seeing fallback behavior instead of an error?\n- Is this a fallback to a mock, stub, or fake implementation outside of test code?\n\n**Error Propagation:**\n- Should this error be propagated to a higher-level handler instead of being caught here?\n- Is the error being swallowed when it should bubble up?\n- Does catching here prevent proper cleanup or resource management?\n\n### 3. Examine Error Messages\n\nFor every user-facing error message:\n- Is it written in clear, non-technical language (when appropriate)?\n- Does it explain what went wrong in terms the user understands?\n- Does it provide actionable next steps?\n- Does it avoid jargon unless the user is a developer who needs technical details?\n- Is it specific enough to distinguish this error from similar errors?\n- Does it include relevant context (file names, operation names, etc.)?\n\n### 4. Check for Hidden Failures\n\nLook for patterns that hide errors:\n- Empty catch blocks (absolutely forbidden)\n- Catch blocks that only log and continue\n- Returning null/undefined/default values on error without logging\n- Using optional chaining (?.) to silently skip operations that might fail\n- Fallback chains that try multiple approaches without explaining why\n- Retry logic that exhausts attempts without informing the user\n\n### 5. Validate Against Project Standards\n\nEnsure compliance with the project's error handling requirements:\n- Never silently fail in production code\n- Always log errors using appropriate logging functions\n- Include relevant context in error messages\n- Use proper error IDs for Sentry tracking\n- Propagate errors to appropriate handlers\n- Never use empty catch blocks\n- Handle errors explicitly, never suppress them\n\n## Your Output Format\n\nFor each issue you find, provide:\n\n1. **Location**: File path and line number(s)\n2. **Severity**: CRITICAL (silent failure, broad catch), HIGH (poor error message, unjustified fallback), MEDIUM (missing context, could be more specific)\n3. **Issue Description**: What's wrong and why it's problematic\n4. **Hidden Errors**: List specific types of unexpected errors that could be caught and hidden\n5. **User Impact**: How this affects the user experience and debugging\n6. **Recommendation**: Specific code changes needed to fix the issue\n7. **Example**: Show what the corrected code should look like\n\n## Your Tone\n\nYou are thorough, skeptical, and uncompromising about error handling quality. You:\n- Call out every instance of inadequate error handling, no matter how minor\n- Explain the debugging nightmares that poor error handling creates\n- Provide specific, actionable recommendations for improvement\n- Acknowledge when error handling is done well (rare but important)\n- Use phrases like \"This catch block could hide...\", \"Users will be confused when...\", \"This fallback masks the real problem...\"\n- Are constructively critical - your goal is to improve the code, not to criticize the developer\n\n## Special Considerations\n\nBe aware of project-specific patterns from CLAUDE.md:\n- This project has specific logging functions: logForDebugging (user-facing), logError (Sentry), logEvent (Statsig)\n- Error IDs should come from constants/errorIds.ts\n- The project explicitly forbids silent failures in production code\n- Empty catch blocks are never acceptable\n- Tests should not be fixed by disabling them; errors should not be fixed by bypassing them\n\nRemember: Every silent failure you catch prevents hours of debugging frustration for users and developers. Be thorough, be skeptical, and never let an error slip through unnoticed.\n"}
{"source":"github","repo":"claude-code","path":"plugins/pr-review-toolkit/agents/type-design-analyzer.md","content":"---\nname: type-design-analyzer\ndescription: Use this agent when you need expert analysis of type design in your codebase. Specifically use it: (1) when introducing a new type to ensure it follows best practices for encapsulation and invariant expression, (2) during pull request creation to review all types being added, (3) when refactoring existing types to improve their design quality. The agent will provide both qualitative feedback and quantitative ratings on encapsulation, invariant expression, usefulness, and enforcement.\\n\\n<example>\\nContext: Daisy is writing code that introduces a new UserAccount type and wants to ensure it has well-designed invariants.\\nuser: \"I've just created a new UserAccount type that handles user authentication and permissions\"\\nassistant: \"I'll use the type-design-analyzer agent to review the UserAccount type design\"\\n<commentary>\\nSince a new type is being introduced, use the type-design-analyzer to ensure it has strong invariants and proper encapsulation.\\n</commentary>\\n</example>\\n\\n<example>\\nContext: Daisy is creating a pull request and wants to review all newly added types.\\nuser: \"I'm about to create a PR with several new data model types\"\\nassistant: \"Let me use the type-design-analyzer agent to review all the types being added in this PR\"\\n<commentary>\\nDuring PR creation with new types, use the type-design-analyzer to review their design quality.\\n</commentary>\\n</example>\nmodel: inherit\ncolor: pink\n---\n\nYou are a type design expert with extensive experience in large-scale software architecture. Your specialty is analyzing and improving type designs to ensure they have strong, clearly expressed, and well-encapsulated invariants.\n\n**Your Core Mission:**\nYou evaluate type designs with a critical eye toward invariant strength, encapsulation quality, and practical usefulness. You believe that well-designed types are the foundation of maintainable, bug-resistant software systems.\n\n**Analysis Framework:**\n\nWhen analyzing a type, you will:\n\n1. **Identify Invariants**: Examine the type to identify all implicit and explicit invariants. Look for:\n   - Data consistency requirements\n   - Valid state transitions\n   - Relationship constraints between fields\n   - Business logic rules encoded in the type\n   - Preconditions and postconditions\n\n2. **Evaluate Encapsulation** (Rate 1-10):\n   - Are internal implementation details properly hidden?\n   - Can the type's invariants be violated from outside?\n   - Are there appropriate access modifiers?\n   - Is the interface minimal and complete?\n\n3. **Assess Invariant Expression** (Rate 1-10):\n   - How clearly are invariants communicated through the type's structure?\n   - Are invariants enforced at compile-time where possible?\n   - Is the type self-documenting through its design?\n   - Are edge cases and constraints obvious from the type definition?\n\n4. **Judge Invariant Usefulness** (Rate 1-10):\n   - Do the invariants prevent real bugs?\n   - Are they aligned with business requirements?\n   - Do they make the code easier to reason about?\n   - Are they neither too restrictive nor too permissive?\n\n5. **Examine Invariant Enforcement** (Rate 1-10):\n   - Are invariants checked at construction time?\n   - Are all mutation points guarded?\n   - Is it impossible to create invalid instances?\n   - Are runtime checks appropriate and comprehensive?\n\n**Output Format:**\n\nProvide your analysis in this structure:\n\n```\n## Type: [TypeName]\n\n### Invariants Identified\n- [List each invariant with a brief description]\n\n### Ratings\n- **Encapsulation**: X/10\n  [Brief justification]\n  \n- **Invariant Expression**: X/10\n  [Brief justification]\n  \n- **Invariant Usefulness**: X/10\n  [Brief justification]\n  \n- **Invariant Enforcement**: X/10\n  [Brief justification]\n\n### Strengths\n[What the type does well]\n\n### Concerns\n[Specific issues that need attention]\n\n### Recommended Improvements\n[Concrete, actionable suggestions that won't overcomplicate the codebase]\n```\n\n**Key Principles:**\n\n- Prefer compile-time guarantees over runtime checks when feasible\n- Value clarity and expressiveness over cleverness\n- Consider the maintenance burden of suggested improvements\n- Recognize that perfect is the enemy of good - suggest pragmatic improvements\n- Types should make illegal states unrepresentable\n- Constructor validation is crucial for maintaining invariants\n- Immutability often simplifies invariant maintenance\n\n**Common Anti-patterns to Flag:**\n\n- Anemic domain models with no behavior\n- Types that expose mutable internals\n- Invariants enforced only through documentation\n- Types with too many responsibilities\n- Missing validation at construction boundaries\n- Inconsistent enforcement across mutation methods\n- Types that rely on external code to maintain invariants\n\n**When Suggesting Improvements:**\n\nAlways consider:\n- The complexity cost of your suggestions\n- Whether the improvement justifies potential breaking changes\n- The skill level and conventions of the existing codebase\n- Performance implications of additional validation\n- The balance between safety and usability\n\nThink deeply about each type's role in the larger system. Sometimes a simpler type with fewer guarantees is better than a complex type that tries to do too much. Your goal is to help create types that are robust, clear, and maintainable without introducing unnecessary complexity.\n"}
{"source":"github","repo":"claude-code","path":"plugins/pr-review-toolkit/agents/code-reviewer.md","content":"---\nname: code-reviewer\ndescription: Use this agent when you need to review code for adherence to project guidelines, style guides, and best practices. This agent should be used proactively after writing or modifying code, especially before committing changes or creating pull requests. It will check for style violations, potential issues, and ensure code follows the established patterns in CLAUDE.md. Also the agent needs to know which files to focus on for the review. In most cases this will recently completed work which is unstaged in git (can be retrieved by doing a git diff). However there can be cases where this is different, make sure to specify this as the agent input when calling the agent. \\n\\nExamples:\\n<example>\\nContext: The user has just implemented a new feature with several TypeScript files.\\nuser: \"I've added the new authentication feature. Can you check if everything looks good?\"\\nassistant: \"I'll use the Task tool to launch the code-reviewer agent to review your recent changes.\"\\n<commentary>\\nSince the user has completed a feature and wants validation, use the code-reviewer agent to ensure the code meets project standards.\\n</commentary>\\n</example>\\n<example>\\nContext: The assistant has just written a new utility function.\\nuser: \"Please create a function to validate email addresses\"\\nassistant: \"Here's the email validation function:\"\\n<function call omitted for brevity>\\nassistant: \"Now I'll use the Task tool to launch the code-reviewer agent to review this implementation.\"\\n<commentary>\\nProactively use the code-reviewer agent after writing new code to catch issues early.\\n</commentary>\\n</example>\\n<example>\\nContext: The user is about to create a PR.\\nuser: \"I think I'm ready to create a PR for this feature\"\\nassistant: \"Before creating the PR, I'll use the Task tool to launch the code-reviewer agent to ensure all code meets our standards.\"\\n<commentary>\\nProactively review code before PR creation to avoid review comments and iterations.\\n</commentary>\\n</example>\nmodel: opus\ncolor: green\n---\n\nYou are an expert code reviewer specializing in modern software development across multiple languages and frameworks. Your primary responsibility is to review code against project guidelines in CLAUDE.md with high precision to minimize false positives.\n\n## Review Scope\n\nBy default, review unstaged changes from `git diff`. The user may specify different files or scope to review.\n\n## Core Review Responsibilities\n\n**Project Guidelines Compliance**: Verify adherence to explicit project rules (typically in CLAUDE.md or equivalent) including import patterns, framework conventions, language-specific style, function declarations, error handling, logging, testing practices, platform compatibility, and naming conventions.\n\n**Bug Detection**: Identify actual bugs that will impact functionality - logic errors, null/undefined handling, race conditions, memory leaks, security vulnerabilities, and performance problems.\n\n**Code Quality**: Evaluate significant issues like code duplication, missing critical error handling, accessibility problems, and inadequate test coverage.\n\n## Issue Confidence Scoring\n\nRate each issue from 0-100:\n\n- **0-25**: Likely false positive or pre-existing issue\n- **26-50**: Minor nitpick not explicitly in CLAUDE.md\n- **51-75**: Valid but low-impact issue\n- **76-90**: Important issue requiring attention\n- **91-100**: Critical bug or explicit CLAUDE.md violation\n\n**Only report issues with confidence â‰¥ 80**\n\n## Output Format\n\nStart by listing what you're reviewing. For each high-confidence issue provide:\n\n- Clear description and confidence score\n- File path and line number\n- Specific CLAUDE.md rule or bug explanation\n- Concrete fix suggestion\n\nGroup issues by severity (Critical: 90-100, Important: 80-89).\n\nIf no high-confidence issues exist, confirm the code meets standards with a brief summary.\n\nBe thorough but filter aggressively - quality over quantity. Focus on issues that truly matter.\n"}
{"source":"github","repo":"claude-code","path":"plugins/pr-review-toolkit/agents/code-simplifier.md","content":"---\nname: code-simplifier\ndescription: Use this agent when code has been written or modified and needs to be simplified for clarity, consistency, and maintainability while preserving all functionality. This agent should be triggered automatically after completing a coding task or writing a logical chunk of code. It simplifies code by following project best practices while retaining all functionality. The agent focuses only on recently modified code unless instructed otherwise.\\n\\nExamples:\\n\\n<example>\nContext: The assistant has just implemented a new feature that adds user authentication to an API endpoint.\nuser: \"Please add authentication to the /api/users endpoint\"\nassistant: \"I've implemented the authentication for the /api/users endpoint. Here's the code:\"\n<function call omitted for brevity>\n<commentary>\nSince a logical chunk of code has been written (authentication feature), use the Task tool to launch the code-simplifier agent to improve the code's clarity and maintainability while preserving functionality.\n</commentary>\nassistant: \"Now let me use the code-simplifier agent to refine this implementation for better clarity and maintainability\"\n</example>\n\n<example>\nContext: The assistant has just fixed a bug by adding several conditional checks.\nuser: \"Fix the null pointer exception in the data processor\"\nassistant: \"I've added the necessary null checks to prevent the exception:\"\n<function call omitted for brevity>\n<commentary>\nAfter modifying code to fix a bug, use the code-simplifier agent to ensure the fix follows best practices and maintains code quality.\n</commentary>\nassistant: \"Let me refine this bug fix using the code-simplifier agent to ensure it follows our best practices\"\n</example>\n\n<example>\nContext: The assistant has just refactored a function to improve performance.\nuser: \"Optimize the data sorting algorithm for better performance\"\nassistant: \"I've optimized the sorting algorithm. Here's the updated implementation:\"\n<function call omitted for brevity>\n<commentary>\nAfter completing a performance optimization task, use the code-simplifier agent to ensure the optimized code is also clear and maintainable.\n</commentary>\nassistant: \"Now I'll use the code-simplifier agent to ensure the optimized code is also clear and follows our coding standards\"\n</example>\nmodel: opus\n---\n\nYou are an expert code simplification specialist focused on enhancing code clarity, consistency, and maintainability while preserving exact functionality. Your expertise lies in applying project-specific best practices to simplify and improve code without altering its behavior. You prioritize readable, explicit code over overly compact solutions. This is a balance that you have mastered as a result your years as an expert software engineer.\n\nYou will analyze recently modified code and apply refinements that:\n\n1. **Preserve Functionality**: Never change what the code does - only how it does it. All original features, outputs, and behaviors must remain intact.\n\n2. **Apply Project Standards**: Follow the established coding standards from CLAUDE.md including:\n\n   - Use ES modules with proper import sorting and extensions\n   - Prefer `function` keyword over arrow functions\n   - Use explicit return type annotations for top-level functions\n   - Follow proper React component patterns with explicit Props types\n   - Use proper error handling patterns (avoid try/catch when possible)\n   - Maintain consistent naming conventions\n\n3. **Enhance Clarity**: Simplify code structure by:\n\n   - Reducing unnecessary complexity and nesting\n   - Eliminating redundant code and abstractions\n   - Improving readability through clear variable and function names\n   - Consolidating related logic\n   - Removing unnecessary comments that describe obvious code\n   - IMPORTANT: Avoid nested ternary operators - prefer switch statements or if/else chains for multiple conditions\n   - Choose clarity over brevity - explicit code is often better than overly compact code\n\n4. **Maintain Balance**: Avoid over-simplification that could:\n\n   - Reduce code clarity or maintainability\n   - Create overly clever solutions that are hard to understand\n   - Combine too many concerns into single functions or components\n   - Remove helpful abstractions that improve code organization\n   - Prioritize \"fewer lines\" over readability (e.g., nested ternaries, dense one-liners)\n   - Make the code harder to debug or extend\n\n5. **Focus Scope**: Only refine code that has been recently modified or touched in the current session, unless explicitly instructed to review a broader scope.\n\nYour refinement process:\n\n1. Identify the recently modified code sections\n2. Analyze for opportunities to improve elegance and consistency\n3. Apply project-specific best practices and coding standards\n4. Ensure all functionality remains unchanged\n5. Verify the refined code is simpler and more maintainable\n6. Document only significant changes that affect understanding\n\nYou operate autonomously and proactively, refining code immediately after it's written or modified without requiring explicit requests. Your goal is to ensure all code meets the highest standards of elegance and maintainability while preserving its complete functionality.\n"}
{"source":"github","repo":"claude-code","path":"plugins/pr-review-toolkit/agents/comment-analyzer.md","content":"---\nname: comment-analyzer\ndescription: Use this agent when you need to analyze code comments for accuracy, completeness, and long-term maintainability. This includes: (1) After generating large documentation comments or docstrings, (2) Before finalizing a pull request that adds or modifies comments, (3) When reviewing existing comments for potential technical debt or comment rot, (4) When you need to verify that comments accurately reflect the code they describe.\\n\\n<example>\\nContext: The user is working on a pull request that adds several documentation comments to functions.\\nuser: \"I've added documentation to these functions. Can you check if the comments are accurate?\"\\nassistant: \"I'll use the comment-analyzer agent to thoroughly review all the comments in this pull request for accuracy and completeness.\"\\n<commentary>\\nSince the user has added documentation comments and wants them checked, use the comment-analyzer agent to verify their accuracy against the actual code.\\n</commentary>\\n</example>\\n\\n<example>\\nContext: The user just asked to generate comprehensive documentation for a complex function.\\nuser: \"Add detailed documentation for this authentication handler function\"\\nassistant: \"I've added the documentation. Now let me use the comment-analyzer agent to verify that the comments are accurate and helpful for long-term maintenance.\"\\n<commentary>\\nAfter generating large documentation comments, proactively use the comment-analyzer to ensure quality.\\n</commentary>\\n</example>\\n\\n<example>\\nContext: The user is preparing to create a pull request with multiple code changes and comments.\\nuser: \"I think we're ready to create the PR now\"\\nassistant: \"Before creating the pull request, let me use the comment-analyzer agent to review all the comments we've added or modified to ensure they're accurate and won't create technical debt.\"\\n<commentary>\\nBefore finalizing a PR, use the comment-analyzer to review all comment changes.\\n</commentary>\\n</example>\nmodel: inherit\ncolor: green\n---\n\nYou are a meticulous code comment analyzer with deep expertise in technical documentation and long-term code maintainability. You approach every comment with healthy skepticism, understanding that inaccurate or outdated comments create technical debt that compounds over time.\n\nYour primary mission is to protect codebases from comment rot by ensuring every comment adds genuine value and remains accurate as code evolves. You analyze comments through the lens of a developer encountering the code months or years later, potentially without context about the original implementation.\n\nWhen analyzing comments, you will:\n\n1. **Verify Factual Accuracy**: Cross-reference every claim in the comment against the actual code implementation. Check:\n   - Function signatures match documented parameters and return types\n   - Described behavior aligns with actual code logic\n   - Referenced types, functions, and variables exist and are used correctly\n   - Edge cases mentioned are actually handled in the code\n   - Performance characteristics or complexity claims are accurate\n\n2. **Assess Completeness**: Evaluate whether the comment provides sufficient context without being redundant:\n   - Critical assumptions or preconditions are documented\n   - Non-obvious side effects are mentioned\n   - Important error conditions are described\n   - Complex algorithms have their approach explained\n   - Business logic rationale is captured when not self-evident\n\n3. **Evaluate Long-term Value**: Consider the comment's utility over the codebase's lifetime:\n   - Comments that merely restate obvious code should be flagged for removal\n   - Comments explaining 'why' are more valuable than those explaining 'what'\n   - Comments that will become outdated with likely code changes should be reconsidered\n   - Comments should be written for the least experienced future maintainer\n   - Avoid comments that reference temporary states or transitional implementations\n\n4. **Identify Misleading Elements**: Actively search for ways comments could be misinterpreted:\n   - Ambiguous language that could have multiple meanings\n   - Outdated references to refactored code\n   - Assumptions that may no longer hold true\n   - Examples that don't match current implementation\n   - TODOs or FIXMEs that may have already been addressed\n\n5. **Suggest Improvements**: Provide specific, actionable feedback:\n   - Rewrite suggestions for unclear or inaccurate portions\n   - Recommendations for additional context where needed\n   - Clear rationale for why comments should be removed\n   - Alternative approaches for conveying the same information\n\nYour analysis output should be structured as:\n\n**Summary**: Brief overview of the comment analysis scope and findings\n\n**Critical Issues**: Comments that are factually incorrect or highly misleading\n- Location: [file:line]\n- Issue: [specific problem]\n- Suggestion: [recommended fix]\n\n**Improvement Opportunities**: Comments that could be enhanced\n- Location: [file:line]\n- Current state: [what's lacking]\n- Suggestion: [how to improve]\n\n**Recommended Removals**: Comments that add no value or create confusion\n- Location: [file:line]\n- Rationale: [why it should be removed]\n\n**Positive Findings**: Well-written comments that serve as good examples (if any)\n\nRemember: You are the guardian against technical debt from poor documentation. Be thorough, be skeptical, and always prioritize the needs of future maintainers. Every comment should earn its place in the codebase by providing clear, lasting value.\n\nIMPORTANT: You analyze and provide feedback only. Do not modify code or comments directly. Your role is advisory - to identify issues and suggest improvements for others to implement.\n"}
{"source":"github","repo":"claude-code","path":"plugins/pr-review-toolkit/agents/pr-test-analyzer.md","content":"---\nname: pr-test-analyzer\ndescription: Use this agent when you need to review a pull request for test coverage quality and completeness. This agent should be invoked after a PR is created or updated to ensure tests adequately cover new functionality and edge cases. Examples:\\n\\n<example>\\nContext: Daisy has just created a pull request with new functionality.\\nuser: \"I've created the PR. Can you check if the tests are thorough?\"\\nassistant: \"I'll use the pr-test-analyzer agent to review the test coverage and identify any critical gaps.\"\\n<commentary>\\nSince Daisy is asking about test thoroughness in a PR, use the Task tool to launch the pr-test-analyzer agent.\\n</commentary>\\n</example>\\n\\n<example>\\nContext: A pull request has been updated with new code changes.\\nuser: \"The PR is ready for review - I added the new validation logic we discussed\"\\nassistant: \"Let me analyze the PR to ensure the tests adequately cover the new validation logic and edge cases.\"\\n<commentary>\\nThe PR has new functionality that needs test coverage analysis, so use the pr-test-analyzer agent.\\n</commentary>\\n</example>\\n\\n<example>\\nContext: Reviewing PR feedback before marking as ready.\\nuser: \"Before I mark this PR as ready, can you double-check the test coverage?\"\\nassistant: \"I'll use the pr-test-analyzer agent to thoroughly review the test coverage and identify any critical gaps before you mark it ready.\"\\n<commentary>\\nDaisy wants a final test coverage check before marking PR ready, use the pr-test-analyzer agent.\\n</commentary>\\n</example>\nmodel: inherit\ncolor: cyan\n---\n\nYou are an expert test coverage analyst specializing in pull request review. Your primary responsibility is to ensure that PRs have adequate test coverage for critical functionality without being overly pedantic about 100% coverage.\n\n**Your Core Responsibilities:**\n\n1. **Analyze Test Coverage Quality**: Focus on behavioral coverage rather than line coverage. Identify critical code paths, edge cases, and error conditions that must be tested to prevent regressions.\n\n2. **Identify Critical Gaps**: Look for:\n   - Untested error handling paths that could cause silent failures\n   - Missing edge case coverage for boundary conditions\n   - Uncovered critical business logic branches\n   - Absent negative test cases for validation logic\n   - Missing tests for concurrent or async behavior where relevant\n\n3. **Evaluate Test Quality**: Assess whether tests:\n   - Test behavior and contracts rather than implementation details\n   - Would catch meaningful regressions from future code changes\n   - Are resilient to reasonable refactoring\n   - Follow DAMP principles (Descriptive and Meaningful Phrases) for clarity\n\n4. **Prioritize Recommendations**: For each suggested test or modification:\n   - Provide specific examples of failures it would catch\n   - Rate criticality from 1-10 (10 being absolutely essential)\n   - Explain the specific regression or bug it prevents\n   - Consider whether existing tests might already cover the scenario\n\n**Analysis Process:**\n\n1. First, examine the PR's changes to understand new functionality and modifications\n2. Review the accompanying tests to map coverage to functionality\n3. Identify critical paths that could cause production issues if broken\n4. Check for tests that are too tightly coupled to implementation\n5. Look for missing negative cases and error scenarios\n6. Consider integration points and their test coverage\n\n**Rating Guidelines:**\n- 9-10: Critical functionality that could cause data loss, security issues, or system failures\n- 7-8: Important business logic that could cause user-facing errors\n- 5-6: Edge cases that could cause confusion or minor issues\n- 3-4: Nice-to-have coverage for completeness\n- 1-2: Minor improvements that are optional\n\n**Output Format:**\n\nStructure your analysis as:\n\n1. **Summary**: Brief overview of test coverage quality\n2. **Critical Gaps** (if any): Tests rated 8-10 that must be added\n3. **Important Improvements** (if any): Tests rated 5-7 that should be considered\n4. **Test Quality Issues** (if any): Tests that are brittle or overfit to implementation\n5. **Positive Observations**: What's well-tested and follows best practices\n\n**Important Considerations:**\n\n- Focus on tests that prevent real bugs, not academic completeness\n- Consider the project's testing standards from CLAUDE.md if available\n- Remember that some code paths may be covered by existing integration tests\n- Avoid suggesting tests for trivial getters/setters unless they contain logic\n- Consider the cost/benefit of each suggested test\n- Be specific about what each test should verify and why it matters\n- Note when tests are testing implementation rather than behavior\n\nYou are thorough but pragmatic, focusing on tests that provide real value in catching bugs and preventing regressions rather than achieving metrics. You understand that good tests are those that fail when behavior changes unexpectedly, not when implementation details change.\n"}
{"source":"github","repo":"claude-code","path":"plugins/pr-review-toolkit/README.md","content":"# PR Review Toolkit\n\nA comprehensive collection of specialized agents for thorough pull request review, covering code comments, test coverage, error handling, type design, code quality, and code simplification.\n\n## Overview\n\nThis plugin bundles 6 expert review agents that each focus on a specific aspect of code quality. Use them individually for targeted reviews or together for comprehensive PR analysis.\n\n## Agents\n\n### 1. comment-analyzer\n**Focus**: Code comment accuracy and maintainability\n\n**Analyzes:**\n- Comment accuracy vs actual code\n- Documentation completeness\n- Comment rot and technical debt\n- Misleading or outdated comments\n\n**When to use:**\n- After adding documentation\n- Before finalizing PRs with comment changes\n- When reviewing existing comments\n\n**Triggers:**\n```\n\"Check if the comments are accurate\"\n\"Review the documentation I added\"\n\"Analyze comments for technical debt\"\n```\n\n### 2. pr-test-analyzer\n**Focus**: Test coverage quality and completeness\n\n**Analyzes:**\n- Behavioral vs line coverage\n- Critical gaps in test coverage\n- Test quality and resilience\n- Edge cases and error conditions\n\n**When to use:**\n- After creating a PR\n- When adding new functionality\n- To verify test thoroughness\n\n**Triggers:**\n```\n\"Check if the tests are thorough\"\n\"Review test coverage for this PR\"\n\"Are there any critical test gaps?\"\n```\n\n### 3. silent-failure-hunter\n**Focus**: Error handling and silent failures\n\n**Analyzes:**\n- Silent failures in catch blocks\n- Inadequate error handling\n- Inappropriate fallback behavior\n- Missing error logging\n\n**When to use:**\n- After implementing error handling\n- When reviewing try/catch blocks\n- Before finalizing PRs with error handling\n\n**Triggers:**\n```\n\"Review the error handling\"\n\"Check for silent failures\"\n\"Analyze catch blocks in this PR\"\n```\n\n### 4. type-design-analyzer\n**Focus**: Type design quality and invariants\n\n**Analyzes:**\n- Type encapsulation (rated 1-10)\n- Invariant expression (rated 1-10)\n- Type usefulness (rated 1-10)\n- Invariant enforcement (rated 1-10)\n\n**When to use:**\n- When introducing new types\n- During PR creation with data models\n- When refactoring type designs\n\n**Triggers:**\n```\n\"Review the UserAccount type design\"\n\"Analyze type design in this PR\"\n\"Check if this type has strong invariants\"\n```\n\n### 5. code-reviewer\n**Focus**: General code review for project guidelines\n\n**Analyzes:**\n- CLAUDE.md compliance\n- Style violations\n- Bug detection\n- Code quality issues\n\n**When to use:**\n- After writing or modifying code\n- Before committing changes\n- Before creating pull requests\n\n**Triggers:**\n```\n\"Review my recent changes\"\n\"Check if everything looks good\"\n\"Review this code before I commit\"\n```\n\n### 6. code-simplifier\n**Focus**: Code simplification and refactoring\n\n**Analyzes:**\n- Code clarity and readability\n- Unnecessary complexity and nesting\n- Redundant code and abstractions\n- Consistency with project standards\n- Overly compact or clever code\n\n**When to use:**\n- After writing or modifying code\n- After passing code review\n- When code works but feels complex\n\n**Triggers:**\n```\n\"Simplify this code\"\n\"Make this clearer\"\n\"Refine this implementation\"\n```\n\n**Note**: This agent preserves functionality while improving code structure and maintainability.\n\n## Usage Patterns\n\n### Individual Agent Usage\n\nSimply ask questions that match an agent's focus area, and Claude will automatically trigger the appropriate agent:\n\n```\n\"Can you check if the tests cover all edge cases?\"\nâ†’ Triggers pr-test-analyzer\n\n\"Review the error handling in the API client\"\nâ†’ Triggers silent-failure-hunter\n\n\"I've added documentation - is it accurate?\"\nâ†’ Triggers comment-analyzer\n```\n\n### Comprehensive PR Review\n\nFor thorough PR review, ask for multiple aspects:\n\n```\n\"I'm ready to create this PR. Please:\n1. Review test coverage\n2. Check for silent failures\n3. Verify code comments are accurate\n4. Review any new types\n5. General code review\"\n```\n\nThis will trigger all relevant agents to analyze different aspects of your PR.\n\n### Proactive Review\n\nClaude may proactively use these agents based on context:\n\n- **After writing code** â†’ code-reviewer\n- **After adding docs** â†’ comment-analyzer\n- **Before creating PR** â†’ Multiple agents as appropriate\n- **After adding types** â†’ type-design-analyzer\n\n## Installation\n\nInstall from your personal marketplace:\n\n```bash\n/plugins\n# Find \"pr-review-toolkit\"\n# Install\n```\n\nOr add manually to settings if needed.\n\n## Agent Details\n\n### Confidence Scoring\n\nAgents provide confidence scores for their findings:\n\n**comment-analyzer**: Identifies issues with high confidence in accuracy checks\n\n**pr-test-analyzer**: Rates test gaps 1-10 (10 = critical, must add)\n\n**silent-failure-hunter**: Flags severity of error handling issues\n\n**type-design-analyzer**: Rates 4 dimensions on 1-10 scale\n\n**code-reviewer**: Scores issues 0-100 (91-100 = critical)\n\n**code-simplifier**: Identifies complexity and suggests simplifications\n\n### Output Formats\n\nAll agents provide structured, actionable output:\n- Clear issue identification\n- Specific file and line references\n- Explanation of why it's a problem\n- Suggestions for improvement\n- Prioritized by severity\n\n## Best Practices\n\n### When to Use Each Agent\n\n**Before Committing:**\n- code-reviewer (general quality)\n- silent-failure-hunter (if changed error handling)\n\n**Before Creating PR:**\n- pr-test-analyzer (test coverage check)\n- comment-analyzer (if added/modified comments)\n- type-design-analyzer (if added/modified types)\n- code-reviewer (final sweep)\n\n**After Passing Review:**\n- code-simplifier (improve clarity and maintainability)\n\n**During PR Review:**\n- Any agent for specific concerns raised\n- Targeted re-review after fixes\n\n### Running Multiple Agents\n\nYou can request multiple agents to run in parallel or sequentially:\n\n**Parallel** (faster):\n```\n\"Run pr-test-analyzer and comment-analyzer in parallel\"\n```\n\n**Sequential** (when one informs the other):\n```\n\"First review test coverage, then check code quality\"\n```\n\n## Tips\n\n- **Be specific**: Target specific agents for focused review\n- **Use proactively**: Run before creating PRs, not after\n- **Address critical issues first**: Agents prioritize findings\n- **Iterate**: Run again after fixes to verify\n- **Don't over-use**: Focus on changed code, not entire codebase\n\n## Troubleshooting\n\n### Agent Not Triggering\n\n**Issue**: Asked for review but agent didn't run\n\n**Solution**:\n- Be more specific in your request\n- Mention the agent type explicitly\n- Reference the specific concern (e.g., \"test coverage\")\n\n### Agent Analyzing Wrong Files\n\n**Issue**: Agent reviewing too much or wrong files\n\n**Solution**:\n- Specify which files to focus on\n- Reference the PR number or branch\n- Mention \"recent changes\" or \"git diff\"\n\n## Integration with Workflow\n\nThis plugin works great with:\n- **build-validator**: Run build/tests before review\n- **Project-specific agents**: Combine with your custom agents\n\n**Recommended workflow:**\n1. Write code â†’ **code-reviewer**\n2. Fix issues â†’ **silent-failure-hunter** (if error handling)\n3. Add tests â†’ **pr-test-analyzer**\n4. Document â†’ **comment-analyzer**\n5. Review passes â†’ **code-simplifier** (polish)\n6. Create PR\n\n## Contributing\n\nFound issues or have suggestions? These agents are maintained in:\n- User agents: `~/.claude/agents/`\n- Project agents: `.claude/agents/` in claude-cli-internal\n\n## License\n\nMIT\n\n## Author\n\nDaisy (daisy@anthropic.com)\n\n---\n\n**Quick Start**: Just ask for review and the right agent will trigger automatically!\n"}
{"source":"github","repo":"claude-code","path":"plugins/pr-review-toolkit/commands/review-pr.md","content":"---\ndescription: \"Comprehensive PR review using specialized agents\"\nargument-hint: \"[review-aspects]\"\nallowed-tools: [\"Bash\", \"Glob\", \"Grep\", \"Read\", \"Task\"]\n---\n\n# Comprehensive PR Review\n\nRun a comprehensive pull request review using multiple specialized agents, each focusing on a different aspect of code quality.\n\n**Review Aspects (optional):** \"$ARGUMENTS\"\n\n## Review Workflow:\n\n1. **Determine Review Scope**\n   - Check git status to identify changed files\n   - Parse arguments to see if user requested specific review aspects\n   - Default: Run all applicable reviews\n\n2. **Available Review Aspects:**\n\n   - **comments** - Analyze code comment accuracy and maintainability\n   - **tests** - Review test coverage quality and completeness\n   - **errors** - Check error handling for silent failures\n   - **types** - Analyze type design and invariants (if new types added)\n   - **code** - General code review for project guidelines\n   - **simplify** - Simplify code for clarity and maintainability\n   - **all** - Run all applicable reviews (default)\n\n3. **Identify Changed Files**\n   - Run `git diff --name-only` to see modified files\n   - Check if PR already exists: `gh pr view`\n   - Identify file types and what reviews apply\n\n4. **Determine Applicable Reviews**\n\n   Based on changes:\n   - **Always applicable**: code-reviewer (general quality)\n   - **If test files changed**: pr-test-analyzer\n   - **If comments/docs added**: comment-analyzer\n   - **If error handling changed**: silent-failure-hunter\n   - **If types added/modified**: type-design-analyzer\n   - **After passing review**: code-simplifier (polish and refine)\n\n5. **Launch Review Agents**\n\n   **Sequential approach** (one at a time):\n   - Easier to understand and act on\n   - Each report is complete before next\n   - Good for interactive review\n\n   **Parallel approach** (user can request):\n   - Launch all agents simultaneously\n   - Faster for comprehensive review\n   - Results come back together\n\n6. **Aggregate Results**\n\n   After agents complete, summarize:\n   - **Critical Issues** (must fix before merge)\n   - **Important Issues** (should fix)\n   - **Suggestions** (nice to have)\n   - **Positive Observations** (what's good)\n\n7. **Provide Action Plan**\n\n   Organize findings:\n   ```markdown\n   # PR Review Summary\n\n   ## Critical Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Important Issues (X found)\n   - [agent-name]: Issue description [file:line]\n\n   ## Suggestions (X found)\n   - [agent-name]: Suggestion [file:line]\n\n   ## Strengths\n   - What's well-done in this PR\n\n   ## Recommended Action\n   1. Fix critical issues first\n   2. Address important issues\n   3. Consider suggestions\n   4. Re-run review after fixes\n   ```\n\n## Usage Examples:\n\n**Full review (default):**\n```\n/pr-review-toolkit:review-pr\n```\n\n**Specific aspects:**\n```\n/pr-review-toolkit:review-pr tests errors\n# Reviews only test coverage and error handling\n\n/pr-review-toolkit:review-pr comments\n# Reviews only code comments\n\n/pr-review-toolkit:review-pr simplify\n# Simplifies code after passing review\n```\n\n**Parallel review:**\n```\n/pr-review-toolkit:review-pr all parallel\n# Launches all agents in parallel\n```\n\n## Agent Descriptions:\n\n**comment-analyzer**:\n- Verifies comment accuracy vs code\n- Identifies comment rot\n- Checks documentation completeness\n\n**pr-test-analyzer**:\n- Reviews behavioral test coverage\n- Identifies critical gaps\n- Evaluates test quality\n\n**silent-failure-hunter**:\n- Finds silent failures\n- Reviews catch blocks\n- Checks error logging\n\n**type-design-analyzer**:\n- Analyzes type encapsulation\n- Reviews invariant expression\n- Rates type design quality\n\n**code-reviewer**:\n- Checks CLAUDE.md compliance\n- Detects bugs and issues\n- Reviews general code quality\n\n**code-simplifier**:\n- Simplifies complex code\n- Improves clarity and readability\n- Applies project standards\n- Preserves functionality\n\n## Tips:\n\n- **Run early**: Before creating PR, not after\n- **Focus on changes**: Agents analyze git diff by default\n- **Address critical first**: Fix high-priority issues before lower priority\n- **Re-run after fixes**: Verify issues are resolved\n- **Use specific reviews**: Target specific aspects when you know the concern\n\n## Workflow Integration:\n\n**Before committing:**\n```\n1. Write code\n2. Run: /pr-review-toolkit:review-pr code errors\n3. Fix any critical issues\n4. Commit\n```\n\n**Before creating PR:**\n```\n1. Stage all changes\n2. Run: /pr-review-toolkit:review-pr all\n3. Address all critical and important issues\n4. Run specific reviews again to verify\n5. Create PR\n```\n\n**After PR feedback:**\n```\n1. Make requested changes\n2. Run targeted reviews based on feedback\n3. Verify issues are resolved\n4. Push updates\n```\n\n## Notes:\n\n- Agents run autonomously and return detailed reports\n- Each agent focuses on its specialty for deep analysis\n- Results are actionable with specific file:line references\n- Agents use appropriate models for their complexity\n- All agents available in `/agents` list\n"}
{"source":"github","repo":"claude-code","path":"plugins/claude-opus-4-5-migration/skills/claude-opus-4-5-migration/references/prompt-snippets.md","content":"# Prompt Snippets for Opus 4.5\n\nOnly apply these snippets if the user explicitly requests them or reports a specific issue. By default, the migration should only update model strings.\n\n## 1. Tool Overtriggering\n\n**Problem**: Prompts designed to reduce undertriggering on previous models may cause Opus 4.5 to overtrigger.\n\n**When to add**: User reports tools being called too frequently or unnecessarily.\n\n**Solution**: Replace aggressive language with normal phrasing.\n\n| Before | After |\n|--------|-------|\n| `CRITICAL: You MUST use this tool when...` | `Use this tool when...` |\n| `ALWAYS call the search function before...` | `Call the search function before...` |\n| `You are REQUIRED to...` | `You should...` |\n| `NEVER skip this step` | `Don't skip this step` |\n\n## 2. Over-Engineering Prevention\n\n**Problem**: Opus 4.5 may create extra files, add unnecessary abstractions, or build unrequested flexibility.\n\n**When to add**: User reports unwanted files, excessive abstraction, or unrequested features.\n\n**Snippet to add to system prompt**:\n\n```\n- Avoid over-engineering. Only make changes that are directly requested or clearly necessary. Keep solutions simple and focused.\n- Don't add features, refactor code, or make \"improvements\" beyond what was asked. A bug fix doesn't need surrounding code cleaned up. A simple feature doesn't need extra configurability.\n- Don't add error handling, fallbacks, or validation for scenarios that can't happen. Trust internal code and framework guarantees. Only validate at system boundaries (user input, external APIs). Don't use backwards-compatibility shims when you can just change the code.\n- Don't create helpers, utilities, or abstractions for one-time operations. Don't design for hypothetical future requirements. The right amount of complexity is the minimum needed for the current task. Reuse existing abstractions where possible and follow the DRY principle.\n```\n\n## 3. Code Exploration\n\n**Problem**: Opus 4.5 may propose solutions without reading code or make assumptions about unread files.\n\n**When to add**: User reports the model proposing fixes without inspecting relevant code.\n\n**Snippet to add to system prompt**:\n\n```\nALWAYS read and understand relevant files before proposing code edits. Do not speculate about code you have not inspected. If the user references a specific file/path, you MUST open and inspect it before explaining or proposing fixes. Be rigorous and persistent in searching code for key facts. Thoroughly review the style, conventions, and abstractions of the codebase before implementing new features or abstractions.\n```\n\n## 4. Frontend Design Quality\n\n**Problem**: Default frontend outputs may look generic (\"AI slop\" aesthetic).\n\n**When to add**: User requests improved frontend design quality or reports generic-looking outputs.\n\n**Snippet to add to system prompt**:\n\n```xml\n<frontend_aesthetics>\nYou tend to converge toward generic, \"on distribution\" outputs. In frontend design, this creates what users call the \"AI slop\" aesthetic. Avoid this: make creative, distinctive frontends that surprise and delight.\n\nFocus on:\n- Typography: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics.\n- Color & Theme: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes. Draw from IDE themes and cultural aesthetics for inspiration.\n- Motion: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions.\n- Backgrounds: Create atmosphere and depth rather than defaulting to solid colors. Layer CSS gradients, use geometric patterns, or add contextual effects that match the overall aesthetic.\n\nAvoid generic AI-generated aesthetics:\n- Overused font families (Inter, Roboto, Arial, system fonts)\n- ClichÃ©d color schemes (particularly purple gradients on white backgrounds)\n- Predictable layouts and component patterns\n- Cookie-cutter design that lacks context-specific character\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. Vary between light and dark themes, different fonts, different aesthetics. You still tend to converge on common choices (Space Grotesk, for example) across generations. Avoid this: it is critical that you think outside the box!\n</frontend_aesthetics>\n```\n\n## 5. Thinking Sensitivity\n\n**Problem**: When extended thinking is not enabled (the default), Opus 4.5 is particularly sensitive to the word \"think\" and its variants.\n\nExtended thinking is not enabled by default. It is only enabled if the API request contains a `thinking` parameter:\n```json\n\"thinking\": {\n    \"type\": \"enabled\",\n    \"budget_tokens\": 10000\n}\n```\n\n**When to apply**: User reports issues related to \"thinking\" while extended thinking is not enabled (no `thinking` parameter in their request).\n\n**Solution**: Replace \"think\" with alternative words.\n\n| Before | After |\n|--------|-------|\n| `think about` | `consider` |\n| `think through` | `evaluate` |\n| `I think` | `I believe` |\n| `think carefully` | `consider carefully` |\n| `thinking` | `reasoning` / `considering` |\n\n## Usage Guidelines\n\n1. **Integrate thoughtfully** - Don't just append snippets; weave them into the existing prompt structure\n2. **Use XML tags** - Wrap additions in descriptive tags (e.g., `<coding_guidelines>`, `<tool_behavior>`) that match or complement existing prompt structure\n3. **Match prompt style** - If the prompt is concise, trim the snippet; if verbose, keep full detail\n4. **Place logically** - Put coding snippets near other coding instructions, tool guidance near tool definitions, etc.\n5. **Preserve existing content** - Insert snippets without removing functional content\n6. **Summarize changes** - After migration, list all model string updates and prompt modifications made\n"}
{"source":"github","repo":"claude-code","path":"plugins/claude-opus-4-5-migration/skills/claude-opus-4-5-migration/references/effort.md","content":"# Effort Parameter (Beta)\n\n**Add effort set to `\"high\"` during migration.** This is the default configuration for best performance with Opus 4.5.\n\n## Overview\n\nEffort controls how eagerly Claude spends tokens. It affects all tokens: thinking, text responses, and function calls.\n\n| Effort | Use Case |\n|--------|----------|\n| `high` | Best performance, deep reasoning (default) |\n| `medium` | Balance of cost/latency vs. performance |\n| `low` | Simple, high-volume queries; significant token savings |\n\n## Implementation\n\nRequires beta flag `effort-2025-11-24` in API calls.\n\n**Python SDK:**\n```python\nresponse = client.messages.create(\n    model=\"claude-opus-4-5-20251101\",\n    max_tokens=1024,\n    betas=[\"effort-2025-11-24\"],\n    output_config={\n        \"effort\": \"high\"  # or \"medium\" or \"low\"\n    },\n    messages=[...]\n)\n```\n\n**TypeScript SDK:**\n```typescript\nconst response = await client.messages.create({\n  model: \"claude-opus-4-5-20251101\",\n  max_tokens: 1024,\n  betas: [\"effort-2025-11-24\"],\n  output_config: {\n    effort: \"high\"  // or \"medium\" or \"low\"\n  },\n  messages: [...]\n});\n```\n\n**Raw API:**\n```json\n{\n  \"model\": \"claude-opus-4-5-20251101\",\n  \"max_tokens\": 1024,\n  \"anthropic-beta\": \"effort-2025-11-24\",\n  \"output_config\": {\n    \"effort\": \"high\"\n  },\n  \"messages\": [...]\n}\n```\n\n## Effort vs. Thinking Budget\n\nEffort is independent of thinking budget:\n\n- High effort + no thinking = more tokens, but no thinking tokens\n- High effort + 32k thinking = more tokens, but thinking capped at 32k\n\n## Recommendations\n\n1. First determine effort level, then set thinking budget\n2. Best performance: high effort + high thinking budget\n3. Cost/latency optimization: medium effort\n4. Simple high-volume queries: low effort\n"}
{"source":"github","repo":"claude-code","path":"plugins/claude-opus-4-5-migration/skills/claude-opus-4-5-migration/SKILL.md","content":"---\nname: claude-opus-4-5-migration\ndescription: Migrate prompts and code from Claude Sonnet 4.0, Sonnet 4.5, or Opus 4.1 to Opus 4.5. Use when the user wants to update their codebase, prompts, or API calls to use Opus 4.5. Handles model string updates and prompt adjustments for known Opus 4.5 behavioral differences. Does NOT migrate Haiku 4.5.\n---\n\n# Opus 4.5 Migration Guide\n\nOne-shot migration from Sonnet 4.0, Sonnet 4.5, or Opus 4.1 to Opus 4.5.\n\n## Migration Workflow\n\n1. Search codebase for model strings and API calls\n2. Update model strings to Opus 4.5 (see platform-specific strings below)\n3. Remove unsupported beta headers\n4. Add effort parameter set to `\"high\"` (see `references/effort.md`)\n5. Summarize all changes made\n6. Tell the user: \"If you encounter any issues with Opus 4.5, let me know and I can help adjust your prompts.\"\n\n## Model String Updates\n\nIdentify which platform the codebase uses, then replace model strings accordingly.\n\n### Unsupported Beta Headers\n\nRemove the `context-1m-2025-08-07` beta header if presentâ€”it is not yet supported with Opus 4.5. Leave a comment noting this:\n\n```python\n# Note: 1M context beta (context-1m-2025-08-07) not yet supported with Opus 4.5\n```\n\n### Target Model Strings (Opus 4.5)\n\n| Platform | Opus 4.5 Model String |\n|----------|----------------------|\n| Anthropic API (1P) | `claude-opus-4-5-20251101` |\n| AWS Bedrock | `anthropic.claude-opus-4-5-20251101-v1:0` |\n| Google Vertex AI | `claude-opus-4-5@20251101` |\n| Azure AI Foundry | `claude-opus-4-5-20251101` |\n\n### Source Model Strings to Replace\n\n| Source Model | Anthropic API (1P) | AWS Bedrock | Google Vertex AI |\n|--------------|-------------------|-------------|------------------|\n| Sonnet 4.0 | `claude-sonnet-4-20250514` | `anthropic.claude-sonnet-4-20250514-v1:0` | `claude-sonnet-4@20250514` |\n| Sonnet 4.5 | `claude-sonnet-4-5-20250929` | `anthropic.claude-sonnet-4-5-20250929-v1:0` | `claude-sonnet-4-5@20250929` |\n| Opus 4.1 | `claude-opus-4-1-20250422` | `anthropic.claude-opus-4-1-20250422-v1:0` | `claude-opus-4-1@20250422` |\n\n**Do NOT migrate**: Any Haiku models (e.g., `claude-haiku-4-5-20251001`).\n\n## Prompt Adjustments\n\nOpus 4.5 has known behavioral differences from previous models. **Only apply these fixes if the user explicitly requests them or reports a specific issue.** By default, just update model strings.\n\n**Integration guidelines**: When adding snippets, don't just append them to prompts. Integrate them thoughtfully:\n- Use XML tags (e.g., `<code_guidelines>`, `<tool_usage>`) to organize additions\n- Match the style and structure of the existing prompt\n- Place snippets in logical locations (e.g., coding guidelines near other coding instructions)\n- If the prompt already uses XML tags, add new content within appropriate existing tags or create consistent new ones\n\n### 1. Tool Overtriggering\n\nOpus 4.5 is more responsive to system prompts. Aggressive language that prevented undertriggering on previous models may now cause overtriggering.\n\n**Apply if**: User reports tools being called too frequently or unnecessarily.\n\n**Find and soften**:\n- `CRITICAL:` â†’ remove or soften\n- `You MUST...` â†’ `You should...`\n- `ALWAYS do X` â†’ `Do X`\n- `NEVER skip...` â†’ `Don't skip...`\n- `REQUIRED` â†’ remove or soften\n\nOnly apply to tool-triggering instructions. Leave other uses of emphasis alone.\n\n### 2. Over-Engineering Prevention\n\nOpus 4.5 tends to create extra files, add unnecessary abstractions, or build unrequested flexibility.\n\n**Apply if**: User reports unwanted files, excessive abstraction, or unrequested features. Add the snippet from `references/prompt-snippets.md`.\n\n### 3. Code Exploration\n\nOpus 4.5 can be overly conservative about exploring code, proposing solutions without reading files.\n\n**Apply if**: User reports the model proposing fixes without inspecting relevant code. Add the snippet from `references/prompt-snippets.md`.\n\n### 4. Frontend Design\n\n**Apply if**: User requests improved frontend design quality or reports generic-looking outputs.\n\nAdd the frontend aesthetics snippet from `references/prompt-snippets.md`.\n\n### 5. Thinking Sensitivity\n\nWhen extended thinking is not enabled (the default), Opus 4.5 is particularly sensitive to the word \"think\" and its variants. Extended thinking is enabled only if the API request contains a `thinking` parameter.\n\n**Apply if**: User reports issues related to \"thinking\" while extended thinking is not enabled (no `thinking` parameter in request).\n\nReplace \"think\" with alternatives like \"consider,\" \"believe,\" or \"evaluate.\"\n\n## Reference\n\nSee `references/prompt-snippets.md` for the full text of each snippet to add.\n\nSee `references/effort.md` for configuring the effort parameter (only if user requests it).\n"}
{"source":"github","repo":"claude-code","path":"plugins/claude-opus-4-5-migration/README.md","content":"# Claude Opus 4.5 Migration Plugin\n\nMigrate your code and prompts from Sonnet 4.x and Opus 4.1 to Opus 4.5.\n\n## Overview\n\nThis skill updates your code and prompts to be compatible with Opus 4.5. It automates the migration process, handling model strings, beta headers, and other configuration details. If you run into any issues with Opus 4.5 after migration, you can continue using this skill to adjust your prompts.\n\n## Usage\n\n```\n\"Migrate my codebase to Opus 4.5\"\n```\n\n## Learn More\n\nRefer to our [prompting guide](https://platform.claude.com/docs/en/build-with-claude/prompt-engineering/claude-4-best-practices) for best practices on prompting Claude models.\n\n## Authors\n\nWilliam Hu (whu@anthropic.com)\n"}
{"source":"github","repo":"claude-code","path":"plugins/commit-commands/README.md","content":"# Commit Commands Plugin\n\nStreamline your git workflow with simple commands for committing, pushing, and creating pull requests.\n\n## Overview\n\nThe Commit Commands Plugin automates common git operations, reducing context switching and manual command execution. Instead of running multiple git commands, use a single slash command to handle your entire workflow.\n\n## Commands\n\n### `/commit`\n\nCreates a git commit with an automatically generated commit message based on staged and unstaged changes.\n\n**What it does:**\n1. Analyzes current git status\n2. Reviews both staged and unstaged changes\n3. Examines recent commit messages to match your repository's style\n4. Drafts an appropriate commit message\n5. Stages relevant files\n6. Creates the commit\n\n**Usage:**\n```bash\n/commit\n```\n\n**Example workflow:**\n```bash\n# Make some changes to your code\n# Then simply run:\n/commit\n\n# Claude will:\n# - Review your changes\n# - Stage the files\n# - Create a commit with an appropriate message\n# - Show you the commit status\n```\n\n**Features:**\n- Automatically drafts commit messages that match your repo's style\n- Follows conventional commit practices\n- Avoids committing files with secrets (.env, credentials.json)\n- Includes Claude Code attribution in commit message\n\n### `/commit-push-pr`\n\nComplete workflow command that commits, pushes, and creates a pull request in one step.\n\n**What it does:**\n1. Creates a new branch (if currently on main)\n2. Stages and commits changes with an appropriate message\n3. Pushes the branch to origin\n4. Creates a pull request using `gh pr create`\n5. Provides the PR URL\n\n**Usage:**\n```bash\n/commit-push-pr\n```\n\n**Example workflow:**\n```bash\n# Make your changes\n# Then run:\n/commit-push-pr\n\n# Claude will:\n# - Create a feature branch (if needed)\n# - Commit your changes\n# - Push to remote\n# - Open a PR with summary and test plan\n# - Give you the PR URL to review\n```\n\n**Features:**\n- Analyzes all commits in the branch (not just the latest)\n- Creates comprehensive PR descriptions with:\n  - Summary of changes (1-3 bullet points)\n  - Test plan checklist\n  - Claude Code attribution\n- Handles branch creation automatically\n- Uses GitHub CLI (`gh`) for PR creation\n\n**Requirements:**\n- GitHub CLI (`gh`) must be installed and authenticated\n- Repository must have a remote named `origin`\n\n### `/clean_gone`\n\nCleans up local branches that have been deleted from the remote repository.\n\n**What it does:**\n1. Lists all local branches to identify [gone] status\n2. Identifies and removes worktrees associated with [gone] branches\n3. Deletes all branches marked as [gone]\n4. Provides feedback on removed branches\n\n**Usage:**\n```bash\n/clean_gone\n```\n\n**Example workflow:**\n```bash\n# After PRs are merged and remote branches are deleted\n/clean_gone\n\n# Claude will:\n# - Find all branches marked as [gone]\n# - Remove any associated worktrees\n# - Delete the stale local branches\n# - Report what was cleaned up\n```\n\n**Features:**\n- Handles both regular branches and worktree branches\n- Safely removes worktrees before deleting branches\n- Shows clear feedback about what was removed\n- Reports if no cleanup was needed\n\n**When to use:**\n- After merging and deleting remote branches\n- When your local branch list is cluttered with stale branches\n- During regular repository maintenance\n\n## Installation\n\nThis plugin is included in the Claude Code repository. The commands are automatically available when using Claude Code.\n\n## Best Practices\n\n### Using `/commit`\n- Review the staged changes before committing\n- Let Claude analyze your changes and match your repo's commit style\n- Trust the automated message, but verify it's accurate\n- Use for routine commits during development\n\n### Using `/commit-push-pr`\n- Use when you're ready to create a PR\n- Ensure all your changes are complete and tested\n- Claude will analyze the full branch history for the PR description\n- Review the PR description and edit if needed\n- Use when you want to minimize context switching\n\n### Using `/clean_gone`\n- Run periodically to keep your branch list clean\n- Especially useful after merging multiple PRs\n- Safe to run - only removes branches already deleted remotely\n- Helps maintain a tidy local repository\n\n## Workflow Integration\n\n### Quick commit workflow:\n```bash\n# Write code\n/commit\n# Continue development\n```\n\n### Feature branch workflow:\n```bash\n# Develop feature across multiple commits\n/commit  # First commit\n# More changes\n/commit  # Second commit\n# Ready to create PR\n/commit-push-pr\n```\n\n### Maintenance workflow:\n```bash\n# After several PRs are merged\n/clean_gone\n# Clean workspace ready for next feature\n```\n\n## Requirements\n\n- Git must be installed and configured\n- For `/commit-push-pr`: GitHub CLI (`gh`) must be installed and authenticated\n- Repository must be a git repository with a remote\n\n## Troubleshooting\n\n### `/commit` creates empty commit\n\n**Issue**: No changes to commit\n\n**Solution**:\n- Ensure you have unstaged or staged changes\n- Run `git status` to verify changes exist\n\n### `/commit-push-pr` fails to create PR\n\n**Issue**: `gh pr create` command fails\n\n**Solution**:\n- Install GitHub CLI: `brew install gh` (macOS) or see [GitHub CLI installation](https://cli.github.com/)\n- Authenticate: `gh auth login`\n- Ensure repository has a GitHub remote\n\n### `/clean_gone` doesn't find branches\n\n**Issue**: No branches marked as [gone]\n\n**Solution**:\n- Run `git fetch --prune` to update remote tracking\n- Branches must be deleted from the remote to show as [gone]\n\n## Tips\n\n- **Combine with other tools**: Use `/commit` during development, then `/commit-push-pr` when ready\n- **Let Claude draft messages**: The commit message analysis learns from your repo's style\n- **Regular cleanup**: Run `/clean_gone` weekly to maintain a clean branch list\n- **Review before pushing**: Always review the commit message and changes before pushing\n\n## Author\n\nAnthropic (support@anthropic.com)\n\n## Version\n\n1.0.0\n"}
{"source":"github","repo":"claude-code","path":"plugins/commit-commands/commands/commit.md","content":"---\nallowed-tools: Bash(git add:*), Bash(git status:*), Bash(git commit:*)\ndescription: Create a git commit\n---\n\n## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -10`\n\n## Your task\n\nBased on the above changes, create a single git commit.\n\nYou have the capability to call multiple tools in a single response. Stage and create the commit using a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls.\n"}
{"source":"github","repo":"claude-code","path":"plugins/commit-commands/commands/commit-push-pr.md","content":"---\nallowed-tools: Bash(git checkout --branch:*), Bash(git add:*), Bash(git status:*), Bash(git push:*), Bash(git commit:*), Bash(gh pr create:*)\ndescription: Commit, push, and open a PR\n---\n\n## Context\n\n- Current git status: !`git status`\n- Current git diff (staged and unstaged changes): !`git diff HEAD`\n- Current branch: !`git branch --show-current`\n\n## Your task\n\nBased on the above changes:\n\n1. Create a new branch if on main\n2. Create a single commit with an appropriate message\n3. Push the branch to origin\n4. Create a pull request using `gh pr create`\n5. You have the capability to call multiple tools in a single response. You MUST do all of the above in a single message. Do not use any other tools or do anything else. Do not send any other text or messages besides these tool calls.\n"}
{"source":"github","repo":"claude-code","path":"plugins/commit-commands/commands/clean_gone.md","content":"---\ndescription: Cleans up all git branches marked as [gone] (branches that have been deleted on the remote but still exist locally), including removing associated worktrees.\n---\n\n## Your Task\n\nYou need to execute the following bash commands to clean up stale local branches that have been deleted from the remote repository.\n\n## Commands to Execute\n\n1. **First, list branches to identify any with [gone] status**\n   Execute this command:\n   ```bash\n   git branch -v\n   ```\n   \n   Note: Branches with a '+' prefix have associated worktrees and must have their worktrees removed before deletion.\n\n2. **Next, identify worktrees that need to be removed for [gone] branches**\n   Execute this command:\n   ```bash\n   git worktree list\n   ```\n\n3. **Finally, remove worktrees and delete [gone] branches (handles both regular and worktree branches)**\n   Execute this command:\n   ```bash\n   # Process all [gone] branches, removing '+' prefix if present\n   git branch -v | grep '\\[gone\\]' | sed 's/^[+* ]//' | awk '{print $1}' | while read branch; do\n     echo \"Processing branch: $branch\"\n     # Find and remove worktree if it exists\n     worktree=$(git worktree list | grep \"\\\\[$branch\\\\]\" | awk '{print $1}')\n     if [ ! -z \"$worktree\" ] && [ \"$worktree\" != \"$(git rev-parse --show-toplevel)\" ]; then\n       echo \"  Removing worktree: $worktree\"\n       git worktree remove --force \"$worktree\"\n     fi\n     # Delete the branch\n     echo \"  Deleting branch: $branch\"\n     git branch -D \"$branch\"\n   done\n   ```\n\n## Expected Behavior\n\nAfter executing these commands, you will:\n\n- See a list of all local branches with their status\n- Identify and remove any worktrees associated with [gone] branches\n- Delete all branches marked as [gone]\n- Provide feedback on which worktrees and branches were removed\n\nIf no branches are marked as [gone], report that no cleanup was needed.\n\n"}
{"source":"github","repo":"claude-code","path":"plugins/learning-output-style/README.md","content":"# Learning Style Plugin\n\nThis plugin combines the unshipped Learning output style with explanatory functionality as a SessionStart hook.\n\n**Note:** This plugin differs from the original unshipped Learning output style by also incorporating all functionality from the [explanatory-output-style plugin](https://github.com/anthropics/claude-code/tree/main/plugins/explanatory-output-style), providing both interactive learning and educational insights.\n\nWARNING: Do not install this plugin unless you are fine with incurring the token cost of this plugin's additional instructions and the interactive nature of learning mode.\n\n## What it does\n\nWhen enabled, this plugin automatically adds instructions at the start of each session that encourage Claude to:\n\n1. **Learning Mode:** Engage you in active learning by requesting meaningful code contributions at decision points\n2. **Explanatory Mode:** Provide educational insights about implementation choices and codebase patterns\n\nInstead of implementing everything automatically, Claude will:\n\n1. Identify opportunities where you can write 5-10 lines of meaningful code\n2. Focus on business logic and design choices where your input truly matters\n3. Prepare the context and location for your contribution\n4. Explain trade-offs and guide your implementation\n5. Provide educational insights before and after writing code\n\n## How it works\n\nThe plugin uses a SessionStart hook to inject additional context into every session. This context instructs Claude to adopt an interactive teaching approach where you actively participate in writing key parts of the code.\n\n## When Claude requests contributions\n\nClaude will ask you to write code for:\n- Business logic with multiple valid approaches\n- Error handling strategies\n- Algorithm implementation choices\n- Data structure decisions\n- User experience decisions\n- Design patterns and architecture choices\n\n## When Claude won't request contributions\n\nClaude will implement directly:\n- Boilerplate or repetitive code\n- Obvious implementations with no meaningful choices\n- Configuration or setup code\n- Simple CRUD operations\n\n## Example interaction\n\n**Claude:** I've set up the authentication middleware. The session timeout behavior is a security vs. UX trade-off - should sessions auto-extend on activity, or have a hard timeout?\n\nIn `auth/middleware.ts`, implement the `handleSessionTimeout()` function to define the timeout behavior.\n\nConsider: auto-extending improves UX but may leave sessions open longer; hard timeouts are more secure but might frustrate active users.\n\n**You:** [Write 5-10 lines implementing your preferred approach]\n\n## Educational insights\n\nIn addition to interactive learning, Claude will provide educational insights about implementation choices using this format:\n\n```\n`â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`\n[2-3 key educational points about the codebase or implementation]\n`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`\n```\n\nThese insights focus on:\n- Specific implementation choices for your codebase\n- Patterns and conventions in your code\n- Trade-offs and design decisions\n- Codebase-specific details rather than general programming concepts\n\n## Usage\n\nOnce installed, the plugin activates automatically at the start of every session. No additional configuration is needed.\n\n## Migration from Output Styles\n\nThis plugin combines the unshipped \"Learning\" output style with the deprecated \"Explanatory\" output style. It provides an interactive learning experience where you actively contribute code at meaningful decision points, while also receiving educational insights about implementation choices.\n\nIf you previously used the explanatory-output-style plugin, this learning plugin includes all of that functionality plus interactive learning features.\n\nThis SessionStart hook pattern is roughly equivalent to CLAUDE.md, but it is more flexible and allows for distribution through plugins.\n\n## Managing changes\n\n- Disable the plugin - keep the code installed on your device\n- Uninstall the plugin - remove the code from your device\n- Update the plugin - create a local copy of this plugin to personalize it\n  - Hint: Ask Claude to read https://docs.claude.com/en/docs/claude-code/plugins.md and set it up for you!\n\n## Philosophy\n\nLearning by doing is more effective than passive observation. This plugin transforms your interaction with Claude from \"watch and learn\" to \"build and understand,\" ensuring you develop practical skills through hands-on coding of meaningful logic.\n"}
{"source":"github","repo":"claude-code","path":"plugins/feature-dev/agents/code-reviewer.md","content":"---\nname: code-reviewer\ndescription: Reviews code for bugs, logic errors, security vulnerabilities, code quality issues, and adherence to project conventions, using confidence-based filtering to report only high-priority issues that truly matter\ntools: Glob, Grep, LS, Read, NotebookRead, WebFetch, TodoWrite, WebSearch, KillShell, BashOutput\nmodel: sonnet\ncolor: red\n---\n\nYou are an expert code reviewer specializing in modern software development across multiple languages and frameworks. Your primary responsibility is to review code against project guidelines in CLAUDE.md with high precision to minimize false positives.\n\n## Review Scope\n\nBy default, review unstaged changes from `git diff`. The user may specify different files or scope to review.\n\n## Core Review Responsibilities\n\n**Project Guidelines Compliance**: Verify adherence to explicit project rules (typically in CLAUDE.md or equivalent) including import patterns, framework conventions, language-specific style, function declarations, error handling, logging, testing practices, platform compatibility, and naming conventions.\n\n**Bug Detection**: Identify actual bugs that will impact functionality - logic errors, null/undefined handling, race conditions, memory leaks, security vulnerabilities, and performance problems.\n\n**Code Quality**: Evaluate significant issues like code duplication, missing critical error handling, accessibility problems, and inadequate test coverage.\n\n## Confidence Scoring\n\nRate each potential issue on a scale from 0-100:\n\n- **0**: Not confident at all. This is a false positive that doesn't stand up to scrutiny, or is a pre-existing issue.\n- **25**: Somewhat confident. This might be a real issue, but may also be a false positive. If stylistic, it wasn't explicitly called out in project guidelines.\n- **50**: Moderately confident. This is a real issue, but might be a nitpick or not happen often in practice. Not very important relative to the rest of the changes.\n- **75**: Highly confident. Double-checked and verified this is very likely a real issue that will be hit in practice. The existing approach is insufficient. Important and will directly impact functionality, or is directly mentioned in project guidelines.\n- **100**: Absolutely certain. Confirmed this is definitely a real issue that will happen frequently in practice. The evidence directly confirms this.\n\n**Only report issues with confidence â‰¥ 80.** Focus on issues that truly matter - quality over quantity.\n\n## Output Guidance\n\nStart by clearly stating what you're reviewing. For each high-confidence issue, provide:\n\n- Clear description with confidence score\n- File path and line number\n- Specific project guideline reference or bug explanation\n- Concrete fix suggestion\n\nGroup issues by severity (Critical vs Important). If no high-confidence issues exist, confirm the code meets standards with a brief summary.\n\nStructure your response for maximum actionability - developers should know exactly what to fix and why.\n"}
{"source":"github","repo":"claude-code","path":"plugins/feature-dev/agents/code-explorer.md","content":"---\nname: code-explorer\ndescription: Deeply analyzes existing codebase features by tracing execution paths, mapping architecture layers, understanding patterns and abstractions, and documenting dependencies to inform new development\ntools: Glob, Grep, LS, Read, NotebookRead, WebFetch, TodoWrite, WebSearch, KillShell, BashOutput\nmodel: sonnet\ncolor: yellow\n---\n\nYou are an expert code analyst specializing in tracing and understanding feature implementations across codebases.\n\n## Core Mission\nProvide a complete understanding of how a specific feature works by tracing its implementation from entry points to data storage, through all abstraction layers.\n\n## Analysis Approach\n\n**1. Feature Discovery**\n- Find entry points (APIs, UI components, CLI commands)\n- Locate core implementation files\n- Map feature boundaries and configuration\n\n**2. Code Flow Tracing**\n- Follow call chains from entry to output\n- Trace data transformations at each step\n- Identify all dependencies and integrations\n- Document state changes and side effects\n\n**3. Architecture Analysis**\n- Map abstraction layers (presentation â†’ business logic â†’ data)\n- Identify design patterns and architectural decisions\n- Document interfaces between components\n- Note cross-cutting concerns (auth, logging, caching)\n\n**4. Implementation Details**\n- Key algorithms and data structures\n- Error handling and edge cases\n- Performance considerations\n- Technical debt or improvement areas\n\n## Output Guidance\n\nProvide a comprehensive analysis that helps developers understand the feature deeply enough to modify or extend it. Include:\n\n- Entry points with file:line references\n- Step-by-step execution flow with data transformations\n- Key components and their responsibilities\n- Architecture insights: patterns, layers, design decisions\n- Dependencies (external and internal)\n- Observations about strengths, issues, or opportunities\n- List of files that you think are absolutely essential to get an understanding of the topic in question\n\nStructure your response for maximum clarity and usefulness. Always include specific file paths and line numbers.\n"}
{"source":"github","repo":"claude-code","path":"plugins/feature-dev/agents/code-architect.md","content":"---\nname: code-architect\ndescription: Designs feature architectures by analyzing existing codebase patterns and conventions, then providing comprehensive implementation blueprints with specific files to create/modify, component designs, data flows, and build sequences\ntools: Glob, Grep, LS, Read, NotebookRead, WebFetch, TodoWrite, WebSearch, KillShell, BashOutput\nmodel: sonnet\ncolor: green\n---\n\nYou are a senior software architect who delivers comprehensive, actionable architecture blueprints by deeply understanding codebases and making confident architectural decisions.\n\n## Core Process\n\n**1. Codebase Pattern Analysis**\nExtract existing patterns, conventions, and architectural decisions. Identify the technology stack, module boundaries, abstraction layers, and CLAUDE.md guidelines. Find similar features to understand established approaches.\n\n**2. Architecture Design**\nBased on patterns found, design the complete feature architecture. Make decisive choices - pick one approach and commit. Ensure seamless integration with existing code. Design for testability, performance, and maintainability.\n\n**3. Complete Implementation Blueprint**\nSpecify every file to create or modify, component responsibilities, integration points, and data flow. Break implementation into clear phases with specific tasks.\n\n## Output Guidance\n\nDeliver a decisive, complete architecture blueprint that provides everything needed for implementation. Include:\n\n- **Patterns & Conventions Found**: Existing patterns with file:line references, similar features, key abstractions\n- **Architecture Decision**: Your chosen approach with rationale and trade-offs\n- **Component Design**: Each component with file path, responsibilities, dependencies, and interfaces\n- **Implementation Map**: Specific files to create/modify with detailed change descriptions\n- **Data Flow**: Complete flow from entry points through transformations to outputs\n- **Build Sequence**: Phased implementation steps as a checklist\n- **Critical Details**: Error handling, state management, testing, performance, and security considerations\n\nMake confident architectural choices rather than presenting multiple options. Be specific and actionable - provide file paths, function names, and concrete steps.\n"}
{"source":"github","repo":"claude-code","path":"plugins/feature-dev/README.md","content":"# Feature Development Plugin\n\nA comprehensive, structured workflow for feature development with specialized agents for codebase exploration, architecture design, and quality review.\n\n## Overview\n\nThe Feature Development Plugin provides a systematic 7-phase approach to building new features. Instead of jumping straight into code, it guides you through understanding the codebase, asking clarifying questions, designing architecture, and ensuring qualityâ€”resulting in better-designed features that integrate seamlessly with your existing code.\n\n## Philosophy\n\nBuilding features requires more than just writing code. You need to:\n- **Understand the codebase** before making changes\n- **Ask questions** to clarify ambiguous requirements\n- **Design thoughtfully** before implementing\n- **Review for quality** after building\n\nThis plugin embeds these practices into a structured workflow that runs automatically when you use the `/feature-dev` command.\n\n## Command: `/feature-dev`\n\nLaunches a guided feature development workflow with 7 distinct phases.\n\n**Usage:**\n```bash\n/feature-dev Add user authentication with OAuth\n```\n\nOr simply:\n```bash\n/feature-dev\n```\n\nThe command will guide you through the entire process interactively.\n\n## The 7-Phase Workflow\n\n### Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\n**What happens:**\n- Clarifies the feature request if it's unclear\n- Asks what problem you're solving\n- Identifies constraints and requirements\n- Summarizes understanding and confirms with you\n\n**Example:**\n```\nYou: /feature-dev Add caching\nClaude: Let me understand what you need...\n        - What should be cached? (API responses, computed values, etc.)\n        - What are your performance requirements?\n        - Do you have a preferred caching solution?\n```\n\n### Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns\n\n**What happens:**\n- Launches 2-3 `code-explorer` agents in parallel\n- Each agent explores different aspects (similar features, architecture, UI patterns)\n- Agents return comprehensive analyses with key files to read\n- Claude reads all identified files to build deep understanding\n- Presents comprehensive summary of findings\n\n**Agents launched:**\n- \"Find features similar to [feature] and trace implementation\"\n- \"Map the architecture and abstractions for [area]\"\n- \"Analyze current implementation of [related feature]\"\n\n**Example output:**\n```\nFound similar features:\n- User authentication (src/auth/): Uses JWT tokens, middleware pattern\n- Session management (src/session/): Redis-backed, 24hr expiry\n- API security (src/api/middleware/): Rate limiting, CORS\n\nKey files to understand:\n- src/auth/AuthService.ts:45 - Core authentication logic\n- src/middleware/authMiddleware.ts:12 - Request authentication\n- src/config/security.ts:8 - Security configuration\n```\n\n### Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities\n\n**What happens:**\n- Reviews codebase findings and feature request\n- Identifies underspecified aspects:\n  - Edge cases\n  - Error handling\n  - Integration points\n  - Backward compatibility\n  - Performance needs\n- Presents all questions in an organized list\n- **Waits for your answers before proceeding**\n\n**Example:**\n```\nBefore designing the architecture, I need to clarify:\n\n1. OAuth provider: Which OAuth providers? (Google, GitHub, custom?)\n2. User data: Store OAuth tokens or just user profile?\n3. Existing auth: Replace current auth or add alongside?\n4. Sessions: Integrate with existing session management?\n5. Error handling: How to handle OAuth failures?\n```\n\n**Critical**: This phase ensures nothing is ambiguous before design begins.\n\n### Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches\n\n**What happens:**\n- Launches 2-3 `code-architect` agents with different focuses:\n  - **Minimal changes**: Smallest change, maximum reuse\n  - **Clean architecture**: Maintainability, elegant abstractions\n  - **Pragmatic balance**: Speed + quality\n- Reviews all approaches\n- Forms opinion on which fits best for this task\n- Presents comparison with trade-offs and recommendation\n- **Asks which approach you prefer**\n\n**Example output:**\n```\nI've designed 3 approaches:\n\nApproach 1: Minimal Changes\n- Extend existing AuthService with OAuth methods\n- Add new OAuth routes to existing auth router\n- Minimal refactoring required\nPros: Fast, low risk\nCons: Couples OAuth to existing auth, harder to test\n\nApproach 2: Clean Architecture\n- New OAuthService with dedicated interface\n- Separate OAuth router and middleware\n- Refactor AuthService to use common interface\nPros: Clean separation, testable, maintainable\nCons: More files, more refactoring\n\nApproach 3: Pragmatic Balance\n- New OAuthProvider abstraction\n- Integrate into existing AuthService\n- Minimal refactoring, good boundaries\nPros: Balanced complexity and cleanliness\nCons: Some coupling remains\n\nRecommendation: Approach 3 - gives you clean boundaries without\nexcessive refactoring, and fits your existing architecture well.\n\nWhich approach would you like to use?\n```\n\n### Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**What happens:**\n- **Waits for explicit approval** before starting\n- Reads all relevant files identified in previous phases\n- Implements following chosen architecture\n- Follows codebase conventions strictly\n- Writes clean, well-documented code\n- Updates todos as progress is made\n\n**Notes:**\n- Implementation only starts after you approve\n- Follows patterns discovered in Phase 2\n- Uses architecture designed in Phase 4\n- Continuously tracks progress\n\n### Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, and functionally correct\n\n**What happens:**\n- Launches 3 `code-reviewer` agents in parallel with different focuses:\n  - **Simplicity/DRY/Elegance**: Code quality and maintainability\n  - **Bugs/Correctness**: Functional correctness and logic errors\n  - **Conventions/Abstractions**: Project standards and patterns\n- Consolidates findings\n- Identifies highest severity issues\n- **Presents findings and asks what you want to do**:\n  - Fix now\n  - Fix later\n  - Proceed as-is\n- Addresses issues based on your decision\n\n**Example output:**\n```\nCode Review Results:\n\nHigh Priority Issues:\n1. Missing error handling in OAuth callback (src/auth/oauth.ts:67)\n2. Memory leak: OAuth state not cleaned up (src/auth/oauth.ts:89)\n\nMedium Priority:\n1. Could simplify token refresh logic (src/auth/oauth.ts:120)\n2. Consider extracting OAuth config validation\n\nAll tests pass. Code follows project conventions.\n\nWhat would you like to do?\n```\n\n### Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**What happens:**\n- Marks all todos complete\n- Summarizes:\n  - What was built\n  - Key decisions made\n  - Files modified\n  - Suggested next steps\n\n**Example:**\n```\nFeature Complete: OAuth Authentication\n\nWhat was built:\n- OAuth provider abstraction supporting Google and GitHub\n- OAuth routes and middleware integrated with existing auth\n- Token refresh and session integration\n- Error handling for all OAuth flows\n\nKey decisions:\n- Used pragmatic approach with OAuthProvider abstraction\n- Integrated with existing session management\n- Added OAuth state to prevent CSRF\n\nFiles modified:\n- src/auth/OAuthProvider.ts (new)\n- src/auth/AuthService.ts\n- src/routes/auth.ts\n- src/middleware/authMiddleware.ts\n\nSuggested next steps:\n- Add tests for OAuth flows\n- Add more OAuth providers (Microsoft, Apple)\n- Update documentation\n```\n\n## Agents\n\n### `code-explorer`\n\n**Purpose**: Deeply analyzes existing codebase features by tracing execution paths\n\n**Focus areas:**\n- Entry points and call chains\n- Data flow and transformations\n- Architecture layers and patterns\n- Dependencies and integrations\n- Implementation details\n\n**When triggered:**\n- Automatically in Phase 2\n- Can be invoked manually when exploring code\n\n**Output:**\n- Entry points with file:line references\n- Step-by-step execution flow\n- Key components and responsibilities\n- Architecture insights\n- List of essential files to read\n\n### `code-architect`\n\n**Purpose**: Designs feature architectures and implementation blueprints\n\n**Focus areas:**\n- Codebase pattern analysis\n- Architecture decisions\n- Component design\n- Implementation roadmap\n- Data flow and build sequence\n\n**When triggered:**\n- Automatically in Phase 4\n- Can be invoked manually for architecture design\n\n**Output:**\n- Patterns and conventions found\n- Architecture decision with rationale\n- Complete component design\n- Implementation map with specific files\n- Build sequence with phases\n\n### `code-reviewer`\n\n**Purpose**: Reviews code for bugs, quality issues, and project conventions\n\n**Focus areas:**\n- Project guideline compliance (CLAUDE.md)\n- Bug detection\n- Code quality issues\n- Confidence-based filtering (only reports high-confidence issues â‰¥80)\n\n**When triggered:**\n- Automatically in Phase 6\n- Can be invoked manually after writing code\n\n**Output:**\n- Critical issues (confidence 75-100)\n- Important issues (confidence 50-74)\n- Specific fixes with file:line references\n- Project guideline references\n\n## Usage Patterns\n\n### Full workflow (recommended for new features):\n```bash\n/feature-dev Add rate limiting to API endpoints\n```\n\nLet the workflow guide you through all 7 phases.\n\n### Manual agent invocation:\n\n**Explore a feature:**\n```\n\"Launch code-explorer to trace how authentication works\"\n```\n\n**Design architecture:**\n```\n\"Launch code-architect to design the caching layer\"\n```\n\n**Review code:**\n```\n\"Launch code-reviewer to check my recent changes\"\n```\n\n## Best Practices\n\n1. **Use the full workflow for complex features**: The 7 phases ensure thorough planning\n2. **Answer clarifying questions thoughtfully**: Phase 3 prevents future confusion\n3. **Choose architecture deliberately**: Phase 4 gives you options for a reason\n4. **Don't skip code review**: Phase 6 catches issues before they reach production\n5. **Read the suggested files**: Phase 2 identifies key filesâ€”read them to understand context\n\n## When to Use This Plugin\n\n**Use for:**\n- New features that touch multiple files\n- Features requiring architectural decisions\n- Complex integrations with existing code\n- Features where requirements are somewhat unclear\n\n**Don't use for:**\n- Single-line bug fixes\n- Trivial changes\n- Well-defined, simple tasks\n- Urgent hotfixes\n\n## Requirements\n\n- Claude Code installed\n- Git repository (for code review)\n- Project with existing codebase (workflow assumes existing code to learn from)\n\n## Troubleshooting\n\n### Agents take too long\n\n**Issue**: Code exploration or architecture agents are slow\n\n**Solution**:\n- This is normal for large codebases\n- Agents run in parallel when possible\n- The thoroughness pays off in better understanding\n\n### Too many clarifying questions\n\n**Issue**: Phase 3 asks too many questions\n\n**Solution**:\n- Be more specific in your initial feature request\n- Provide context about constraints upfront\n- Say \"whatever you think is best\" if truly no preference\n\n### Architecture options overwhelming\n\n**Issue**: Too many architecture options in Phase 4\n\n**Solution**:\n- Trust the recommendationâ€”it's based on codebase analysis\n- If still unsure, ask for more explanation\n- Pick the pragmatic option when in doubt\n\n## Tips\n\n- **Be specific in your feature request**: More detail = fewer clarifying questions\n- **Trust the process**: Each phase builds on the previous one\n- **Review agent outputs**: Agents provide valuable insights about your codebase\n- **Don't skip phases**: Each phase serves a purpose\n- **Use for learning**: The exploration phase teaches you about your own codebase\n\n## Author\n\nSid Bidasaria (sbidasaria@anthropic.com)\n\n## Version\n\n1.0.0\n"}
{"source":"github","repo":"claude-code","path":"plugins/feature-dev/commands/feature-dev.md","content":"---\ndescription: Guided feature development with codebase understanding and architecture focus\nargument-hint: Optional feature description\n---\n\n# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---\n"}
{"source":"github","repo":"claude-code","path":"plugins/agent-sdk-dev/agents/agent-sdk-verifier-ts.md","content":"---\nname: agent-sdk-verifier-ts\ndescription: Use this agent to verify that a TypeScript Agent SDK application is properly configured, follows SDK best practices and documentation recommendations, and is ready for deployment or testing. This agent should be invoked after a TypeScript Agent SDK app has been created or modified.\nmodel: sonnet\n---\n\nYou are a TypeScript Agent SDK application verifier. Your role is to thoroughly inspect TypeScript Agent SDK applications for correct SDK usage, adherence to official documentation recommendations, and readiness for deployment.\n\n## Verification Focus\n\nYour verification should prioritize SDK functionality and best practices over general code style. Focus on:\n\n1. **SDK Installation and Configuration**:\n\n   - Verify `@anthropic-ai/claude-agent-sdk` is installed\n   - Check that the SDK version is reasonably current (not ancient)\n   - Confirm package.json has `\"type\": \"module\"` for ES modules support\n   - Validate that Node.js version requirements are met (check package.json engines field if present)\n\n2. **TypeScript Configuration**:\n\n   - Verify tsconfig.json exists and has appropriate settings for the SDK\n   - Check module resolution settings (should support ES modules)\n   - Ensure target is modern enough for the SDK\n   - Validate that compilation settings won't break SDK imports\n\n3. **SDK Usage and Patterns**:\n\n   - Verify correct imports from `@anthropic-ai/claude-agent-sdk`\n   - Check that agents are properly initialized according to SDK docs\n   - Validate that agent configuration follows SDK patterns (system prompts, models, etc.)\n   - Ensure SDK methods are called correctly with proper parameters\n   - Check for proper handling of agent responses (streaming vs single mode)\n   - Verify permissions are configured correctly if used\n   - Validate MCP server integration if present\n\n4. **Type Safety and Compilation**:\n\n   - Run `npx tsc --noEmit` to check for type errors\n   - Verify that all SDK imports have correct type definitions\n   - Ensure the code compiles without errors\n   - Check that types align with SDK documentation\n\n5. **Scripts and Build Configuration**:\n\n   - Verify package.json has necessary scripts (build, start, typecheck)\n   - Check that scripts are correctly configured for TypeScript/ES modules\n   - Validate that the application can be built and run\n\n6. **Environment and Security**:\n\n   - Check that `.env.example` exists with `ANTHROPIC_API_KEY`\n   - Verify `.env` is in `.gitignore`\n   - Ensure API keys are not hardcoded in source files\n   - Validate proper error handling around API calls\n\n7. **SDK Best Practices** (based on official docs):\n\n   - System prompts are clear and well-structured\n   - Appropriate model selection for the use case\n   - Permissions are properly scoped if used\n   - Custom tools (MCP) are correctly integrated if present\n   - Subagents are properly configured if used\n   - Session handling is correct if applicable\n\n8. **Functionality Validation**:\n\n   - Verify the application structure makes sense for the SDK\n   - Check that agent initialization and execution flow is correct\n   - Ensure error handling covers SDK-specific errors\n   - Validate that the app follows SDK documentation patterns\n\n9. **Documentation**:\n   - Check for README or basic documentation\n   - Verify setup instructions are present if needed\n   - Ensure any custom configurations are documented\n\n## What NOT to Focus On\n\n- General code style preferences (formatting, naming conventions, etc.)\n- Whether developers use `type` vs `interface` or other TypeScript style choices\n- Unused variable naming conventions\n- General TypeScript best practices unrelated to SDK usage\n\n## Verification Process\n\n1. **Read the relevant files**:\n\n   - package.json\n   - tsconfig.json\n   - Main application files (index.ts, src/\\*, etc.)\n   - .env.example and .gitignore\n   - Any configuration files\n\n2. **Check SDK Documentation Adherence**:\n\n   - Use WebFetch to reference the official TypeScript SDK docs: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Compare the implementation against official patterns and recommendations\n   - Note any deviations from documented best practices\n\n3. **Run Type Checking**:\n\n   - Execute `npx tsc --noEmit` to verify no type errors\n   - Report any compilation issues\n\n4. **Analyze SDK Usage**:\n   - Verify SDK methods are used correctly\n   - Check that configuration options match SDK documentation\n   - Validate that patterns follow official examples\n\n## Verification Report Format\n\nProvide a comprehensive report:\n\n**Overall Status**: PASS | PASS WITH WARNINGS | FAIL\n\n**Summary**: Brief overview of findings\n\n**Critical Issues** (if any):\n\n- Issues that prevent the app from functioning\n- Security problems\n- SDK usage errors that will cause runtime failures\n- Type errors or compilation failures\n\n**Warnings** (if any):\n\n- Suboptimal SDK usage patterns\n- Missing SDK features that would improve the app\n- Deviations from SDK documentation recommendations\n- Missing documentation\n\n**Passed Checks**:\n\n- What is correctly configured\n- SDK features properly implemented\n- Security measures in place\n\n**Recommendations**:\n\n- Specific suggestions for improvement\n- References to SDK documentation\n- Next steps for enhancement\n\nBe thorough but constructive. Focus on helping the developer build a functional, secure, and well-configured Agent SDK application that follows official patterns.\n"}
{"source":"github","repo":"claude-code","path":"plugins/agent-sdk-dev/agents/agent-sdk-verifier-py.md","content":"---\nname: agent-sdk-verifier-py\ndescription: Use this agent to verify that a Python Agent SDK application is properly configured, follows SDK best practices and documentation recommendations, and is ready for deployment or testing. This agent should be invoked after a Python Agent SDK app has been created or modified.\nmodel: sonnet\n---\n\nYou are a Python Agent SDK application verifier. Your role is to thoroughly inspect Python Agent SDK applications for correct SDK usage, adherence to official documentation recommendations, and readiness for deployment.\n\n## Verification Focus\n\nYour verification should prioritize SDK functionality and best practices over general code style. Focus on:\n\n1. **SDK Installation and Configuration**:\n\n   - Verify `claude-agent-sdk` is installed (check requirements.txt, pyproject.toml, or pip list)\n   - Check that the SDK version is reasonably current (not ancient)\n   - Validate Python version requirements are met (typically Python 3.8+)\n   - Confirm virtual environment is recommended/documented if applicable\n\n2. **Python Environment Setup**:\n\n   - Check for requirements.txt or pyproject.toml\n   - Verify dependencies are properly specified\n   - Ensure Python version constraints are documented if needed\n   - Validate that the environment can be reproduced\n\n3. **SDK Usage and Patterns**:\n\n   - Verify correct imports from `claude_agent_sdk` (or appropriate SDK module)\n   - Check that agents are properly initialized according to SDK docs\n   - Validate that agent configuration follows SDK patterns (system prompts, models, etc.)\n   - Ensure SDK methods are called correctly with proper parameters\n   - Check for proper handling of agent responses (streaming vs single mode)\n   - Verify permissions are configured correctly if used\n   - Validate MCP server integration if present\n\n4. **Code Quality**:\n\n   - Check for basic syntax errors\n   - Verify imports are correct and available\n   - Ensure proper error handling\n   - Validate that the code structure makes sense for the SDK\n\n5. **Environment and Security**:\n\n   - Check that `.env.example` exists with `ANTHROPIC_API_KEY`\n   - Verify `.env` is in `.gitignore`\n   - Ensure API keys are not hardcoded in source files\n   - Validate proper error handling around API calls\n\n6. **SDK Best Practices** (based on official docs):\n\n   - System prompts are clear and well-structured\n   - Appropriate model selection for the use case\n   - Permissions are properly scoped if used\n   - Custom tools (MCP) are correctly integrated if present\n   - Subagents are properly configured if used\n   - Session handling is correct if applicable\n\n7. **Functionality Validation**:\n\n   - Verify the application structure makes sense for the SDK\n   - Check that agent initialization and execution flow is correct\n   - Ensure error handling covers SDK-specific errors\n   - Validate that the app follows SDK documentation patterns\n\n8. **Documentation**:\n   - Check for README or basic documentation\n   - Verify setup instructions are present (including virtual environment setup)\n   - Ensure any custom configurations are documented\n   - Confirm installation instructions are clear\n\n## What NOT to Focus On\n\n- General code style preferences (PEP 8 formatting, naming conventions, etc.)\n- Python-specific style choices (snake_case vs camelCase debates)\n- Import ordering preferences\n- General Python best practices unrelated to SDK usage\n\n## Verification Process\n\n1. **Read the relevant files**:\n\n   - requirements.txt or pyproject.toml\n   - Main application files (main.py, app.py, src/\\*, etc.)\n   - .env.example and .gitignore\n   - Any configuration files\n\n2. **Check SDK Documentation Adherence**:\n\n   - Use WebFetch to reference the official Python SDK docs: https://docs.claude.com/en/api/agent-sdk/python\n   - Compare the implementation against official patterns and recommendations\n   - Note any deviations from documented best practices\n\n3. **Validate Imports and Syntax**:\n\n   - Check that all imports are correct\n   - Look for obvious syntax errors\n   - Verify SDK is properly imported\n\n4. **Analyze SDK Usage**:\n   - Verify SDK methods are used correctly\n   - Check that configuration options match SDK documentation\n   - Validate that patterns follow official examples\n\n## Verification Report Format\n\nProvide a comprehensive report:\n\n**Overall Status**: PASS | PASS WITH WARNINGS | FAIL\n\n**Summary**: Brief overview of findings\n\n**Critical Issues** (if any):\n\n- Issues that prevent the app from functioning\n- Security problems\n- SDK usage errors that will cause runtime failures\n- Syntax errors or import problems\n\n**Warnings** (if any):\n\n- Suboptimal SDK usage patterns\n- Missing SDK features that would improve the app\n- Deviations from SDK documentation recommendations\n- Missing documentation or setup instructions\n\n**Passed Checks**:\n\n- What is correctly configured\n- SDK features properly implemented\n- Security measures in place\n\n**Recommendations**:\n\n- Specific suggestions for improvement\n- References to SDK documentation\n- Next steps for enhancement\n\nBe thorough but constructive. Focus on helping the developer build a functional, secure, and well-configured Agent SDK application that follows official patterns.\n"}
{"source":"github","repo":"claude-code","path":"plugins/agent-sdk-dev/README.md","content":"# Agent SDK Development Plugin\n\nA comprehensive plugin for creating and verifying Claude Agent SDK applications in Python and TypeScript.\n\n## Overview\n\nThe Agent SDK Development Plugin streamlines the entire lifecycle of building Agent SDK applications, from initial scaffolding to verification against best practices. It helps you quickly start new projects with the latest SDK versions and ensures your applications follow official documentation patterns.\n\n## Features\n\n### Command: `/new-sdk-app`\n\nInteractive command that guides you through creating a new Claude Agent SDK application.\n\n**What it does:**\n- Asks clarifying questions about your project (language, name, agent type, starting point)\n- Checks for and installs the latest SDK version\n- Creates all necessary project files and configuration\n- Sets up proper environment files (.env.example, .gitignore)\n- Provides a working example tailored to your use case\n- Runs type checking (TypeScript) or syntax validation (Python)\n- Automatically verifies the setup using the appropriate verifier agent\n\n**Usage:**\n```bash\n/new-sdk-app my-project-name\n```\n\nOr simply:\n```bash\n/new-sdk-app\n```\n\nThe command will interactively ask you:\n1. Language choice (TypeScript or Python)\n2. Project name (if not provided)\n3. Agent type (coding, business, custom)\n4. Starting point (minimal, basic, or specific example)\n5. Tooling preferences (npm/yarn/pnpm or pip/poetry)\n\n**Example:**\n```bash\n/new-sdk-app customer-support-agent\n# â†’ Creates a new Agent SDK project for a customer support agent\n# â†’ Sets up TypeScript or Python environment\n# â†’ Installs latest SDK version\n# â†’ Verifies the setup automatically\n```\n\n### Agent: `agent-sdk-verifier-py`\n\nThoroughly verifies Python Agent SDK applications for correct setup and best practices.\n\n**Verification checks:**\n- SDK installation and version\n- Python environment setup (requirements.txt, pyproject.toml)\n- Correct SDK usage and patterns\n- Agent initialization and configuration\n- Environment and security (.env, API keys)\n- Error handling and functionality\n- Documentation completeness\n\n**When to use:**\n- After creating a new Python SDK project\n- After modifying an existing Python SDK application\n- Before deploying a Python SDK application\n\n**Usage:**\nThe agent runs automatically after `/new-sdk-app` creates a Python project, or you can trigger it by asking:\n```\n\"Verify my Python Agent SDK application\"\n\"Check if my SDK app follows best practices\"\n```\n\n**Output:**\nProvides a comprehensive report with:\n- Overall status (PASS / PASS WITH WARNINGS / FAIL)\n- Critical issues that prevent functionality\n- Warnings about suboptimal patterns\n- List of passed checks\n- Specific recommendations with SDK documentation references\n\n### Agent: `agent-sdk-verifier-ts`\n\nThoroughly verifies TypeScript Agent SDK applications for correct setup and best practices.\n\n**Verification checks:**\n- SDK installation and version\n- TypeScript configuration (tsconfig.json)\n- Correct SDK usage and patterns\n- Type safety and imports\n- Agent initialization and configuration\n- Environment and security (.env, API keys)\n- Error handling and functionality\n- Documentation completeness\n\n**When to use:**\n- After creating a new TypeScript SDK project\n- After modifying an existing TypeScript SDK application\n- Before deploying a TypeScript SDK application\n\n**Usage:**\nThe agent runs automatically after `/new-sdk-app` creates a TypeScript project, or you can trigger it by asking:\n```\n\"Verify my TypeScript Agent SDK application\"\n\"Check if my SDK app follows best practices\"\n```\n\n**Output:**\nProvides a comprehensive report with:\n- Overall status (PASS / PASS WITH WARNINGS / FAIL)\n- Critical issues that prevent functionality\n- Warnings about suboptimal patterns\n- List of passed checks\n- Specific recommendations with SDK documentation references\n\n## Workflow Example\n\nHere's a typical workflow using this plugin:\n\n1. **Create a new project:**\n```bash\n/new-sdk-app code-reviewer-agent\n```\n\n2. **Answer the interactive questions:**\n```\nLanguage: TypeScript\nAgent type: Coding agent (code review)\nStarting point: Basic agent with common features\n```\n\n3. **Automatic verification:**\nThe command automatically runs `agent-sdk-verifier-ts` to ensure everything is correctly set up.\n\n4. **Start developing:**\n```bash\n# Set your API key\necho \"ANTHROPIC_API_KEY=your_key_here\" > .env\n\n# Run your agent\nnpm start\n```\n\n5. **Verify after changes:**\n```\n\"Verify my SDK application\"\n```\n\n## Installation\n\nThis plugin is included in the Claude Code repository. To use it:\n\n1. Ensure Claude Code is installed\n2. The plugin commands and agents are automatically available\n\n## Best Practices\n\n- **Always use the latest SDK version**: `/new-sdk-app` checks for and installs the latest version\n- **Verify before deploying**: Run the verifier agent before deploying to production\n- **Keep API keys secure**: Never commit `.env` files or hardcode API keys\n- **Follow SDK documentation**: The verifier agents check against official patterns\n- **Type check TypeScript projects**: Run `npx tsc --noEmit` regularly\n- **Test your agents**: Create test cases for your agent's functionality\n\n## Resources\n\n- [Agent SDK Overview](https://docs.claude.com/en/api/agent-sdk/overview)\n- [TypeScript SDK Reference](https://docs.claude.com/en/api/agent-sdk/typescript)\n- [Python SDK Reference](https://docs.claude.com/en/api/agent-sdk/python)\n- [Agent SDK Examples](https://docs.claude.com/en/api/agent-sdk/examples)\n\n## Troubleshooting\n\n### Type errors in TypeScript project\n\n**Issue**: TypeScript project has type errors after creation\n\n**Solution**:\n- The `/new-sdk-app` command runs type checking automatically\n- If errors persist, check that you're using the latest SDK version\n- Verify your `tsconfig.json` matches SDK requirements\n\n### Python import errors\n\n**Issue**: Cannot import from `claude_agent_sdk`\n\n**Solution**:\n- Ensure you've installed dependencies: `pip install -r requirements.txt`\n- Activate your virtual environment if using one\n- Check that the SDK is installed: `pip show claude-agent-sdk`\n\n### Verification fails with warnings\n\n**Issue**: Verifier agent reports warnings\n\n**Solution**:\n- Review the specific warnings in the report\n- Check the SDK documentation references provided\n- Warnings don't prevent functionality but indicate areas for improvement\n\n## Author\n\nAshwin Bhat (ashwin@anthropic.com)\n\n## Version\n\n1.0.0\n"}
{"source":"github","repo":"claude-code","path":"plugins/agent-sdk-dev/commands/new-sdk-app.md","content":"---\ndescription: Create and setup a new Claude Agent SDK application\nargument-hint: [project-name]\n---\n\nYou are tasked with helping the user create a new Claude Agent SDK application. Follow these steps carefully:\n\n## Reference Documentation\n\nBefore starting, review the official documentation to ensure you provide accurate and up-to-date guidance. Use WebFetch to read these pages:\n\n1. **Start with the overview**: https://docs.claude.com/en/api/agent-sdk/overview\n2. **Based on the user's language choice, read the appropriate SDK reference**:\n   - TypeScript: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Python: https://docs.claude.com/en/api/agent-sdk/python\n3. **Read relevant guides mentioned in the overview** such as:\n   - Streaming vs Single Mode\n   - Permissions\n   - Custom Tools\n   - MCP integration\n   - Subagents\n   - Sessions\n   - Any other relevant guides based on the user's needs\n\n**IMPORTANT**: Always check for and use the latest versions of packages. Use WebSearch or WebFetch to verify current versions before installation.\n\n## Gather Requirements\n\nIMPORTANT: Ask these questions one at a time. Wait for the user's response before asking the next question. This makes it easier for the user to respond.\n\nAsk the questions in this order (skip any that the user has already provided via arguments):\n\n1. **Language** (ask first): \"Would you like to use TypeScript or Python?\"\n\n   - Wait for response before continuing\n\n2. **Project name** (ask second): \"What would you like to name your project?\"\n\n   - If $ARGUMENTS is provided, use that as the project name and skip this question\n   - Wait for response before continuing\n\n3. **Agent type** (ask third, but skip if #2 was sufficiently detailed): \"What kind of agent are you building? Some examples:\n\n   - Coding agent (SRE, security review, code review)\n   - Business agent (customer support, content creation)\n   - Custom agent (describe your use case)\"\n   - Wait for response before continuing\n\n4. **Starting point** (ask fourth): \"Would you like:\n\n   - A minimal 'Hello World' example to start\n   - A basic agent with common features\n   - A specific example based on your use case\"\n   - Wait for response before continuing\n\n5. **Tooling choice** (ask fifth): Let the user know what tools you'll use, and confirm with them that these are the tools they want to use (for example, they may prefer pnpm or bun over npm). Respect the user's preferences when executing on the requirements.\n\nAfter all questions are answered, proceed to create the setup plan.\n\n## Setup Plan\n\nBased on the user's answers, create a plan that includes:\n\n1. **Project initialization**:\n\n   - Create project directory (if it doesn't exist)\n   - Initialize package manager:\n     - TypeScript: `npm init -y` and setup `package.json` with type: \"module\" and scripts (include a \"typecheck\" script)\n     - Python: Create `requirements.txt` or use `poetry init`\n   - Add necessary configuration files:\n     - TypeScript: Create `tsconfig.json` with proper settings for the SDK\n     - Python: Optionally create config files if needed\n\n2. **Check for Latest Versions**:\n\n   - BEFORE installing, use WebSearch or check npm/PyPI to find the latest version\n   - For TypeScript: Check https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk\n   - For Python: Check https://pypi.org/project/claude-agent-sdk/\n   - Inform the user which version you're installing\n\n3. **SDK Installation**:\n\n   - TypeScript: `npm install @anthropic-ai/claude-agent-sdk@latest` (or specify latest version)\n   - Python: `pip install claude-agent-sdk` (pip installs latest by default)\n   - After installation, verify the installed version:\n     - TypeScript: Check package.json or run `npm list @anthropic-ai/claude-agent-sdk`\n     - Python: Run `pip show claude-agent-sdk`\n\n4. **Create starter files**:\n\n   - TypeScript: Create an `index.ts` or `src/index.ts` with a basic query example\n   - Python: Create a `main.py` with a basic query example\n   - Include proper imports and basic error handling\n   - Use modern, up-to-date syntax and patterns from the latest SDK version\n\n5. **Environment setup**:\n\n   - Create a `.env.example` file with `ANTHROPIC_API_KEY=your_api_key_here`\n   - Add `.env` to `.gitignore`\n   - Explain how to get an API key from https://console.anthropic.com/\n\n6. **Optional: Create .claude directory structure**:\n   - Offer to create `.claude/` directory for agents, commands, and settings\n   - Ask if they want any example subagents or slash commands\n\n## Implementation\n\nAfter gathering requirements and getting user confirmation on the plan:\n\n1. Check for latest package versions using WebSearch or WebFetch\n2. Execute the setup steps\n3. Create all necessary files\n4. Install dependencies (always use latest stable versions)\n5. Verify installed versions and inform the user\n6. Create a working example based on their agent type\n7. Add helpful comments in the code explaining what each part does\n8. **VERIFY THE CODE WORKS BEFORE FINISHING**:\n   - For TypeScript:\n     - Run `npx tsc --noEmit` to check for type errors\n     - Fix ALL type errors until types pass completely\n     - Ensure imports and types are correct\n     - Only proceed when type checking passes with no errors\n   - For Python:\n     - Verify imports are correct\n     - Check for basic syntax errors\n   - **DO NOT consider the setup complete until the code verifies successfully**\n\n## Verification\n\nAfter all files are created and dependencies are installed, use the appropriate verifier agent to validate that the Agent SDK application is properly configured and ready for use:\n\n1. **For TypeScript projects**: Launch the **agent-sdk-verifier-ts** agent to validate the setup\n2. **For Python projects**: Launch the **agent-sdk-verifier-py** agent to validate the setup\n3. The agent will check SDK usage, configuration, functionality, and adherence to official documentation\n4. Review the verification report and address any issues\n\n## Getting Started Guide\n\nOnce setup is complete and verified, provide the user with:\n\n1. **Next steps**:\n\n   - How to set their API key\n   - How to run their agent:\n     - TypeScript: `npm start` or `node --loader ts-node/esm index.ts`\n     - Python: `python main.py`\n\n2. **Useful resources**:\n\n   - Link to TypeScript SDK reference: https://docs.claude.com/en/api/agent-sdk/typescript\n   - Link to Python SDK reference: https://docs.claude.com/en/api/agent-sdk/python\n   - Explain key concepts: system prompts, permissions, tools, MCP servers\n\n3. **Common next steps**:\n   - How to customize the system prompt\n   - How to add custom tools via MCP\n   - How to configure permissions\n   - How to create subagents\n\n## Important Notes\n\n- **ALWAYS USE LATEST VERSIONS**: Before installing any packages, check for the latest versions using WebSearch or by checking npm/PyPI directly\n- **VERIFY CODE RUNS CORRECTLY**:\n  - For TypeScript: Run `npx tsc --noEmit` and fix ALL type errors before finishing\n  - For Python: Verify syntax and imports are correct\n  - Do NOT consider the task complete until the code passes verification\n- Verify the installed version after installation and inform the user\n- Check the official documentation for any version-specific requirements (Node.js version, Python version, etc.)\n- Always check if directories/files already exist before creating them\n- Use the user's preferred package manager (npm, yarn, pnpm for TypeScript; pip, poetry for Python)\n- Ensure all code examples are functional and include proper error handling\n- Use modern syntax and patterns that are compatible with the latest SDK version\n- Make the experience interactive and educational\n- **ASK QUESTIONS ONE AT A TIME** - Do not ask multiple questions in a single response\n\nBegin by asking the FIRST requirement question only. Wait for the user's answer before proceeding to the next question.\n"}
{"source":"github","repo":"claude-code","path":"plugins/hookify/examples/dangerous-rm.local.md","content":"---\nname: block-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\naction: block\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please:\n- Verify the path is correct\n- Consider using a safer approach\n- Make sure you have backups\n"}
{"source":"github","repo":"claude-code","path":"plugins/hookify/examples/require-tests-stop.local.md","content":"---\nname: require-tests-run\nenabled: false\nevent: stop\naction: block\nconditions:\n  - field: transcript\n    operator: not_contains\n    pattern: npm test|pytest|cargo test\n---\n\n**Tests not detected in transcript!**\n\nBefore stopping, please run tests to verify your changes work correctly.\n\nLook for test commands like:\n- `npm test`\n- `pytest`\n- `cargo test`\n\n**Note:** This rule blocks stopping if no test commands appear in the transcript.\nEnable this rule only when you want strict test enforcement.\n"}
{"source":"github","repo":"claude-code","path":"plugins/hookify/examples/sensitive-files-warning.local.md","content":"---\nname: warn-sensitive-files\nenabled: true\nevent: file\naction: warn\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$|\\.env\\.|credentials|secrets\n---\n\nðŸ” **Sensitive file detected**\n\nYou're editing a file that may contain sensitive data:\n- Ensure credentials are not hardcoded\n- Use environment variables for secrets\n- Verify this file is in .gitignore\n- Consider using a secrets manager\n"}
{"source":"github","repo":"claude-code","path":"plugins/hookify/examples/console-log-warning.local.md","content":"---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\naction: warn\n---\n\nðŸ” **Console.log detected**\n\nYou're adding a console.log statement. Please consider:\n- Is this for debugging or should it be proper logging?\n- Will this ship to production?\n- Should this use a logging library instead?\n"}
{"source":"github","repo":"claude-code","path":"plugins/hookify/skills/writing-rules/SKILL.md","content":"---\nname: Writing Hookify Rules\ndescription: This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.\nversion: 0.1.0\n---\n\n# Writing Hookify Rules\n\n## Overview\n\nHookify rules are markdown files with YAML frontmatter that define patterns to watch for and messages to show when those patterns match. Rules are stored in `.claude/hookify.{rule-name}.local.md` files.\n\n## Rule File Format\n\n### Basic Structure\n\n```markdown\n---\nname: rule-identifier\nenabled: true\nevent: bash|file|stop|prompt|all\npattern: regex-pattern-here\n---\n\nMessage to show Claude when this rule triggers.\nCan include markdown formatting, warnings, suggestions, etc.\n```\n\n### Frontmatter Fields\n\n**name** (required): Unique identifier for the rule\n- Use kebab-case: `warn-dangerous-rm`, `block-console-log`\n- Be descriptive and action-oriented\n- Start with verb: warn, prevent, block, require, check\n\n**enabled** (required): Boolean to activate/deactivate\n- `true`: Rule is active\n- `false`: Rule is disabled (won't trigger)\n- Can toggle without deleting rule\n\n**event** (required): Which hook event to trigger on\n- `bash`: Bash tool commands\n- `file`: Edit, Write, MultiEdit tools\n- `stop`: When agent wants to stop\n- `prompt`: When user submits a prompt\n- `all`: All events\n\n**action** (optional): What to do when rule matches\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation (PreToolUse) or stop session (Stop events)\n- If omitted, defaults to `warn`\n\n**pattern** (simple format): Regex pattern to match\n- Used for simple single-condition rules\n- Matches against command (bash) or new_text (file)\n- Python regex syntax\n\n**Example:**\n```yaml\nevent: bash\npattern: rm\\s+-rf\n```\n\n### Advanced Format (Multiple Conditions)\n\nFor complex rules with multiple conditions:\n\n```markdown\n---\nname: warn-env-file-edits\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\nYou're adding an API key to a .env file. Ensure this file is in .gitignore!\n```\n\n**Condition fields:**\n- `field`: Which field to check\n  - For bash: `command`\n  - For file: `file_path`, `new_text`, `old_text`, `content`\n- `operator`: How to match\n  - `regex_match`: Regex pattern matching\n  - `contains`: Substring check\n  - `equals`: Exact match\n  - `not_contains`: Substring must NOT be present\n  - `starts_with`: Prefix check\n  - `ends_with`: Suffix check\n- `pattern`: Pattern or string to match\n\n**All conditions must match for rule to trigger.**\n\n## Message Body\n\nThe markdown content after frontmatter is shown to Claude when the rule triggers.\n\n**Good messages:**\n- Explain what was detected\n- Explain why it's problematic\n- Suggest alternatives or best practices\n- Use formatting for clarity (bold, lists, etc.)\n\n**Example:**\n```markdown\nâš ï¸ **Console.log detected!**\n\nYou're adding console.log to production code.\n\n**Why this matters:**\n- Debug logs shouldn't ship to production\n- Console.log can expose sensitive data\n- Impacts browser performance\n\n**Alternatives:**\n- Use a proper logging library\n- Remove before committing\n- Use conditional debug builds\n```\n\n## Event Type Guide\n\n### bash Events\n\nMatch Bash command patterns:\n\n```markdown\n---\nevent: bash\npattern: sudo\\s+|rm\\s+-rf|chmod\\s+777\n---\n\nDangerous command detected!\n```\n\n**Common patterns:**\n- Dangerous commands: `rm\\s+-rf`, `dd\\s+if=`, `mkfs`\n- Privilege escalation: `sudo\\s+`, `su\\s+`\n- Permission issues: `chmod\\s+777`, `chown\\s+root`\n\n### file Events\n\nMatch Edit/Write/MultiEdit operations:\n\n```markdown\n---\nevent: file\npattern: console\\.log\\(|eval\\(|innerHTML\\s*=\n---\n\nPotentially problematic code pattern detected!\n```\n\n**Match on different fields:**\n```markdown\n---\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: console\\.log\\(\n---\n\nConsole.log in TypeScript file!\n```\n\n**Common patterns:**\n- Debug code: `console\\.log\\(`, `debugger`, `print\\(`\n- Security risks: `eval\\(`, `innerHTML\\s*=`, `dangerouslySetInnerHTML`\n- Sensitive files: `\\.env$`, `credentials`, `\\.pem$`\n- Generated files: `node_modules/`, `dist/`, `build/`\n\n### stop Events\n\nMatch when agent wants to stop (completion checks):\n\n```markdown\n---\nevent: stop\npattern: .*\n---\n\nBefore stopping, verify:\n- [ ] Tests were run\n- [ ] Build succeeded\n- [ ] Documentation updated\n```\n\n**Use for:**\n- Reminders about required steps\n- Completion checklists\n- Process enforcement\n\n### prompt Events\n\nMatch user prompt content (advanced):\n\n```markdown\n---\nevent: prompt\nconditions:\n  - field: user_prompt\n    operator: contains\n    pattern: deploy to production\n---\n\nProduction deployment checklist:\n- [ ] Tests passing?\n- [ ] Reviewed by team?\n- [ ] Monitoring ready?\n```\n\n## Pattern Writing Tips\n\n### Regex Basics\n\n**Literal characters:** Most characters match themselves\n- `rm` matches \"rm\"\n- `console.log` matches \"console.log\"\n\n**Special characters need escaping:**\n- `.` (any char) â†’ `\\.` (literal dot)\n- `(` `)` â†’ `\\(` `\\)` (literal parens)\n- `[` `]` â†’ `\\[` `\\]` (literal brackets)\n\n**Common metacharacters:**\n- `\\s` - whitespace (space, tab, newline)\n- `\\d` - digit (0-9)\n- `\\w` - word character (a-z, A-Z, 0-9, _)\n- `.` - any character\n- `+` - one or more\n- `*` - zero or more\n- `?` - zero or one\n- `|` - OR\n\n**Examples:**\n```\nrm\\s+-rf         Matches: rm -rf, rm  -rf\nconsole\\.log\\(   Matches: console.log(\n(eval|exec)\\(    Matches: eval( or exec(\nchmod\\s+777      Matches: chmod 777, chmod  777\nAPI_KEY\\s*=      Matches: API_KEY=, API_KEY =\n```\n\n### Testing Patterns\n\nTest regex patterns before using:\n\n```bash\npython3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\"\n```\n\nOr use online regex testers (regex101.com with Python flavor).\n\n### Common Pitfalls\n\n**Too broad:**\n```yaml\npattern: log    # Matches \"log\", \"login\", \"dialog\", \"catalog\"\n```\nBetter: `console\\.log\\(|logger\\.`\n\n**Too specific:**\n```yaml\npattern: rm -rf /tmp  # Only matches exact path\n```\nBetter: `rm\\s+-rf`\n\n**Escaping issues:**\n- YAML quoted strings: `\"pattern\"` requires double backslashes `\\\\s`\n- YAML unquoted: `pattern: \\s` works as-is\n- **Recommendation**: Use unquoted patterns in YAML\n\n## File Organization\n\n**Location:** All rules in `.claude/` directory\n**Naming:** `.claude/hookify.{descriptive-name}.local.md`\n**Gitignore:** Add `.claude/*.local.md` to `.gitignore`\n\n**Good names:**\n- `hookify.dangerous-rm.local.md`\n- `hookify.console-log.local.md`\n- `hookify.require-tests.local.md`\n- `hookify.sensitive-files.local.md`\n\n**Bad names:**\n- `hookify.rule1.local.md` (not descriptive)\n- `hookify.md` (missing .local)\n- `danger.local.md` (missing hookify prefix)\n\n## Workflow\n\n### Creating a Rule\n\n1. Identify unwanted behavior\n2. Determine which tool is involved (Bash, Edit, etc.)\n3. Choose event type (bash, file, stop, etc.)\n4. Write regex pattern\n5. Create `.claude/hookify.{name}.local.md` file in project root\n6. Test immediately - rules are read dynamically on next tool use\n\n### Refining a Rule\n\n1. Edit the `.local.md` file\n2. Adjust pattern or message\n3. Test immediately - changes take effect on next tool use\n\n### Disabling a Rule\n\n**Temporary:** Set `enabled: false` in frontmatter\n**Permanent:** Delete the `.local.md` file\n\n## Examples\n\nSee `${CLAUDE_PLUGIN_ROOT}/examples/` for complete examples:\n- `dangerous-rm.local.md` - Block dangerous rm commands\n- `console-log-warning.local.md` - Warn about console.log\n- `sensitive-files-warning.local.md` - Warn about editing .env files\n\n## Quick Reference\n\n**Minimum viable rule:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: bash\npattern: dangerous_command\n---\n\nWarning message here\n```\n\n**Rule with conditions:**\n```markdown\n---\nname: my-rule\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.ts$\n  - field: new_text\n    operator: contains\n    pattern: any\n---\n\nWarning message\n```\n\n**Event types:**\n- `bash` - Bash commands\n- `file` - File edits\n- `stop` - Completion checks\n- `prompt` - User input\n- `all` - All events\n\n**Field options:**\n- Bash: `command`\n- File: `file_path`, `new_text`, `old_text`, `content`\n- Prompt: `user_prompt`\n\n**Operators:**\n- `regex_match`, `contains`, `equals`, `not_contains`, `starts_with`, `ends_with`\n"}
{"source":"github","repo":"claude-code","path":"plugins/hookify/agents/conversation-analyzer.md","content":"---\nname: conversation-analyzer\ndescription: Use this agent when analyzing conversation transcripts to find behaviors worth preventing with hooks. Examples: <example>Context: User is running /hookify command without arguments\\nuser: \"/hookify\"\\nassistant: \"I'll analyze the conversation to find behaviors you want to prevent\"\\n<commentary>The /hookify command without arguments triggers conversation analysis to find unwanted behaviors.</commentary></example><example>Context: User wants to create hooks from recent frustrations\\nuser: \"Can you look back at this conversation and help me create hooks for the mistakes you made?\"\\nassistant: \"I'll use the conversation-analyzer agent to identify the issues and suggest hooks.\"\\n<commentary>User explicitly asks to analyze conversation for mistakes that should be prevented.</commentary></example>\nmodel: inherit\ncolor: yellow\ntools: [\"Read\", \"Grep\"]\n---\n\nYou are a conversation analysis specialist that identifies problematic behaviors in Claude Code sessions that could be prevented with hooks.\n\n**Your Core Responsibilities:**\n1. Read and analyze user messages to find frustration signals\n2. Identify specific tool usage patterns that caused issues\n3. Extract actionable patterns that can be matched with regex\n4. Categorize issues by severity and type\n5. Provide structured findings for hook rule generation\n\n**Analysis Process:**\n\n### 1. Search for User Messages Indicating Issues\n\nRead through user messages in reverse chronological order (most recent first). Look for:\n\n**Explicit correction requests:**\n- \"Don't use X\"\n- \"Stop doing Y\"\n- \"Please don't Z\"\n- \"Avoid...\"\n- \"Never...\"\n\n**Frustrated reactions:**\n- \"Why did you do X?\"\n- \"I didn't ask for that\"\n- \"That's not what I meant\"\n- \"That was wrong\"\n\n**Corrections and reversions:**\n- User reverting changes Claude made\n- User fixing issues Claude created\n- User providing step-by-step corrections\n\n**Repeated issues:**\n- Same type of mistake multiple times\n- User having to remind multiple times\n- Pattern of similar problems\n\n### 2. Identify Tool Usage Patterns\n\nFor each issue, determine:\n- **Which tool**: Bash, Edit, Write, MultiEdit\n- **What action**: Specific command or code pattern\n- **When it happened**: During what task/phase\n- **Why problematic**: User's stated reason or implicit concern\n\n**Extract concrete examples:**\n- For Bash: Actual command that was problematic\n- For Edit/Write: Code pattern that was added\n- For Stop: What was missing before stopping\n\n### 3. Create Regex Patterns\n\nConvert behaviors into matchable patterns:\n\n**Bash command patterns:**\n- `rm\\s+-rf` for dangerous deletes\n- `sudo\\s+` for privilege escalation\n- `chmod\\s+777` for permission issues\n\n**Code patterns (Edit/Write):**\n- `console\\.log\\(` for debug logging\n- `eval\\(|new Function\\(` for dangerous eval\n- `innerHTML\\s*=` for XSS risks\n\n**File path patterns:**\n- `\\.env$` for environment files\n- `/node_modules/` for dependency files\n- `dist/|build/` for generated files\n\n### 4. Categorize Severity\n\n**High severity (should block in future):**\n- Dangerous commands (rm -rf, chmod 777)\n- Security issues (hardcoded secrets, eval)\n- Data loss risks\n\n**Medium severity (warn):**\n- Style violations (console.log in production)\n- Wrong file types (editing generated files)\n- Missing best practices\n\n**Low severity (optional):**\n- Preferences (coding style)\n- Non-critical patterns\n\n### 5. Output Format\n\nReturn your findings as structured text in this format:\n\n```\n## Hookify Analysis Results\n\n### Issue 1: Dangerous rm Commands\n**Severity**: High\n**Tool**: Bash\n**Pattern**: `rm\\s+-rf`\n**Occurrences**: 3 times\n**Context**: Used rm -rf on /tmp directories without verification\n**User Reaction**: \"Please be more careful with rm commands\"\n\n**Suggested Rule:**\n- Name: warn-dangerous-rm\n- Event: bash\n- Pattern: rm\\s+-rf\n- Message: \"Dangerous rm command detected. Verify path before proceeding.\"\n\n---\n\n### Issue 2: Console.log in TypeScript\n**Severity**: Medium\n**Tool**: Edit/Write\n**Pattern**: `console\\.log\\(`\n**Occurrences**: 2 times\n**Context**: Added console.log statements to production TypeScript files\n**User Reaction**: \"Don't use console.log in production code\"\n\n**Suggested Rule:**\n- Name: warn-console-log\n- Event: file\n- Pattern: console\\.log\\(\n- Message: \"Console.log detected. Use proper logging library instead.\"\n\n---\n\n[Continue for each issue found...]\n\n## Summary\n\nFound {N} behaviors worth preventing:\n- {N} high severity\n- {N} medium severity\n- {N} low severity\n\nRecommend creating rules for high and medium severity issues.\n```\n\n**Quality Standards:**\n- Be specific about patterns (don't be overly broad)\n- Include actual examples from conversation\n- Explain why each issue matters\n- Provide ready-to-use regex patterns\n- Don't false-positive on discussions about what NOT to do\n\n**Edge Cases:**\n\n**User discussing hypotheticals:**\n- \"What would happen if I used rm -rf?\"\n- Don't treat as problematic behavior\n\n**Teaching moments:**\n- \"Here's what you shouldn't do: ...\"\n- Context indicates explanation, not actual problem\n\n**One-time accidents:**\n- Single occurrence, already fixed\n- Mention but mark as low priority\n\n**Subjective preferences:**\n- \"I prefer X over Y\"\n- Mark as low severity, let user decide\n\n**Return Results:**\nProvide your analysis in the structured format above. The /hookify command will use this to:\n1. Present findings to user\n2. Ask which rules to create\n3. Generate .local.md configuration files\n4. Save rules to .claude directory\n"}
{"source":"github","repo":"claude-code","path":"plugins/hookify/README.md","content":"# Hookify Plugin\n\nEasily create custom hooks to prevent unwanted behaviors by analyzing conversation patterns or from explicit instructions.\n\n## Overview\n\nThe hookify plugin makes it simple to create hooks without editing complex `hooks.json` files. Instead, you create lightweight markdown configuration files that define patterns to watch for and messages to show when those patterns match.\n\n**Key features:**\n- ðŸŽ¯ Analyze conversations to find unwanted behaviors automatically\n- ðŸ“ Simple markdown configuration files with YAML frontmatter\n- ðŸ” Regex pattern matching for powerful rules\n- ðŸš€ No coding required - just describe the behavior\n- ðŸ”„ Easy enable/disable without restarting\n\n## Quick Start\n\n### 1. Create Your First Rule\n\n```bash\n/hookify Warn me when I use rm -rf commands\n```\n\nThis analyzes your request and creates `.claude/hookify.warn-rm.local.md`.\n\n### 2. Test It Immediately\n\n**No restart needed!** Rules take effect on the very next tool use.\n\nAsk Claude to run a command that should trigger the rule:\n```\nRun rm -rf /tmp/test\n```\n\nYou should see the warning message immediately!\n\n## Usage\n\n### Main Command: /hookify\n\n**With arguments:**\n```\n/hookify Don't use console.log in TypeScript files\n```\nCreates a rule from your explicit instructions.\n\n**Without arguments:**\n```\n/hookify\n```\nAnalyzes recent conversation to find behaviors you've corrected or been frustrated by.\n\n### Helper Commands\n\n**List all rules:**\n```\n/hookify:list\n```\n\n**Configure rules interactively:**\n```\n/hookify:configure\n```\nEnable/disable existing rules through an interactive interface.\n\n**Get help:**\n```\n/hookify:help\n```\n\n## Rule Configuration Format\n\n### Simple Rule (Single Pattern)\n\n`.claude/hookify.dangerous-rm.local.md`:\n```markdown\n---\nname: block-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\naction: block\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please:\n- Verify the path is correct\n- Consider using a safer approach\n- Make sure you have backups\n```\n\n**Action field:**\n- `warn`: Shows warning but allows operation (default)\n- `block`: Prevents operation from executing (PreToolUse) or stops session (Stop events)\n\n### Advanced Rule (Multiple Conditions)\n\n`.claude/hookify.sensitive-files.local.md`:\n```markdown\n---\nname: warn-sensitive-files\nenabled: true\nevent: file\naction: warn\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$|credentials|secrets\n  - field: new_text\n    operator: contains\n    pattern: KEY\n---\n\nðŸ” **Sensitive file edit detected!**\n\nEnsure credentials are not hardcoded and file is in .gitignore.\n```\n\n**All conditions must match** for the rule to trigger.\n\n## Event Types\n\n- **`bash`**: Triggers on Bash tool commands\n- **`file`**: Triggers on Edit, Write, MultiEdit tools\n- **`stop`**: Triggers when Claude wants to stop (for completion checks)\n- **`prompt`**: Triggers on user prompt submission\n- **`all`**: Triggers on all events\n\n## Pattern Syntax\n\nUse Python regex syntax:\n\n| Pattern | Matches | Example |\n|---------|---------|---------|\n| `rm\\s+-rf` | rm -rf | rm -rf /tmp |\n| `console\\.log\\(` | console.log( | console.log(\"test\") |\n| `(eval\\|exec)\\(` | eval( or exec( | eval(\"code\") |\n| `\\.env$` | files ending in .env | .env, .env.local |\n| `chmod\\s+777` | chmod 777 | chmod 777 file.txt |\n\n**Tips:**\n- Use `\\s` for whitespace\n- Escape special chars: `\\.` for literal dot\n- Use `|` for OR: `(foo|bar)`\n- Use `.*` to match anything\n- Set `action: block` for dangerous operations\n- Set `action: warn` (or omit) for informational warnings\n\n## Examples\n\n### Example 1: Block Dangerous Commands\n\n```markdown\n---\nname: block-destructive-ops\nenabled: true\nevent: bash\npattern: rm\\s+-rf|dd\\s+if=|mkfs|format\naction: block\n---\n\nðŸ›‘ **Destructive operation detected!**\n\nThis command can cause data loss. Operation blocked for safety.\nPlease verify the exact path and use a safer approach.\n```\n\n**This rule blocks the operation** - Claude will not be allowed to execute these commands.\n\n### Example 2: Warn About Debug Code\n\n```markdown\n---\nname: warn-debug-code\nenabled: true\nevent: file\npattern: console\\.log\\(|debugger;|print\\(\naction: warn\n---\n\nðŸ› **Debug code detected**\n\nRemember to remove debugging statements before committing.\n```\n\n**This rule warns but allows** - Claude sees the message but can still proceed.\n\n### Example 3: Require Tests Before Stopping\n\n```markdown\n---\nname: require-tests-run\nenabled: false\nevent: stop\naction: block\nconditions:\n  - field: transcript\n    operator: not_contains\n    pattern: npm test|pytest|cargo test\n---\n\n**Tests not detected in transcript!**\n\nBefore stopping, please run tests to verify your changes work correctly.\n```\n\n**This blocks Claude from stopping** if no test commands appear in the session transcript. Enable only when you want strict enforcement.\n\n## Advanced Usage\n\n### Multiple Conditions\n\nCheck multiple fields simultaneously:\n\n```markdown\n---\nname: api-key-in-typescript\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.tsx?$\n  - field: new_text\n    operator: regex_match\n    pattern: (API_KEY|SECRET|TOKEN)\\s*=\\s*[\"']\n---\n\nðŸ” **Hardcoded credential in TypeScript!**\n\nUse environment variables instead of hardcoded values.\n```\n\n### Operators Reference\n\n- `regex_match`: Pattern must match (most common)\n- `contains`: String must contain pattern\n- `equals`: Exact string match\n- `not_contains`: String must NOT contain pattern\n- `starts_with`: String starts with pattern\n- `ends_with`: String ends with pattern\n\n### Field Reference\n\n**For bash events:**\n- `command`: The bash command string\n\n**For file events:**\n- `file_path`: Path to file being edited\n- `new_text`: New content being added (Edit, Write)\n- `old_text`: Old content being replaced (Edit only)\n- `content`: File content (Write only)\n\n**For prompt events:**\n- `user_prompt`: The user's submitted prompt text\n\n**For stop events:**\n- Use general matching on session state\n\n## Management\n\n### Enable/Disable Rules\n\n**Temporarily disable:**\nEdit the `.local.md` file and set `enabled: false`\n\n**Re-enable:**\nSet `enabled: true`\n\n**Or use interactive tool:**\n```\n/hookify:configure\n```\n\n### Delete Rules\n\nSimply delete the `.local.md` file:\n```bash\nrm .claude/hookify.my-rule.local.md\n```\n\n### View All Rules\n\n```\n/hookify:list\n```\n\n## Installation\n\nThis plugin is part of the Claude Code Marketplace. It should be auto-discovered when the marketplace is installed.\n\n**Manual testing:**\n```bash\ncc --plugin-dir /path/to/hookify\n```\n\n## Requirements\n\n- Python 3.7+\n- No external dependencies (uses stdlib only)\n\n## Troubleshooting\n\n**Rule not triggering:**\n1. Check rule file exists in `.claude/` directory (in project root, not plugin directory)\n2. Verify `enabled: true` in frontmatter\n3. Test regex pattern separately\n4. Rules should work immediately - no restart needed\n5. Try `/hookify:list` to see if rule is loaded\n\n**Import errors:**\n- Ensure Python 3 is available: `python3 --version`\n- Check hookify plugin is installed\n\n**Pattern not matching:**\n- Test regex: `python3 -c \"import re; print(re.search(r'pattern', 'text'))\"`\n- Use unquoted patterns in YAML to avoid escaping issues\n- Start simple, then add complexity\n\n**Hook seems slow:**\n- Keep patterns simple (avoid complex regex)\n- Use specific event types (bash, file) instead of \"all\"\n- Limit number of active rules\n\n## Contributing\n\nFound a useful rule pattern? Consider sharing example files via PR!\n\n## Future Enhancements\n\n- Severity levels (error/warning/info distinctions)\n- Rule templates library\n- Interactive pattern builder\n- Hook testing utilities\n- JSON format support (in addition to markdown)\n\n## License\n\nMIT License\n"}
{"source":"github","repo":"claude-code","path":"plugins/hookify/commands/help.md","content":"---\ndescription: Get help with the hookify plugin\nallowed-tools: [\"Read\"]\n---\n\n# Hookify Plugin Help\n\nExplain how the hookify plugin works and how to use it.\n\n## Overview\n\nThe hookify plugin makes it easy to create custom hooks that prevent unwanted behaviors. Instead of editing `hooks.json` files, users create simple markdown configuration files that define patterns to watch for.\n\n## How It Works\n\n### 1. Hook System\n\nHookify installs generic hooks that run on these events:\n- **PreToolUse**: Before any tool executes (Bash, Edit, Write, etc.)\n- **PostToolUse**: After a tool executes\n- **Stop**: When Claude wants to stop working\n- **UserPromptSubmit**: When user submits a prompt\n\nThese hooks read configuration files from `.claude/hookify.*.local.md` and check if any rules match the current operation.\n\n### 2. Configuration Files\n\nUsers create rules in `.claude/hookify.{rule-name}.local.md` files:\n\n```markdown\n---\nname: warn-dangerous-rm\nenabled: true\nevent: bash\npattern: rm\\s+-rf\n---\n\nâš ï¸ **Dangerous rm command detected!**\n\nThis command could delete important files. Please verify the path.\n```\n\n**Key fields:**\n- `name`: Unique identifier for the rule\n- `enabled`: true/false to activate/deactivate\n- `event`: bash, file, stop, prompt, or all\n- `pattern`: Regex pattern to match\n\nThe message body is what Claude sees when the rule triggers.\n\n### 3. Creating Rules\n\n**Option A: Use /hookify command**\n```\n/hookify Don't use console.log in production files\n```\n\nThis analyzes your request and creates the appropriate rule file.\n\n**Option B: Create manually**\nCreate `.claude/hookify.my-rule.local.md` with the format above.\n\n**Option C: Analyze conversation**\n```\n/hookify\n```\n\nWithout arguments, hookify analyzes recent conversation to find behaviors you want to prevent.\n\n## Available Commands\n\n- **`/hookify`** - Create hooks from conversation analysis or explicit instructions\n- **`/hookify:help`** - Show this help (what you're reading now)\n- **`/hookify:list`** - List all configured hooks\n- **`/hookify:configure`** - Enable/disable existing hooks interactively\n\n## Example Use Cases\n\n**Prevent dangerous commands:**\n```markdown\n---\nname: block-chmod-777\nenabled: true\nevent: bash\npattern: chmod\\s+777\n---\n\nDon't use chmod 777 - it's a security risk. Use specific permissions instead.\n```\n\n**Warn about debugging code:**\n```markdown\n---\nname: warn-console-log\nenabled: true\nevent: file\npattern: console\\.log\\(\n---\n\nConsole.log detected. Remember to remove debug logging before committing.\n```\n\n**Require tests before stopping:**\n```markdown\n---\nname: require-tests\nenabled: true\nevent: stop\npattern: .*\n---\n\nDid you run tests before finishing? Make sure `npm test` or equivalent was executed.\n```\n\n## Pattern Syntax\n\nUse Python regex syntax:\n- `\\s` - whitespace\n- `\\.` - literal dot\n- `|` - OR\n- `+` - one or more\n- `*` - zero or more\n- `\\d` - digit\n- `[abc]` - character class\n\n**Examples:**\n- `rm\\s+-rf` - matches \"rm -rf\"\n- `console\\.log\\(` - matches \"console.log(\"\n- `(eval|exec)\\(` - matches \"eval(\" or \"exec(\"\n- `\\.env$` - matches files ending in .env\n\n## Important Notes\n\n**No Restart Needed**: Hookify rules (`.local.md` files) take effect immediately on the next tool use. The hookify hooks are already loaded and read your rules dynamically.\n\n**Block or Warn**: Rules can either `block` operations (prevent execution) or `warn` (show message but allow). Set `action: block` or `action: warn` in the rule's frontmatter.\n\n**Rule Files**: Keep rules in `.claude/hookify.*.local.md` - they should be git-ignored (add to .gitignore if needed).\n\n**Disable Rules**: Set `enabled: false` in frontmatter or delete the file.\n\n## Troubleshooting\n\n**Hook not triggering:**\n- Check rule file is in `.claude/` directory\n- Verify `enabled: true` in frontmatter\n- Confirm pattern is valid regex\n- Test pattern: `python3 -c \"import re; print(re.search('your_pattern', 'test_text'))\"`\n- Rules take effect immediately - no restart needed\n\n**Import errors:**\n- Check Python 3 is available: `python3 --version`\n- Verify hookify plugin is installed correctly\n\n**Pattern not matching:**\n- Test regex separately\n- Check for escaping issues (use unquoted patterns in YAML)\n- Try simpler pattern first, then refine\n\n## Getting Started\n\n1. Create your first rule:\n   ```\n   /hookify Warn me when I try to use rm -rf\n   ```\n\n2. Try to trigger it:\n   - Ask Claude to run `rm -rf /tmp/test`\n   - You should see the warning\n\n4. Refine the rule by editing `.claude/hookify.warn-rm.local.md`\n\n5. Create more rules as you encounter unwanted behaviors\n\nFor more examples, check the `${CLAUDE_PLUGIN_ROOT}/examples/` directory.\n"}
{"source":"github","repo":"claude-code","path":"plugins/hookify/commands/hookify.md","content":"---\ndescription: Create hooks to prevent unwanted behaviors from conversation analysis or explicit instructions\nargument-hint: Optional specific behavior to address\nallowed-tools: [\"Read\", \"Write\", \"AskUserQuestion\", \"Task\", \"Grep\", \"TodoWrite\", \"Skill\"]\n---\n\n# Hookify - Create Hooks from Unwanted Behaviors\n\n**FIRST: Load the hookify:writing-rules skill** using the Skill tool to understand rule file format and syntax.\n\nCreate hook rules to prevent problematic behaviors by analyzing the conversation or from explicit user instructions.\n\n## Your Task\n\nYou will help the user create hookify rules to prevent unwanted behaviors. Follow these steps:\n\n### Step 1: Gather Behavior Information\n\n**If $ARGUMENTS is provided:**\n- User has given specific instructions: `$ARGUMENTS`\n- Still analyze recent conversation (last 10-15 user messages) for additional context\n- Look for examples of the behavior happening\n\n**If $ARGUMENTS is empty:**\n- Launch the conversation-analyzer agent to find problematic behaviors\n- Agent will scan user prompts for frustration signals\n- Agent will return structured findings\n\n**To analyze conversation:**\nUse the Task tool to launch conversation-analyzer agent:\n```\n{\n  \"subagent_type\": \"general-purpose\",\n  \"description\": \"Analyze conversation for unwanted behaviors\",\n  \"prompt\": \"You are analyzing a Claude Code conversation to find behaviors the user wants to prevent.\n\nRead user messages in the current conversation and identify:\n1. Explicit requests to avoid something (\\\"don't do X\\\", \\\"stop doing Y\\\")\n2. Corrections or reversions (user fixing Claude's actions)\n3. Frustrated reactions (\\\"why did you do X?\\\", \\\"I didn't ask for that\\\")\n4. Repeated issues (same problem multiple times)\n\nFor each issue found, extract:\n- What tool was used (Bash, Edit, Write, etc.)\n- Specific pattern or command\n- Why it was problematic\n- User's stated reason\n\nReturn findings as a structured list with:\n- category: Type of issue\n- tool: Which tool was involved\n- pattern: Regex or literal pattern to match\n- context: What happened\n- severity: high/medium/low\n\nFocus on the most recent issues (last 20-30 messages). Don't go back further unless explicitly asked.\"\n}\n```\n\n### Step 2: Present Findings to User\n\nAfter gathering behaviors (from arguments or agent), present to user using AskUserQuestion:\n\n**Question 1: Which behaviors to hookify?**\n- Header: \"Create Rules\"\n- multiSelect: true\n- Options: List each detected behavior (max 4)\n  - Label: Short description (e.g., \"Block rm -rf\")\n  - Description: Why it's problematic\n\n**Question 2: For each selected behavior, ask about action:**\n- \"Should this block the operation or just warn?\"\n- Options:\n  - \"Just warn\" (action: warn - shows message but allows)\n  - \"Block operation\" (action: block - prevents execution)\n\n**Question 3: Ask for example patterns:**\n- \"What patterns should trigger this rule?\"\n- Show detected patterns\n- Allow user to refine or add more\n\n### Step 3: Generate Rule Files\n\nFor each confirmed behavior, create a `.claude/hookify.{rule-name}.local.md` file:\n\n**Rule naming convention:**\n- Use kebab-case\n- Be descriptive: `block-dangerous-rm`, `warn-console-log`, `require-tests-before-stop`\n- Start with action verb: block, warn, prevent, require\n\n**File format:**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: {bash|file|stop|prompt|all}\npattern: {regex pattern}\naction: {warn|block}\n---\n\n{Message to show Claude when rule triggers}\n```\n\n**Action values:**\n- `warn`: Show message but allow operation (default)\n- `block`: Prevent operation or stop session\n\n**For more complex rules (multiple conditions):**\n```markdown\n---\nname: {rule-name}\nenabled: true\nevent: file\nconditions:\n  - field: file_path\n    operator: regex_match\n    pattern: \\.env$\n  - field: new_text\n    operator: contains\n    pattern: API_KEY\n---\n\n{Warning message}\n```\n\n### Step 4: Create Files and Confirm\n\n**IMPORTANT**: Rule files must be created in the current working directory's `.claude/` folder, NOT the plugin directory.\n\nUse the current working directory (where Claude Code was started) as the base path.\n\n1. Check if `.claude/` directory exists in current working directory\n   - If not, create it first with: `mkdir -p .claude`\n\n2. Use Write tool to create each `.claude/hookify.{name}.local.md` file\n   - Use relative path from current working directory: `.claude/hookify.{name}.local.md`\n   - The path should resolve to the project's .claude directory, not the plugin's\n\n3. Show user what was created:\n   ```\n   Created 3 hookify rules:\n   - .claude/hookify.dangerous-rm.local.md\n   - .claude/hookify.console-log.local.md\n   - .claude/hookify.sensitive-files.local.md\n\n   These rules will trigger on:\n   - dangerous-rm: Bash commands matching \"rm -rf\"\n   - console-log: Edits adding console.log statements\n   - sensitive-files: Edits to .env or credentials files\n   ```\n\n4. Verify files were created in the correct location by listing them\n\n5. Inform user: **\"Rules are active immediately - no restart needed!\"**\n\n   The hookify hooks are already loaded and will read your new rules on the next tool use.\n\n## Event Types Reference\n\n- **bash**: Matches Bash tool commands\n- **file**: Matches Edit, Write, MultiEdit tools\n- **stop**: Matches when agent wants to stop (use for completion checks)\n- **prompt**: Matches when user submits prompts\n- **all**: Matches all events\n\n## Pattern Writing Tips\n\n**Bash patterns:**\n- Match dangerous commands: `rm\\s+-rf|chmod\\s+777|dd\\s+if=`\n- Match specific tools: `npm\\s+install\\s+|pip\\s+install`\n\n**File patterns:**\n- Match code patterns: `console\\.log\\(|eval\\(|innerHTML\\s*=`\n- Match file paths: `\\.env$|\\.git/|node_modules/`\n\n**Stop patterns:**\n- Check for missing steps: (check transcript or completion criteria)\n\n## Example Workflow\n\n**User says**: \"/hookify Don't use rm -rf without asking me first\"\n\n**Your response**:\n1. Analyze: User wants to prevent rm -rf commands\n2. Ask: \"Should I block this command or just warn you?\"\n3. User selects: \"Just warn\"\n4. Create `.claude/hookify.dangerous-rm.local.md`:\n   ```markdown\n   ---\n   name: warn-dangerous-rm\n   enabled: true\n   event: bash\n   pattern: rm\\s+-rf\n   ---\n\n   âš ï¸ **Dangerous rm command detected**\n\n   You requested to be warned before using rm -rf.\n   Please verify the path is correct.\n   ```\n5. Confirm: \"Created hookify rule. It's active immediately - try triggering it!\"\n\n## Important Notes\n\n- **No restart needed**: Rules take effect immediately on the next tool use\n- **File location**: Create files in project's `.claude/` directory (current working directory), NOT the plugin's .claude/\n- **Regex syntax**: Use Python regex syntax (raw strings, no need to escape in YAML)\n- **Action types**: Rules can `warn` (default) or `block` operations\n- **Testing**: Test rules immediately after creating them\n\n## Troubleshooting\n\n**If rule file creation fails:**\n1. Check current working directory with pwd\n2. Ensure `.claude/` directory exists (create with mkdir if needed)\n3. Use absolute path if needed: `{cwd}/.claude/hookify.{name}.local.md`\n4. Verify file was created with Glob or ls\n\n**If rule doesn't trigger after creation:**\n1. Verify file is in project `.claude/` not plugin `.claude/`\n2. Check file with Read tool to ensure pattern is correct\n3. Test pattern with: `python3 -c \"import re; print(re.search(r'pattern', 'test text'))\"`\n4. Verify `enabled: true` in frontmatter\n5. Remember: Rules work immediately, no restart needed\n\n**If blocking seems too strict:**\n1. Change `action: block` to `action: warn` in the rule file\n2. Or adjust the pattern to be more specific\n3. Changes take effect on next tool use\n\nUse TodoWrite to track your progress through the steps.\n"}
{"source":"github","repo":"claude-code","path":"plugins/hookify/commands/list.md","content":"---\ndescription: List all configured hookify rules\nallowed-tools: [\"Glob\", \"Read\", \"Skill\"]\n---\n\n# List Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nShow all configured hookify rules in the project.\n\n## Steps\n\n1. Use Glob tool to find all hookify rule files:\n   ```\n   pattern: \".claude/hookify.*.local.md\"\n   ```\n\n2. For each file found:\n   - Use Read tool to read the file\n   - Extract frontmatter fields: name, enabled, event, pattern\n   - Extract message preview (first 100 chars)\n\n3. Present results in a table:\n\n```\n## Configured Hookify Rules\n\n| Name | Enabled | Event | Pattern | File |\n|------|---------|-------|---------|------|\n| warn-dangerous-rm | âœ… Yes | bash | rm\\s+-rf | hookify.dangerous-rm.local.md |\n| warn-console-log | âœ… Yes | file | console\\.log\\( | hookify.console-log.local.md |\n| check-tests | âŒ No | stop | .* | hookify.require-tests.local.md |\n\n**Total**: 3 rules (2 enabled, 1 disabled)\n```\n\n4. For each rule, show a brief preview:\n```\n### warn-dangerous-rm\n**Event**: bash\n**Pattern**: `rm\\s+-rf`\n**Message**: \"âš ï¸ **Dangerous rm command detected!** This command could delete...\"\n\n**Status**: âœ… Active\n**File**: .claude/hookify.dangerous-rm.local.md\n```\n\n5. Add helpful footer:\n```\n---\n\nTo modify a rule: Edit the .local.md file directly\nTo disable a rule: Set `enabled: false` in frontmatter\nTo enable a rule: Set `enabled: true` in frontmatter\nTo delete a rule: Remove the .local.md file\nTo create a rule: Use `/hookify` command\n\n**Remember**: Changes take effect immediately - no restart needed\n```\n\n## If No Rules Found\n\nIf no hookify rules exist:\n\n```\n## No Hookify Rules Configured\n\nYou haven't created any hookify rules yet.\n\nTo get started:\n1. Use `/hookify` to analyze conversation and create rules\n2. Or manually create `.claude/hookify.my-rule.local.md` files\n3. See `/hookify:help` for documentation\n\nExample:\n```\n/hookify Warn me when I use console.log\n```\n\nCheck `${CLAUDE_PLUGIN_ROOT}/examples/` for example rule files.\n```\n"}
{"source":"github","repo":"claude-code","path":"plugins/hookify/commands/configure.md","content":"---\ndescription: Enable or disable hookify rules interactively\nallowed-tools: [\"Glob\", \"Read\", \"Edit\", \"AskUserQuestion\", \"Skill\"]\n---\n\n# Configure Hookify Rules\n\n**Load hookify:writing-rules skill first** to understand rule format.\n\nEnable or disable existing hookify rules using an interactive interface.\n\n## Steps\n\n### 1. Find Existing Rules\n\nUse Glob tool to find all hookify rule files:\n```\npattern: \".claude/hookify.*.local.md\"\n```\n\nIf no rules found, inform user:\n```\nNo hookify rules configured yet. Use `/hookify` to create your first rule.\n```\n\n### 2. Read Current State\n\nFor each rule file:\n- Read the file\n- Extract `name` and `enabled` fields from frontmatter\n- Build list of rules with current state\n\n### 3. Ask User Which Rules to Toggle\n\nUse AskUserQuestion to let user select rules:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Which rules would you like to enable or disable?\",\n      \"header\": \"Configure\",\n      \"multiSelect\": true,\n      \"options\": [\n        {\n          \"label\": \"warn-dangerous-rm (currently enabled)\",\n          \"description\": \"Warns about rm -rf commands\"\n        },\n        {\n          \"label\": \"warn-console-log (currently disabled)\",\n          \"description\": \"Warns about console.log in code\"\n        },\n        {\n          \"label\": \"require-tests (currently enabled)\",\n          \"description\": \"Requires tests before stopping\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Option format:**\n- Label: `{rule-name} (currently {enabled|disabled})`\n- Description: Brief description from rule's message or pattern\n\n### 4. Parse User Selection\n\nFor each selected rule:\n- Determine current state from label (enabled/disabled)\n- Toggle state: enabled â†’ disabled, disabled â†’ enabled\n\n### 5. Update Rule Files\n\nFor each rule to toggle:\n- Use Read tool to read current content\n- Use Edit tool to change `enabled: true` to `enabled: false` (or vice versa)\n- Handle both with and without quotes\n\n**Edit pattern for enabling:**\n```\nold_string: \"enabled: false\"\nnew_string: \"enabled: true\"\n```\n\n**Edit pattern for disabling:**\n```\nold_string: \"enabled: true\"\nnew_string: \"enabled: false\"\n```\n\n### 6. Confirm Changes\n\nShow user what was changed:\n\n```\n## Hookify Rules Updated\n\n**Enabled:**\n- warn-console-log\n\n**Disabled:**\n- warn-dangerous-rm\n\n**Unchanged:**\n- require-tests\n\nChanges apply immediately - no restart needed\n```\n\n## Important Notes\n\n- Changes take effect immediately on next tool use\n- You can also manually edit .claude/hookify.*.local.md files\n- To permanently remove a rule, delete its .local.md file\n- Use `/hookify:list` to see all configured rules\n\n## Edge Cases\n\n**No rules to configure:**\n- Show message about using `/hookify` to create rules first\n\n**User selects no rules:**\n- Inform that no changes were made\n\n**File read/write errors:**\n- Inform user of specific error\n- Suggest manual editing as fallback\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-structure/examples/standard-plugin.md","content":"# Standard Plugin Example\n\nA well-structured plugin with commands, agents, and skills.\n\n## Directory Structure\n\n```\ncode-quality/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ lint.md\nâ”‚   â”œâ”€â”€ test.md\nâ”‚   â””â”€â”€ review.md\nâ”œâ”€â”€ agents/\nâ”‚   â”œâ”€â”€ code-reviewer.md\nâ”‚   â””â”€â”€ test-generator.md\nâ”œâ”€â”€ skills/\nâ”‚   â”œâ”€â”€ code-standards/\nâ”‚   â”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”‚   â””â”€â”€ references/\nâ”‚   â”‚       â””â”€â”€ style-guide.md\nâ”‚   â””â”€â”€ testing-patterns/\nâ”‚       â”œâ”€â”€ SKILL.md\nâ”‚       â””â”€â”€ examples/\nâ”‚           â”œâ”€â”€ unit-test.js\nâ”‚           â””â”€â”€ integration-test.js\nâ”œâ”€â”€ hooks/\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”‚       â””â”€â”€ validate-commit.sh\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ run-linter.sh\n    â””â”€â”€ generate-report.py\n```\n\n## File Contents\n\n### .claude-plugin/plugin.json\n\n```json\n{\n  \"name\": \"code-quality\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Comprehensive code quality tools including linting, testing, and review automation\",\n  \"author\": {\n    \"name\": \"Quality Team\",\n    \"email\": \"quality@example.com\"\n  },\n  \"homepage\": \"https://docs.example.com/plugins/code-quality\",\n  \"repository\": \"https://github.com/example/code-quality-plugin\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"code-quality\", \"linting\", \"testing\", \"code-review\", \"automation\"]\n}\n```\n\n### commands/lint.md\n\n```markdown\n---\nname: lint\ndescription: Run linting checks on the codebase\n---\n\n# Lint Command\n\nRun comprehensive linting checks on the project codebase.\n\n## Process\n\n1. Detect project type and installed linters\n2. Run appropriate linters (ESLint, Pylint, RuboCop, etc.)\n3. Collect and format results\n4. Report issues with file locations and severity\n\n## Implementation\n\nExecute the linting script:\n\n\\`\\`\\`bash\nbash ${CLAUDE_PLUGIN_ROOT}/scripts/run-linter.sh\n\\`\\`\\`\n\nParse the output and present issues organized by:\n- Critical issues (must fix)\n- Warnings (should fix)\n- Style suggestions (optional)\n\nFor each issue, show:\n- File path and line number\n- Issue description\n- Suggested fix (if available)\n```\n\n### commands/test.md\n\n```markdown\n---\nname: test\ndescription: Run test suite with coverage reporting\n---\n\n# Test Command\n\nExecute the project test suite and generate coverage reports.\n\n## Process\n\n1. Identify test framework (Jest, pytest, RSpec, etc.)\n2. Run all tests\n3. Generate coverage report\n4. Identify untested code\n\n## Output\n\nPresent results in structured format:\n- Test summary (passed/failed/skipped)\n- Coverage percentage by file\n- Critical untested areas\n- Failed test details\n\n## Integration\n\nAfter test completion, offer to:\n- Fix failing tests\n- Generate tests for untested code (using test-generator agent)\n- Update documentation based on test changes\n```\n\n### agents/code-reviewer.md\n\n```markdown\n---\ndescription: Expert code reviewer specializing in identifying bugs, security issues, and improvement opportunities\ncapabilities:\n  - Analyze code for potential bugs and logic errors\n  - Identify security vulnerabilities\n  - Suggest performance improvements\n  - Ensure code follows project standards\n  - Review test coverage adequacy\n---\n\n# Code Reviewer Agent\n\nSpecialized agent for comprehensive code review.\n\n## Expertise\n\n- **Bug detection**: Logic errors, edge cases, error handling\n- **Security analysis**: Injection vulnerabilities, authentication issues, data exposure\n- **Performance**: Algorithm efficiency, resource usage, optimization opportunities\n- **Standards compliance**: Style guide adherence, naming conventions, documentation\n- **Test coverage**: Adequacy of test cases, missing scenarios\n\n## Review Process\n\n1. **Initial scan**: Quick pass for obvious issues\n2. **Deep analysis**: Line-by-line review of changed code\n3. **Context evaluation**: Check impact on related code\n4. **Best practices**: Compare against project and language standards\n5. **Recommendations**: Prioritized list of improvements\n\n## Integration with Skills\n\nAutomatically loads `code-standards` skill for project-specific guidelines.\n\n## Output Format\n\nFor each file reviewed:\n- Overall assessment\n- Critical issues (must fix before merge)\n- Important issues (should fix)\n- Suggestions (nice to have)\n- Positive feedback (what was done well)\n```\n\n### agents/test-generator.md\n\n```markdown\n---\ndescription: Generates comprehensive test suites from code analysis\ncapabilities:\n  - Analyze code structure and logic flow\n  - Generate unit tests for functions and methods\n  - Create integration tests for modules\n  - Design edge case and error condition tests\n  - Suggest test fixtures and mocks\n---\n\n# Test Generator Agent\n\nSpecialized agent for generating comprehensive test suites.\n\n## Expertise\n\n- **Unit testing**: Individual function/method tests\n- **Integration testing**: Module interaction tests\n- **Edge cases**: Boundary conditions, error paths\n- **Test organization**: Proper test structure and naming\n- **Mocking**: Appropriate use of mocks and stubs\n\n## Generation Process\n\n1. **Code analysis**: Understand function purpose and logic\n2. **Path identification**: Map all execution paths\n3. **Input design**: Create test inputs covering all paths\n4. **Assertion design**: Define expected outputs\n5. **Test generation**: Write tests in project's framework\n\n## Integration with Skills\n\nAutomatically loads `testing-patterns` skill for project-specific test conventions.\n\n## Test Quality\n\nGenerated tests include:\n- Happy path scenarios\n- Edge cases and boundary conditions\n- Error handling verification\n- Mock data for external dependencies\n- Clear test descriptions\n```\n\n### skills/code-standards/SKILL.md\n\n```markdown\n---\nname: Code Standards\ndescription: This skill should be used when reviewing code, enforcing style guidelines, checking naming conventions, or ensuring code quality standards. Provides project-specific coding standards and best practices.\nversion: 1.0.0\n---\n\n# Code Standards\n\nComprehensive coding standards and best practices for maintaining code quality.\n\n## Overview\n\nEnforce consistent code quality through standardized conventions for:\n- Code style and formatting\n- Naming conventions\n- Documentation requirements\n- Error handling patterns\n- Security practices\n\n## Style Guidelines\n\n### Formatting\n\n- **Indentation**: 2 spaces (JavaScript/TypeScript), 4 spaces (Python)\n- **Line length**: Maximum 100 characters\n- **Braces**: Same line for opening brace (K&R style)\n- **Whitespace**: Space after commas, around operators\n\n### Naming Conventions\n\n- **Variables**: camelCase for JavaScript, snake_case for Python\n- **Functions**: camelCase, descriptive verb-noun pairs\n- **Classes**: PascalCase\n- **Constants**: UPPER_SNAKE_CASE\n- **Files**: kebab-case for modules\n\n## Documentation Requirements\n\n### Function Documentation\n\nEvery function must include:\n- Purpose description\n- Parameter descriptions with types\n- Return value description with type\n- Example usage (for public functions)\n\n### Module Documentation\n\nEvery module must include:\n- Module purpose\n- Public API overview\n- Usage examples\n- Dependencies\n\n## Error Handling\n\n### Required Practices\n\n- Never swallow errors silently\n- Always log errors with context\n- Use specific error types\n- Provide actionable error messages\n- Clean up resources in finally blocks\n\n### Example Pattern\n\n\\`\\`\\`javascript\nasync function processData(data) {\n  try {\n    const result = await transform(data)\n    return result\n  } catch (error) {\n    logger.error('Data processing failed', {\n      data: sanitize(data),\n      error: error.message,\n      stack: error.stack\n    })\n    throw new DataProcessingError('Failed to process data', { cause: error })\n  }\n}\n\\`\\`\\`\n\n## Security Practices\n\n- Validate all external input\n- Sanitize data before output\n- Use parameterized queries\n- Never log sensitive information\n- Keep dependencies updated\n\n## Detailed Guidelines\n\nFor comprehensive style guides by language, see:\n- `references/style-guide.md`\n```\n\n### skills/code-standards/references/style-guide.md\n\n```markdown\n# Comprehensive Style Guide\n\nDetailed style guidelines for all supported languages.\n\n## JavaScript/TypeScript\n\n### Variable Declarations\n\nUse `const` by default, `let` when reassignment needed, never `var`:\n\n\\`\\`\\`javascript\n// Good\nconst MAX_RETRIES = 3\nlet currentTry = 0\n\n// Bad\nvar MAX_RETRIES = 3\n\\`\\`\\`\n\n### Function Declarations\n\nUse function expressions for consistency:\n\n\\`\\`\\`javascript\n// Good\nconst calculateTotal = (items) => {\n  return items.reduce((sum, item) => sum + item.price, 0)\n}\n\n// Bad (inconsistent style)\nfunction calculateTotal(items) {\n  return items.reduce((sum, item) => sum + item.price, 0)\n}\n\\`\\`\\`\n\n### Async/Await\n\nPrefer async/await over promise chains:\n\n\\`\\`\\`javascript\n// Good\nasync function fetchUserData(userId) {\n  const user = await db.getUser(userId)\n  const orders = await db.getOrders(user.id)\n  return { user, orders }\n}\n\n// Bad\nfunction fetchUserData(userId) {\n  return db.getUser(userId)\n    .then(user => db.getOrders(user.id)\n      .then(orders => ({ user, orders })))\n}\n\\`\\`\\`\n\n## Python\n\n### Import Organization\n\nOrder imports: standard library, third-party, local:\n\n\\`\\`\\`python\n# Good\nimport os\nimport sys\n\nimport numpy as np\nimport pandas as pd\n\nfrom app.models import User\nfrom app.utils import helper\n\n# Bad - mixed order\nfrom app.models import User\nimport numpy as np\nimport os\n\\`\\`\\`\n\n### Type Hints\n\nUse type hints for all function signatures:\n\n\\`\\`\\`python\n# Good\ndef calculate_average(numbers: list[float]) -> float:\n    return sum(numbers) / len(numbers)\n\n# Bad\ndef calculate_average(numbers):\n    return sum(numbers) / len(numbers)\n\\`\\`\\`\n\n## Additional Languages\n\nSee language-specific guides for:\n- Go: `references/go-style.md`\n- Rust: `references/rust-style.md`\n- Ruby: `references/ruby-style.md`\n```\n\n### hooks/hooks.json\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Before modifying code, verify it meets our coding standards from the code-standards skill. Check formatting, naming conventions, and documentation. If standards aren't met, suggest improvements.\",\n          \"timeout\": 30\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \".*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate-commit.sh\",\n          \"timeout\": 45\n        }\n      ]\n    }\n  ]\n}\n```\n\n### hooks/scripts/validate-commit.sh\n\n```bash\n#!/bin/bash\n# Validate code quality before task completion\n\nset -e\n\n# Check if there are any uncommitted changes\nif [[ -z $(git status -s) ]]; then\n  echo '{\"systemMessage\": \"No changes to validate. Task complete.\"}'\n  exit 0\nfi\n\n# Run linter on changed files\nCHANGED_FILES=$(git diff --name-only --cached | grep -E '\\.(js|ts|py)$' || true)\n\nif [[ -z \"$CHANGED_FILES\" ]]; then\n  echo '{\"systemMessage\": \"No code files changed. Validation passed.\"}'\n  exit 0\nfi\n\n# Run appropriate linters\nISSUES=0\n\nfor file in $CHANGED_FILES; do\n  case \"$file\" in\n    *.js|*.ts)\n      if ! npx eslint \"$file\" --quiet; then\n        ISSUES=$((ISSUES + 1))\n      fi\n      ;;\n    *.py)\n      if ! python -m pylint \"$file\" --errors-only; then\n        ISSUES=$((ISSUES + 1))\n      fi\n      ;;\n  esac\ndone\n\nif [[ $ISSUES -gt 0 ]]; then\n  echo \"{\\\"systemMessage\\\": \\\"Found $ISSUES code quality issues. Please fix before completing.\\\"}\"\n  exit 1\nfi\n\necho '{\"systemMessage\": \"Code quality checks passed. Ready to commit.\"}'\nexit 0\n```\n\n## Usage Examples\n\n### Running Commands\n\n```\n$ claude\n> /lint\nRunning linter checks...\n\nCritical Issues (2):\n  src/api/users.js:45 - SQL injection vulnerability\n  src/utils/helpers.js:12 - Unhandled promise rejection\n\nWarnings (5):\n  src/components/Button.tsx:23 - Missing PropTypes\n  ...\n\nStyle Suggestions (8):\n  src/index.js:1 - Use const instead of let\n  ...\n\n> /test\nRunning test suite...\n\nTest Results:\n  âœ“ 245 passed\n  âœ— 3 failed\n  â—‹ 2 skipped\n\nCoverage: 87.3%\n\nUntested Files:\n  src/utils/cache.js - 0% coverage\n  src/api/webhooks.js - 23% coverage\n\nFailed Tests:\n  1. User API â€º GET /users â€º should handle pagination\n     Expected 200, received 500\n  ...\n```\n\n### Using Agents\n\n```\n> Review the changes in src/api/users.js\n\n[code-reviewer agent selected automatically]\n\nCode Review: src/api/users.js\n\nCritical Issues:\n  1. Line 45: SQL injection vulnerability\n     - Using string concatenation for SQL query\n     - Replace with parameterized query\n     - Priority: CRITICAL\n\n  2. Line 67: Missing error handling\n     - Database query without try/catch\n     - Could crash server on DB error\n     - Priority: HIGH\n\nSuggestions:\n  1. Line 23: Consider caching user data\n     - Frequent DB queries for same users\n     - Add Redis caching layer\n     - Priority: MEDIUM\n```\n\n## Key Points\n\n1. **Complete manifest**: All recommended metadata fields\n2. **Multiple components**: Commands, agents, skills, hooks\n3. **Rich skills**: References and examples for detailed information\n4. **Automation**: Hooks enforce standards automatically\n5. **Integration**: Components work together cohesively\n\n## When to Use This Pattern\n\n- Production plugins for distribution\n- Team collaboration tools\n- Plugins requiring consistency enforcement\n- Complex workflows with multiple entry points\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-structure/examples/advanced-plugin.md","content":"# Advanced Plugin Example\n\nA complex, enterprise-grade plugin with MCP integration and advanced organization.\n\n## Directory Structure\n\n```\nenterprise-devops/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ ci/\nâ”‚   â”‚   â”œâ”€â”€ build.md\nâ”‚   â”‚   â”œâ”€â”€ test.md\nâ”‚   â”‚   â””â”€â”€ deploy.md\nâ”‚   â”œâ”€â”€ monitoring/\nâ”‚   â”‚   â”œâ”€â”€ status.md\nâ”‚   â”‚   â””â”€â”€ logs.md\nâ”‚   â””â”€â”€ admin/\nâ”‚       â”œâ”€â”€ configure.md\nâ”‚       â””â”€â”€ manage.md\nâ”œâ”€â”€ agents/\nâ”‚   â”œâ”€â”€ orchestration/\nâ”‚   â”‚   â”œâ”€â”€ deployment-orchestrator.md\nâ”‚   â”‚   â””â”€â”€ rollback-manager.md\nâ”‚   â””â”€â”€ specialized/\nâ”‚       â”œâ”€â”€ kubernetes-expert.md\nâ”‚       â”œâ”€â”€ terraform-expert.md\nâ”‚       â””â”€â”€ security-auditor.md\nâ”œâ”€â”€ skills/\nâ”‚   â”œâ”€â”€ kubernetes-ops/\nâ”‚   â”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”‚   â”œâ”€â”€ references/\nâ”‚   â”‚   â”‚   â”œâ”€â”€ deployment-patterns.md\nâ”‚   â”‚   â”‚   â”œâ”€â”€ troubleshooting.md\nâ”‚   â”‚   â”‚   â””â”€â”€ security.md\nâ”‚   â”‚   â”œâ”€â”€ examples/\nâ”‚   â”‚   â”‚   â”œâ”€â”€ basic-deployment.yaml\nâ”‚   â”‚   â”‚   â”œâ”€â”€ stateful-set.yaml\nâ”‚   â”‚   â”‚   â””â”€â”€ ingress-config.yaml\nâ”‚   â”‚   â””â”€â”€ scripts/\nâ”‚   â”‚       â”œâ”€â”€ validate-manifest.sh\nâ”‚   â”‚       â””â”€â”€ health-check.sh\nâ”‚   â”œâ”€â”€ terraform-iac/\nâ”‚   â”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”‚   â”œâ”€â”€ references/\nâ”‚   â”‚   â”‚   â””â”€â”€ best-practices.md\nâ”‚   â”‚   â””â”€â”€ examples/\nâ”‚   â”‚       â””â”€â”€ module-template/\nâ”‚   â””â”€â”€ ci-cd-pipelines/\nâ”‚       â”œâ”€â”€ SKILL.md\nâ”‚       â””â”€â”€ references/\nâ”‚           â””â”€â”€ pipeline-patterns.md\nâ”œâ”€â”€ hooks/\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”‚       â”œâ”€â”€ security/\nâ”‚       â”‚   â”œâ”€â”€ scan-secrets.sh\nâ”‚       â”‚   â”œâ”€â”€ validate-permissions.sh\nâ”‚       â”‚   â””â”€â”€ audit-changes.sh\nâ”‚       â”œâ”€â”€ quality/\nâ”‚       â”‚   â”œâ”€â”€ check-config.sh\nâ”‚       â”‚   â””â”€â”€ verify-tests.sh\nâ”‚       â””â”€â”€ workflow/\nâ”‚           â”œâ”€â”€ notify-team.sh\nâ”‚           â””â”€â”€ update-status.sh\nâ”œâ”€â”€ .mcp.json\nâ”œâ”€â”€ servers/\nâ”‚   â”œâ”€â”€ kubernetes-mcp/\nâ”‚   â”‚   â”œâ”€â”€ index.js\nâ”‚   â”‚   â”œâ”€â”€ package.json\nâ”‚   â”‚   â””â”€â”€ lib/\nâ”‚   â”œâ”€â”€ terraform-mcp/\nâ”‚   â”‚   â”œâ”€â”€ main.py\nâ”‚   â”‚   â””â”€â”€ requirements.txt\nâ”‚   â””â”€â”€ github-actions-mcp/\nâ”‚       â”œâ”€â”€ server.js\nâ”‚       â””â”€â”€ package.json\nâ”œâ”€â”€ lib/\nâ”‚   â”œâ”€â”€ core/\nâ”‚   â”‚   â”œâ”€â”€ logger.js\nâ”‚   â”‚   â”œâ”€â”€ config.js\nâ”‚   â”‚   â””â”€â”€ auth.js\nâ”‚   â”œâ”€â”€ integrations/\nâ”‚   â”‚   â”œâ”€â”€ slack.js\nâ”‚   â”‚   â”œâ”€â”€ pagerduty.js\nâ”‚   â”‚   â””â”€â”€ datadog.js\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ retry.js\nâ”‚       â””â”€â”€ validation.js\nâ””â”€â”€ config/\n    â”œâ”€â”€ environments/\n    â”‚   â”œâ”€â”€ production.json\n    â”‚   â”œâ”€â”€ staging.json\n    â”‚   â””â”€â”€ development.json\n    â””â”€â”€ templates/\n        â”œâ”€â”€ deployment.yaml\n        â””â”€â”€ service.yaml\n```\n\n## File Contents\n\n### .claude-plugin/plugin.json\n\n```json\n{\n  \"name\": \"enterprise-devops\",\n  \"version\": \"2.3.1\",\n  \"description\": \"Comprehensive DevOps automation for enterprise CI/CD pipelines, infrastructure management, and monitoring\",\n  \"author\": {\n    \"name\": \"DevOps Platform Team\",\n    \"email\": \"devops-platform@company.com\",\n    \"url\": \"https://company.com/teams/devops\"\n  },\n  \"homepage\": \"https://docs.company.com/plugins/devops\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/company/devops-plugin.git\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"keywords\": [\n    \"devops\",\n    \"ci-cd\",\n    \"kubernetes\",\n    \"terraform\",\n    \"automation\",\n    \"infrastructure\",\n    \"deployment\",\n    \"monitoring\"\n  ],\n  \"commands\": [\n    \"./commands/ci\",\n    \"./commands/monitoring\",\n    \"./commands/admin\"\n  ],\n  \"agents\": [\n    \"./agents/orchestration\",\n    \"./agents/specialized\"\n  ],\n  \"hooks\": \"./hooks/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n### .mcp.json\n\n```json\n{\n  \"mcpServers\": {\n    \"kubernetes\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/kubernetes-mcp/index.js\"],\n      \"env\": {\n        \"KUBECONFIG\": \"${KUBECONFIG}\",\n        \"K8S_NAMESPACE\": \"${K8S_NAMESPACE:-default}\"\n      }\n    },\n    \"terraform\": {\n      \"command\": \"python\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/terraform-mcp/main.py\"],\n      \"env\": {\n        \"TF_STATE_BUCKET\": \"${TF_STATE_BUCKET}\",\n        \"AWS_REGION\": \"${AWS_REGION}\"\n      }\n    },\n    \"github-actions\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/github-actions-mcp/server.js\"],\n      \"env\": {\n        \"GITHUB_TOKEN\": \"${GITHUB_TOKEN}\",\n        \"GITHUB_ORG\": \"${GITHUB_ORG}\"\n      }\n    }\n  }\n}\n```\n\n### commands/ci/build.md\n\n```markdown\n---\nname: build\ndescription: Trigger and monitor CI build pipeline\n---\n\n# Build Command\n\nTrigger CI/CD build pipeline and monitor progress in real-time.\n\n## Process\n\n1. **Validation**: Check prerequisites\n   - Verify branch status\n   - Check for uncommitted changes\n   - Validate configuration files\n\n2. **Trigger**: Start build via MCP server\n   \\`\\`\\`javascript\n   // Uses github-actions MCP server\n   const build = await tools.github_actions_trigger_workflow({\n     workflow: 'build.yml',\n     ref: currentBranch\n   })\n   \\`\\`\\`\n\n3. **Monitor**: Track build progress\n   - Display real-time logs\n   - Show test results as they complete\n   - Alert on failures\n\n4. **Report**: Summarize results\n   - Build status\n   - Test coverage\n   - Performance metrics\n   - Deploy readiness\n\n## Integration\n\nAfter successful build:\n- Offer to deploy to staging\n- Suggest performance optimizations\n- Generate deployment checklist\n```\n\n### agents/orchestration/deployment-orchestrator.md\n\n```markdown\n---\ndescription: Orchestrates complex multi-environment deployments with rollback capabilities and health monitoring\ncapabilities:\n  - Plan and execute multi-stage deployments\n  - Coordinate service dependencies\n  - Monitor deployment health\n  - Execute automated rollbacks\n  - Manage deployment approvals\n---\n\n# Deployment Orchestrator Agent\n\nSpecialized agent for orchestrating complex deployments across multiple environments.\n\n## Expertise\n\n- **Deployment strategies**: Blue-green, canary, rolling updates\n- **Dependency management**: Service startup ordering, dependency injection\n- **Health monitoring**: Service health checks, metric validation\n- **Rollback automation**: Automatic rollback on failure detection\n- **Approval workflows**: Multi-stage approval processes\n\n## Orchestration Process\n\n1. **Planning Phase**\n   - Analyze deployment requirements\n   - Identify service dependencies\n   - Generate deployment plan\n   - Calculate rollback strategy\n\n2. **Validation Phase**\n   - Verify environment readiness\n   - Check resource availability\n   - Validate configurations\n   - Run pre-deployment tests\n\n3. **Execution Phase**\n   - Deploy services in dependency order\n   - Monitor health after each stage\n   - Validate metrics and logs\n   - Proceed to next stage on success\n\n4. **Verification Phase**\n   - Run smoke tests\n   - Validate service integration\n   - Check performance metrics\n   - Confirm deployment success\n\n5. **Rollback Phase** (if needed)\n   - Detect failure conditions\n   - Execute rollback plan\n   - Restore previous state\n   - Notify stakeholders\n\n## MCP Integration\n\nUses multiple MCP servers:\n- `kubernetes`: Deploy and manage containers\n- `terraform`: Provision infrastructure\n- `github-actions`: Trigger deployment pipelines\n\n## Monitoring Integration\n\nIntegrates with monitoring tools via lib:\n\\`\\`\\`javascript\nconst { DatadogClient } = require('${CLAUDE_PLUGIN_ROOT}/lib/integrations/datadog')\nconst metrics = await DatadogClient.getMetrics(service, timeRange)\n\\`\\`\\`\n\n## Notification Integration\n\nSends updates via Slack and PagerDuty:\n\\`\\`\\`javascript\nconst { SlackClient } = require('${CLAUDE_PLUGIN_ROOT}/lib/integrations/slack')\nawait SlackClient.notify({\n  channel: '#deployments',\n  message: 'Deployment started',\n  metadata: deploymentPlan\n})\n\\`\\`\\`\n```\n\n### skills/kubernetes-ops/SKILL.md\n\n```markdown\n---\nname: Kubernetes Operations\ndescription: This skill should be used when deploying to Kubernetes, managing K8s resources, troubleshooting cluster issues, configuring ingress/services, scaling deployments, or working with Kubernetes manifests. Provides comprehensive Kubernetes operational knowledge and best practices.\nversion: 2.0.0\n---\n\n# Kubernetes Operations\n\nComprehensive operational knowledge for managing Kubernetes clusters and workloads.\n\n## Overview\n\nManage Kubernetes infrastructure effectively through:\n- Deployment strategies and patterns\n- Resource configuration and optimization\n- Troubleshooting and debugging\n- Security best practices\n- Performance tuning\n\n## Core Concepts\n\n### Resource Management\n\n**Deployments**: Use for stateless applications\n- Rolling updates for zero-downtime deployments\n- Rollback capabilities for failed deployments\n- Replica management for scaling\n\n**StatefulSets**: Use for stateful applications\n- Stable network identities\n- Persistent storage\n- Ordered deployment and scaling\n\n**DaemonSets**: Use for node-level services\n- Log collectors\n- Monitoring agents\n- Network plugins\n\n### Configuration\n\n**ConfigMaps**: Store non-sensitive configuration\n- Environment-specific settings\n- Application configuration files\n- Feature flags\n\n**Secrets**: Store sensitive data\n- API keys and tokens\n- Database credentials\n- TLS certificates\n\nUse external secret management (Vault, AWS Secrets Manager) for production.\n\n### Networking\n\n**Services**: Expose applications internally\n- ClusterIP for internal communication\n- NodePort for external access (non-production)\n- LoadBalancer for external access (production)\n\n**Ingress**: HTTP/HTTPS routing\n- Path-based routing\n- Host-based routing\n- TLS termination\n- Load balancing\n\n## Deployment Strategies\n\n### Rolling Update\n\nDefault strategy, gradual replacement:\n\\`\\`\\`yaml\nstrategy:\n  type: RollingUpdate\n  rollingUpdate:\n    maxSurge: 1\n    maxUnavailable: 0\n\\`\\`\\`\n\n**When to use**: Standard deployments, minor updates\n\n### Recreate\n\nStop all pods, then create new ones:\n\\`\\`\\`yaml\nstrategy:\n  type: Recreate\n\\`\\`\\`\n\n**When to use**: Stateful apps that can't run multiple versions\n\n### Blue-Green\n\nRun two complete environments, switch traffic:\n1. Deploy new version (green)\n2. Test green environment\n3. Switch traffic to green\n4. Keep blue for quick rollback\n\n**When to use**: Critical services, need instant rollback\n\n### Canary\n\nGradually roll out to subset of users:\n1. Deploy canary version (10% traffic)\n2. Monitor metrics and errors\n3. Increase traffic gradually\n4. Complete rollout or rollback\n\n**When to use**: High-risk changes, want gradual validation\n\n## Resource Configuration\n\n### Resource Requests and Limits\n\nAlways set for production workloads:\n\\`\\`\\`yaml\nresources:\n  requests:\n    memory: \"256Mi\"\n    cpu: \"250m\"\n  limits:\n    memory: \"512Mi\"\n    cpu: \"500m\"\n\\`\\`\\`\n\n**Requests**: Guaranteed resources\n**Limits**: Maximum allowed resources\n\n### Health Checks\n\nEssential for reliability:\n\\`\\`\\`yaml\nlivenessProbe:\n  httpGet:\n    path: /health\n    port: 8080\n  initialDelaySeconds: 30\n  periodSeconds: 10\n\nreadinessProbe:\n  httpGet:\n    path: /ready\n    port: 8080\n  initialDelaySeconds: 5\n  periodSeconds: 5\n\\`\\`\\`\n\n**Liveness**: Restart unhealthy pods\n**Readiness**: Remove unready pods from service\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Pods not starting**\n   - Check: `kubectl describe pod <name>`\n   - Look for: Image pull errors, resource constraints\n   - Fix: Verify image name, increase resources\n\n2. **Service not reachable**\n   - Check: `kubectl get svc`, `kubectl get endpoints`\n   - Look for: No endpoints, wrong selector\n   - Fix: Verify pod labels match service selector\n\n3. **High memory usage**\n   - Check: `kubectl top pods`\n   - Look for: Pods near memory limit\n   - Fix: Increase limits, optimize application\n\n4. **Frequent restarts**\n   - Check: `kubectl get pods`, `kubectl logs <name>`\n   - Look for: Liveness probe failures, OOMKilled\n   - Fix: Adjust health checks, increase memory\n\n### Debugging Commands\n\nGet pod details:\n\\`\\`\\`bash\nkubectl describe pod <name>\nkubectl logs <name>\nkubectl logs <name> --previous  # logs from crashed container\n\\`\\`\\`\n\nExecute commands in pod:\n\\`\\`\\`bash\nkubectl exec -it <name> -- /bin/sh\nkubectl exec <name> -- env\n\\`\\`\\`\n\nCheck resource usage:\n\\`\\`\\`bash\nkubectl top nodes\nkubectl top pods\n\\`\\`\\`\n\n## Security Best Practices\n\n### Pod Security\n\n- Run as non-root user\n- Use read-only root filesystem\n- Drop unnecessary capabilities\n- Use security contexts\n\nExample:\n\\`\\`\\`yaml\nsecurityContext:\n  runAsNonRoot: true\n  runAsUser: 1000\n  readOnlyRootFilesystem: true\n  capabilities:\n    drop:\n      - ALL\n\\`\\`\\`\n\n### Network Policies\n\nRestrict pod communication:\n\\`\\`\\`yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: api-allow\nspec:\n  podSelector:\n    matchLabels:\n      app: api\n  ingress:\n    - from:\n      - podSelector:\n          matchLabels:\n            app: frontend\n\\`\\`\\`\n\n### Secrets Management\n\n- Never commit secrets to git\n- Use external secret managers\n- Rotate secrets regularly\n- Limit secret access with RBAC\n\n## Performance Optimization\n\n### Resource Tuning\n\n1. **Start conservative**: Set low limits initially\n2. **Monitor usage**: Track actual resource consumption\n3. **Adjust gradually**: Increase based on metrics\n4. **Set appropriate requests**: Match typical usage\n5. **Set safe limits**: 2x requests for headroom\n\n### Horizontal Pod Autoscaling\n\nAutomatically scale based on metrics:\n\\`\\`\\`yaml\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: api-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: api\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          type: Utilization\n          averageUtilization: 70\n\\`\\`\\`\n\n## MCP Server Integration\n\nThis skill works with the kubernetes MCP server for operations:\n\n**List pods**:\n\\`\\`\\`javascript\nconst pods = await tools.k8s_list_pods({ namespace: 'default' })\n\\`\\`\\`\n\n**Get pod logs**:\n\\`\\`\\`javascript\nconst logs = await tools.k8s_get_logs({ pod: 'api-xyz', container: 'app' })\n\\`\\`\\`\n\n**Apply manifests**:\n\\`\\`\\`javascript\nconst result = await tools.k8s_apply_manifest({ file: 'deployment.yaml' })\n\\`\\`\\`\n\n## Detailed References\n\nFor in-depth information:\n- **Deployment patterns**: `references/deployment-patterns.md`\n- **Troubleshooting guide**: `references/troubleshooting.md`\n- **Security hardening**: `references/security.md`\n\n## Example Manifests\n\nFor copy-paste examples:\n- **Basic deployment**: `examples/basic-deployment.yaml`\n- **StatefulSet**: `examples/stateful-set.yaml`\n- **Ingress config**: `examples/ingress-config.yaml`\n\n## Validation Scripts\n\nFor manifest validation:\n\\`\\`\\`bash\nbash ${CLAUDE_PLUGIN_ROOT}/skills/kubernetes-ops/scripts/validate-manifest.sh deployment.yaml\n\\`\\`\\`\n```\n\n### hooks/hooks.json\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/security/scan-secrets.sh\",\n          \"timeout\": 30\n        }\n      ]\n    },\n    {\n      \"matcher\": \"Bash\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Evaluate if this bash command is safe for production environment. Check for destructive operations, missing safeguards, and potential security issues. Commands should be idempotent and reversible.\",\n          \"timeout\": 20\n        }\n      ]\n    }\n  ],\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Bash\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/workflow/update-status.sh\",\n          \"timeout\": 15\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \".*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/quality/check-config.sh\",\n          \"timeout\": 45\n        },\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/workflow/notify-team.sh\",\n          \"timeout\": 30\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \".*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/security/validate-permissions.sh\",\n          \"timeout\": 20\n        }\n      ]\n    }\n  ]\n}\n```\n\n## Key Features\n\n### Multi-Level Organization\n\n**Commands**: Organized by function (CI, monitoring, admin)\n**Agents**: Separated by role (orchestration vs. specialized)\n**Skills**: Rich resources (references, examples, scripts)\n\n### MCP Integration\n\nThree custom MCP servers:\n- **Kubernetes**: Cluster operations\n- **Terraform**: Infrastructure provisioning\n- **GitHub Actions**: CI/CD automation\n\n### Shared Libraries\n\nReusable code in `lib/`:\n- **Core**: Common utilities (logging, config, auth)\n- **Integrations**: External services (Slack, Datadog)\n- **Utils**: Helper functions (retry, validation)\n\n### Configuration Management\n\nEnvironment-specific configs in `config/`:\n- **Environments**: Per-environment settings\n- **Templates**: Reusable deployment templates\n\n### Security Automation\n\nMultiple security hooks:\n- Secret scanning before writes\n- Permission validation on session start\n- Configuration auditing on completion\n\n### Monitoring Integration\n\nBuilt-in monitoring via lib integrations:\n- Datadog for metrics\n- PagerDuty for alerts\n- Slack for notifications\n\n## Use Cases\n\n1. **Multi-environment deployments**: Orchestrated rollouts across dev/staging/prod\n2. **Infrastructure as code**: Terraform automation with state management\n3. **CI/CD automation**: Build, test, deploy pipelines\n4. **Monitoring and observability**: Integrated metrics and alerting\n5. **Security enforcement**: Automated security scanning and validation\n6. **Team collaboration**: Slack notifications and status updates\n\n## When to Use This Pattern\n\n- Large-scale enterprise deployments\n- Multiple environment management\n- Complex CI/CD workflows\n- Integrated monitoring requirements\n- Security-critical infrastructure\n- Team collaboration needs\n\n## Scaling Considerations\n\n- **Performance**: Separate MCP servers for parallel operations\n- **Organization**: Multi-level directories for scalability\n- **Maintainability**: Shared libraries reduce duplication\n- **Flexibility**: Environment configs enable customization\n- **Security**: Layered security hooks and validation\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-structure/examples/minimal-plugin.md","content":"# Minimal Plugin Example\n\nA bare-bones plugin with a single command.\n\n## Directory Structure\n\n```\nhello-world/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md\n```\n\n## File Contents\n\n### .claude-plugin/plugin.json\n\n```json\n{\n  \"name\": \"hello-world\"\n}\n```\n\n### commands/hello.md\n\n```markdown\n---\nname: hello\ndescription: Prints a friendly greeting message\n---\n\n# Hello Command\n\nPrint a friendly greeting to the user.\n\n## Implementation\n\nOutput the following message to the user:\n\n> Hello! This is a simple command from the hello-world plugin.\n>\n> Use this as a starting point for building more complex plugins.\n\nInclude the current timestamp in the greeting to show the command executed successfully.\n```\n\n## Usage\n\nAfter installing the plugin:\n\n```\n$ claude\n> /hello\nHello! This is a simple command from the hello-world plugin.\n\nUse this as a starting point for building more complex plugins.\n\nExecuted at: 2025-01-15 14:30:22 UTC\n```\n\n## Key Points\n\n1. **Minimal manifest**: Only the required `name` field\n2. **Single command**: One markdown file in `commands/` directory\n3. **Auto-discovery**: Claude Code finds the command automatically\n4. **No dependencies**: No scripts, hooks, or external resources\n\n## When to Use This Pattern\n\n- Quick prototypes\n- Single-purpose utilities\n- Learning plugin development\n- Internal team tools with one specific function\n\n## Extending This Plugin\n\nTo add more functionality:\n\n1. **Add commands**: Create more `.md` files in `commands/`\n2. **Add metadata**: Update `plugin.json` with version, description, author\n3. **Add agents**: Create `agents/` directory with agent definitions\n4. **Add hooks**: Create `hooks/hooks.json` for event handling\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-structure/README.md","content":"# Plugin Structure Skill\n\nComprehensive guidance on Claude Code plugin architecture, directory layout, and best practices.\n\n## Overview\n\nThis skill provides detailed knowledge about:\n- Plugin directory structure and organization\n- `plugin.json` manifest configuration\n- Component organization (commands, agents, skills, hooks)\n- Auto-discovery mechanisms\n- Portable path references with `${CLAUDE_PLUGIN_ROOT}`\n- File naming conventions\n\n## Skill Structure\n\n### SKILL.md (1,619 words)\n\nCore skill content covering:\n- Directory structure overview\n- Plugin manifest (plugin.json) fields\n- Component organization patterns\n- ${CLAUDE_PLUGIN_ROOT} usage\n- File naming conventions\n- Auto-discovery mechanism\n- Best practices\n- Common patterns\n- Troubleshooting\n\n### References\n\nDetailed documentation for deep dives:\n\n- **manifest-reference.md**: Complete `plugin.json` field reference\n  - All field descriptions and examples\n  - Path resolution rules\n  - Validation guidelines\n  - Minimal vs. complete manifest examples\n\n- **component-patterns.md**: Advanced organization patterns\n  - Component lifecycle (discovery, activation)\n  - Command organization patterns\n  - Agent organization patterns\n  - Skill organization patterns\n  - Hook organization patterns\n  - Script organization patterns\n  - Cross-component patterns\n  - Best practices for scalability\n\n### Examples\n\nThree complete plugin examples:\n\n- **minimal-plugin.md**: Simplest possible plugin\n  - Single command\n  - Minimal manifest\n  - When to use this pattern\n\n- **standard-plugin.md**: Well-structured production plugin\n  - Multiple components (commands, agents, skills, hooks)\n  - Complete manifest with metadata\n  - Rich skill structure\n  - Integration between components\n\n- **advanced-plugin.md**: Enterprise-grade plugin\n  - Multi-level organization\n  - MCP server integration\n  - Shared libraries\n  - Configuration management\n  - Security automation\n  - Monitoring integration\n\n## When This Skill Triggers\n\nClaude Code activates this skill when users:\n- Ask to \"create a plugin\" or \"scaffold a plugin\"\n- Need to \"understand plugin structure\"\n- Want to \"organize plugin components\"\n- Need to \"set up plugin.json\"\n- Ask about \"${CLAUDE_PLUGIN_ROOT}\" usage\n- Want to \"add commands/agents/skills/hooks\"\n- Need \"configure auto-discovery\" help\n- Ask about plugin architecture or best practices\n\n## Progressive Disclosure\n\nThe skill uses progressive disclosure to manage context:\n\n1. **SKILL.md** (~1600 words): Core concepts and workflows\n2. **References** (~6000 words): Detailed field references and patterns\n3. **Examples** (~8000 words): Complete working examples\n\nClaude loads references and examples only as needed based on the task.\n\n## Related Skills\n\nThis skill works well with:\n- **hook-development**: For creating plugin hooks\n- **mcp-integration**: For integrating MCP servers (when available)\n- **marketplace-publishing**: For publishing plugins (when available)\n\n## Maintenance\n\nTo update this skill:\n1. Keep SKILL.md lean and focused on core concepts\n2. Move detailed information to references/\n3. Add new examples/ for common patterns\n4. Update version in SKILL.md frontmatter\n5. Ensure all documentation uses imperative/infinitive form\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-structure/references/component-patterns.md","content":"# Component Organization Patterns\n\nAdvanced patterns for organizing plugin components effectively.\n\n## Component Lifecycle\n\n### Discovery Phase\n\nWhen Claude Code starts:\n\n1. **Scan enabled plugins**: Read `.claude-plugin/plugin.json` for each\n2. **Discover components**: Look in default and custom paths\n3. **Parse definitions**: Read YAML frontmatter and configurations\n4. **Register components**: Make available to Claude Code\n5. **Initialize**: Start MCP servers, register hooks\n\n**Timing**: Component registration happens during Claude Code initialization, not continuously.\n\n### Activation Phase\n\nWhen components are used:\n\n**Commands**: User types slash command â†’ Claude Code looks up â†’ Executes\n**Agents**: Task arrives â†’ Claude Code evaluates capabilities â†’ Selects agent\n**Skills**: Task context matches description â†’ Claude Code loads skill\n**Hooks**: Event occurs â†’ Claude Code calls matching hooks\n**MCP Servers**: Tool call matches server capability â†’ Forwards to server\n\n## Command Organization Patterns\n\n### Flat Structure\n\nSingle directory with all commands:\n\n```\ncommands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**When to use**:\n- 5-15 commands total\n- All commands at same abstraction level\n- No clear categorization\n\n**Advantages**:\n- Simple, easy to navigate\n- No configuration needed\n- Fast discovery\n\n### Categorized Structure\n\nMultiple directories for different command types:\n\n```\ncommands/              # Core commands\nâ”œâ”€â”€ build.md\nâ””â”€â”€ test.md\n\nadmin-commands/        # Administrative\nâ”œâ”€â”€ configure.md\nâ””â”€â”€ manage.md\n\nworkflow-commands/     # Workflow automation\nâ”œâ”€â”€ review.md\nâ””â”€â”€ deploy.md\n```\n\n**Manifest configuration**:\n```json\n{\n  \"commands\": [\n    \"./commands\",\n    \"./admin-commands\",\n    \"./workflow-commands\"\n  ]\n}\n```\n\n**When to use**:\n- 15+ commands\n- Clear functional categories\n- Different permission levels\n\n**Advantages**:\n- Organized by purpose\n- Easier to maintain\n- Can restrict access by directory\n\n### Hierarchical Structure\n\nNested organization for complex plugins:\n\n```\ncommands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md\nâ”‚   â”œâ”€â”€ test.md\nâ”‚   â””â”€â”€ lint.md\nâ”œâ”€â”€ deployment/\nâ”‚   â”œâ”€â”€ staging.md\nâ”‚   â””â”€â”€ production.md\nâ””â”€â”€ management/\n    â”œâ”€â”€ config.md\n    â””â”€â”€ status.md\n```\n\n**Note**: Claude Code doesn't support nested command discovery automatically. Use custom paths:\n\n```json\n{\n  \"commands\": [\n    \"./commands/ci\",\n    \"./commands/deployment\",\n    \"./commands/management\"\n  ]\n}\n```\n\n**When to use**:\n- 20+ commands\n- Multi-level categorization\n- Complex workflows\n\n**Advantages**:\n- Maximum organization\n- Clear boundaries\n- Scalable structure\n\n## Agent Organization Patterns\n\n### Role-Based Organization\n\nOrganize agents by their primary role:\n\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md        # Reviews code\nâ”œâ”€â”€ test-generator.md       # Generates tests\nâ”œâ”€â”€ documentation-writer.md # Writes docs\nâ””â”€â”€ refactorer.md          # Refactors code\n```\n\n**When to use**:\n- Agents have distinct, non-overlapping roles\n- Users invoke agents manually\n- Clear agent responsibilities\n\n### Capability-Based Organization\n\nOrganize by specific capabilities:\n\n```\nagents/\nâ”œâ”€â”€ python-expert.md        # Python-specific\nâ”œâ”€â”€ typescript-expert.md    # TypeScript-specific\nâ”œâ”€â”€ api-specialist.md       # API design\nâ””â”€â”€ database-specialist.md  # Database work\n```\n\n**When to use**:\n- Technology-specific agents\n- Domain expertise focus\n- Automatic agent selection\n\n### Workflow-Based Organization\n\nOrganize by workflow stage:\n\n```\nagents/\nâ”œâ”€â”€ planning-agent.md      # Planning phase\nâ”œâ”€â”€ implementation-agent.md # Coding phase\nâ”œâ”€â”€ testing-agent.md       # Testing phase\nâ””â”€â”€ deployment-agent.md    # Deployment phase\n```\n\n**When to use**:\n- Sequential workflows\n- Stage-specific expertise\n- Pipeline automation\n\n## Skill Organization Patterns\n\n### Topic-Based Organization\n\nEach skill covers a specific topic:\n\n```\nskills/\nâ”œâ”€â”€ api-design/\nâ”‚   â””â”€â”€ SKILL.md\nâ”œâ”€â”€ error-handling/\nâ”‚   â””â”€â”€ SKILL.md\nâ”œâ”€â”€ testing-strategies/\nâ”‚   â””â”€â”€ SKILL.md\nâ””â”€â”€ performance-optimization/\n    â””â”€â”€ SKILL.md\n```\n\n**When to use**:\n- Knowledge-based skills\n- Educational or reference content\n- Broad applicability\n\n### Tool-Based Organization\n\nSkills for specific tools or technologies:\n\n```\nskills/\nâ”œâ”€â”€ docker/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ dockerfile-best-practices.md\nâ”œâ”€â”€ kubernetes/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â””â”€â”€ examples/\nâ”‚       â””â”€â”€ deployment.yaml\nâ””â”€â”€ terraform/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ scripts/\n        â””â”€â”€ validate-config.sh\n```\n\n**When to use**:\n- Tool-specific expertise\n- Complex tool configurations\n- Tool best practices\n\n### Workflow-Based Organization\n\nSkills for complete workflows:\n\n```\nskills/\nâ”œâ”€â”€ code-review-workflow/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â””â”€â”€ references/\nâ”‚       â”œâ”€â”€ checklist.md\nâ”‚       â””â”€â”€ standards.md\nâ”œâ”€â”€ deployment-workflow/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â””â”€â”€ scripts/\nâ”‚       â”œâ”€â”€ pre-deploy.sh\nâ”‚       â””â”€â”€ post-deploy.sh\nâ””â”€â”€ testing-workflow/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ test-structure.md\n```\n\n**When to use**:\n- Multi-step processes\n- Company-specific workflows\n- Process automation\n\n### Skill with Rich Resources\n\nComprehensive skill with all resource types:\n\n```\nskills/\nâ””â”€â”€ api-testing/\n    â”œâ”€â”€ SKILL.md              # Core skill (1500 words)\n    â”œâ”€â”€ references/\n    â”‚   â”œâ”€â”€ rest-api-guide.md\n    â”‚   â”œâ”€â”€ graphql-guide.md\n    â”‚   â””â”€â”€ authentication.md\n    â”œâ”€â”€ examples/\n    â”‚   â”œâ”€â”€ basic-test.js\n    â”‚   â”œâ”€â”€ authenticated-test.js\n    â”‚   â””â”€â”€ integration-test.js\n    â”œâ”€â”€ scripts/\n    â”‚   â”œâ”€â”€ run-tests.sh\n    â”‚   â””â”€â”€ generate-report.py\n    â””â”€â”€ assets/\n        â””â”€â”€ test-template.json\n```\n\n**Resource usage**:\n- **SKILL.md**: Overview and when to use resources\n- **references/**: Detailed guides (loaded as needed)\n- **examples/**: Copy-paste code samples\n- **scripts/**: Executable test runners\n- **assets/**: Templates and configurations\n\n## Hook Organization Patterns\n\n### Monolithic Configuration\n\nSingle hooks.json with all hooks:\n\n```\nhooks/\nâ”œâ”€â”€ hooks.json     # All hook definitions\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate-write.sh\n    â”œâ”€â”€ validate-bash.sh\n    â””â”€â”€ load-context.sh\n```\n\n**hooks.json**:\n```json\n{\n  \"PreToolUse\": [...],\n  \"PostToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**When to use**:\n- 5-10 hooks total\n- Simple hook logic\n- Centralized configuration\n\n### Event-Based Organization\n\nSeparate files per event type:\n\n```\nhooks/\nâ”œâ”€â”€ hooks.json              # Combines all\nâ”œâ”€â”€ pre-tool-use.json      # PreToolUse hooks\nâ”œâ”€â”€ post-tool-use.json     # PostToolUse hooks\nâ”œâ”€â”€ stop.json              # Stop hooks\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate/\n    â”‚   â”œâ”€â”€ write.sh\n    â”‚   â””â”€â”€ bash.sh\n    â””â”€â”€ context/\n        â””â”€â”€ load.sh\n```\n\n**hooks.json** (combines):\n```json\n{\n  \"PreToolUse\": ${file:./pre-tool-use.json},\n  \"PostToolUse\": ${file:./post-tool-use.json},\n  \"Stop\": ${file:./stop.json}\n}\n```\n\n**Note**: Use build script to combine files, Claude Code doesn't support file references.\n\n**When to use**:\n- 10+ hooks\n- Different teams managing different events\n- Complex hook configurations\n\n### Purpose-Based Organization\n\nGroup by functional purpose:\n\n```\nhooks/\nâ”œâ”€â”€ hooks.json\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ security/\n    â”‚   â”œâ”€â”€ validate-paths.sh\n    â”‚   â”œâ”€â”€ check-credentials.sh\n    â”‚   â””â”€â”€ scan-malware.sh\n    â”œâ”€â”€ quality/\n    â”‚   â”œâ”€â”€ lint-code.sh\n    â”‚   â”œâ”€â”€ check-tests.sh\n    â”‚   â””â”€â”€ verify-docs.sh\n    â””â”€â”€ workflow/\n        â”œâ”€â”€ notify-team.sh\n        â””â”€â”€ update-status.sh\n```\n\n**When to use**:\n- Many hook scripts\n- Clear functional boundaries\n- Team specialization\n\n## Script Organization Patterns\n\n### Flat Scripts\n\nAll scripts in single directory:\n\n```\nscripts/\nâ”œâ”€â”€ build.sh\nâ”œâ”€â”€ test.py\nâ”œâ”€â”€ deploy.sh\nâ”œâ”€â”€ validate.js\nâ””â”€â”€ report.py\n```\n\n**When to use**:\n- 5-10 scripts\n- All scripts related\n- Simple plugin\n\n### Categorized Scripts\n\nGroup by purpose:\n\n```\nscripts/\nâ”œâ”€â”€ build/\nâ”‚   â”œâ”€â”€ compile.sh\nâ”‚   â””â”€â”€ package.sh\nâ”œâ”€â”€ test/\nâ”‚   â”œâ”€â”€ run-unit.sh\nâ”‚   â””â”€â”€ run-integration.sh\nâ”œâ”€â”€ deploy/\nâ”‚   â”œâ”€â”€ staging.sh\nâ”‚   â””â”€â”€ production.sh\nâ””â”€â”€ utils/\n    â”œâ”€â”€ log.sh\n    â””â”€â”€ notify.sh\n```\n\n**When to use**:\n- 10+ scripts\n- Clear categories\n- Reusable utilities\n\n### Language-Based Organization\n\nGroup by programming language:\n\n```\nscripts/\nâ”œâ”€â”€ bash/\nâ”‚   â”œâ”€â”€ build.sh\nâ”‚   â””â”€â”€ deploy.sh\nâ”œâ”€â”€ python/\nâ”‚   â”œâ”€â”€ analyze.py\nâ”‚   â””â”€â”€ report.py\nâ””â”€â”€ javascript/\n    â”œâ”€â”€ bundle.js\n    â””â”€â”€ optimize.js\n```\n\n**When to use**:\n- Multi-language scripts\n- Different runtime requirements\n- Language-specific dependencies\n\n## Cross-Component Patterns\n\n### Shared Resources\n\nComponents sharing common resources:\n\n```\nplugin/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ test.md        # Uses lib/test-utils.sh\nâ”‚   â””â”€â”€ deploy.md      # Uses lib/deploy-utils.sh\nâ”œâ”€â”€ agents/\nâ”‚   â””â”€â”€ tester.md      # References lib/test-utils.sh\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ scripts/\nâ”‚       â””â”€â”€ pre-test.sh # Sources lib/test-utils.sh\nâ””â”€â”€ lib/\n    â”œâ”€â”€ test-utils.sh\n    â””â”€â”€ deploy-utils.sh\n```\n\n**Usage in components**:\n```bash\n#!/bin/bash\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/test-utils.sh\"\nrun_tests\n```\n\n**Benefits**:\n- Code reuse\n- Consistent behavior\n- Easier maintenance\n\n### Layered Architecture\n\nSeparate concerns into layers:\n\n```\nplugin/\nâ”œâ”€â”€ commands/          # User interface layer\nâ”œâ”€â”€ agents/            # Orchestration layer\nâ”œâ”€â”€ skills/            # Knowledge layer\nâ””â”€â”€ lib/\n    â”œâ”€â”€ core/         # Core business logic\n    â”œâ”€â”€ integrations/ # External services\n    â””â”€â”€ utils/        # Helper functions\n```\n\n**When to use**:\n- Large plugins (100+ files)\n- Multiple developers\n- Clear separation of concerns\n\n### Plugin Within Plugin\n\nNested plugin structure:\n\n```\nplugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ core/              # Core functionality\nâ”‚   â”œâ”€â”€ commands/\nâ”‚   â””â”€â”€ agents/\nâ””â”€â”€ extensions/        # Optional extensions\n    â”œâ”€â”€ extension-a/\n    â”‚   â”œâ”€â”€ commands/\n    â”‚   â””â”€â”€ agents/\n    â””â”€â”€ extension-b/\n        â”œâ”€â”€ commands/\n        â””â”€â”€ agents/\n```\n\n**Manifest**:\n```json\n{\n  \"commands\": [\n    \"./core/commands\",\n    \"./extensions/extension-a/commands\",\n    \"./extensions/extension-b/commands\"\n  ]\n}\n```\n\n**When to use**:\n- Modular functionality\n- Optional features\n- Plugin families\n\n## Best Practices\n\n### Naming\n\n1. **Consistent naming**: Match file names to component purpose\n2. **Descriptive names**: Indicate what component does\n3. **Avoid abbreviations**: Use full words for clarity\n\n### Organization\n\n1. **Start simple**: Use flat structure, reorganize when needed\n2. **Group related items**: Keep related components together\n3. **Separate concerns**: Don't mix unrelated functionality\n\n### Scalability\n\n1. **Plan for growth**: Choose structure that scales\n2. **Refactor early**: Reorganize before it becomes painful\n3. **Document structure**: Explain organization in README\n\n### Maintainability\n\n1. **Consistent patterns**: Use same structure throughout\n2. **Minimize nesting**: Keep directory depth manageable\n3. **Use conventions**: Follow community standards\n\n### Performance\n\n1. **Avoid deep nesting**: Impacts discovery time\n2. **Minimize custom paths**: Use defaults when possible\n3. **Keep configurations small**: Large configs slow loading\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-structure/references/manifest-reference.md","content":"# Plugin Manifest Reference\n\nComplete reference for `plugin.json` configuration.\n\n## File Location\n\n**Required path**: `.claude-plugin/plugin.json`\n\nThe manifest MUST be in the `.claude-plugin/` directory at the plugin root. Claude Code will not recognize plugins without this file in the correct location.\n\n## Complete Field Reference\n\n### Core Fields\n\n#### name (required)\n\n**Type**: String\n**Format**: kebab-case\n**Example**: `\"test-automation-suite\"`\n\nThe unique identifier for the plugin. Used for:\n- Plugin identification in Claude Code\n- Conflict detection with other plugins\n- Command namespacing (optional)\n\n**Requirements**:\n- Must be unique across all installed plugins\n- Use only lowercase letters, numbers, and hyphens\n- No spaces or special characters\n- Start with a letter\n- End with a letter or number\n\n**Validation**:\n```javascript\n/^[a-z][a-z0-9]*(-[a-z0-9]+)*$/\n```\n\n**Examples**:\n- âœ… Good: `api-tester`, `code-review`, `git-workflow-automation`\n- âŒ Bad: `API Tester`, `code_review`, `-git-workflow`, `test-`\n\n#### version\n\n**Type**: String\n**Format**: Semantic versioning (MAJOR.MINOR.PATCH)\n**Example**: `\"2.1.0\"`\n**Default**: `\"0.1.0\"` if not specified\n\nSemantic versioning guidelines:\n- **MAJOR**: Incompatible API changes, breaking changes\n- **MINOR**: New functionality, backward-compatible\n- **PATCH**: Bug fixes, backward-compatible\n\n**Pre-release versions**:\n- `\"1.0.0-alpha.1\"` - Alpha release\n- `\"1.0.0-beta.2\"` - Beta release\n- `\"1.0.0-rc.1\"` - Release candidate\n\n**Examples**:\n- `\"0.1.0\"` - Initial development\n- `\"1.0.0\"` - First stable release\n- `\"1.2.3\"` - Patch update to 1.2\n- `\"2.0.0\"` - Major version with breaking changes\n\n#### description\n\n**Type**: String\n**Length**: 50-200 characters recommended\n**Example**: `\"Automates code review workflows with style checks and automated feedback\"`\n\nBrief explanation of plugin purpose and functionality.\n\n**Best practices**:\n- Focus on what the plugin does, not how\n- Use active voice\n- Mention key features or benefits\n- Keep under 200 characters for marketplace display\n\n**Examples**:\n- âœ… \"Generates comprehensive test suites from code analysis and coverage reports\"\n- âœ… \"Integrates with Jira for automatic issue tracking and sprint management\"\n- âŒ \"A plugin that helps you do testing stuff\"\n- âŒ \"This is a very long description that goes on and on about every single feature...\"\n\n### Metadata Fields\n\n#### author\n\n**Type**: Object\n**Fields**: name (required), email (optional), url (optional)\n\n```json\n{\n  \"author\": {\n    \"name\": \"Jane Developer\",\n    \"email\": \"jane@example.com\",\n    \"url\": \"https://janedeveloper.com\"\n  }\n}\n```\n\n**Alternative format** (string only):\n```json\n{\n  \"author\": \"Jane Developer <jane@example.com> (https://janedeveloper.com)\"\n}\n```\n\n**Use cases**:\n- Credit and attribution\n- Contact for support or questions\n- Marketplace display\n- Community recognition\n\n#### homepage\n\n**Type**: String (URL)\n**Example**: `\"https://docs.example.com/plugins/my-plugin\"`\n\nLink to plugin documentation or landing page.\n\n**Should point to**:\n- Plugin documentation site\n- Project homepage\n- Detailed usage guide\n- Installation instructions\n\n**Not for**:\n- Source code (use `repository` field)\n- Issue tracker (include in documentation)\n- Personal websites (use `author.url`)\n\n#### repository\n\n**Type**: String (URL) or Object\n**Example**: `\"https://github.com/user/plugin-name\"`\n\nSource code repository location.\n\n**String format**:\n```json\n{\n  \"repository\": \"https://github.com/user/plugin-name\"\n}\n```\n\n**Object format** (detailed):\n```json\n{\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/user/plugin-name.git\",\n    \"directory\": \"packages/plugin-name\"\n  }\n}\n```\n\n**Use cases**:\n- Source code access\n- Issue reporting\n- Community contributions\n- Transparency and trust\n\n#### license\n\n**Type**: String\n**Format**: SPDX identifier\n**Example**: `\"MIT\"`\n\nSoftware license identifier.\n\n**Common licenses**:\n- `\"MIT\"` - Permissive, popular choice\n- `\"Apache-2.0\"` - Permissive with patent grant\n- `\"GPL-3.0\"` - Copyleft\n- `\"BSD-3-Clause\"` - Permissive\n- `\"ISC\"` - Permissive, similar to MIT\n- `\"UNLICENSED\"` - Proprietary, not open source\n\n**Full list**: https://spdx.org/licenses/\n\n**Multiple licenses**:\n```json\n{\n  \"license\": \"(MIT OR Apache-2.0)\"\n}\n```\n\n#### keywords\n\n**Type**: Array of strings\n**Example**: `[\"testing\", \"automation\", \"ci-cd\", \"quality-assurance\"]`\n\nTags for plugin discovery and categorization.\n\n**Best practices**:\n- Use 5-10 keywords\n- Include functionality categories\n- Add technology names\n- Use common search terms\n- Avoid duplicating plugin name\n\n**Categories to consider**:\n- Functionality: `testing`, `debugging`, `documentation`, `deployment`\n- Technologies: `typescript`, `python`, `docker`, `aws`\n- Workflows: `ci-cd`, `code-review`, `git-workflow`\n- Domains: `web-development`, `data-science`, `devops`\n\n### Component Path Fields\n\n#### commands\n\n**Type**: String or Array of strings\n**Default**: `[\"./commands\"]`\n**Example**: `\"./cli-commands\"`\n\nAdditional directories or files containing command definitions.\n\n**Single path**:\n```json\n{\n  \"commands\": \"./custom-commands\"\n}\n```\n\n**Multiple paths**:\n```json\n{\n  \"commands\": [\n    \"./commands\",\n    \"./admin-commands\",\n    \"./experimental-commands\"\n  ]\n}\n```\n\n**Behavior**: Supplements default `commands/` directory (does not replace)\n\n**Use cases**:\n- Organizing commands by category\n- Separating stable from experimental commands\n- Loading commands from shared locations\n\n#### agents\n\n**Type**: String or Array of strings\n**Default**: `[\"./agents\"]`\n**Example**: `\"./specialized-agents\"`\n\nAdditional directories or files containing agent definitions.\n\n**Format**: Same as `commands` field\n\n**Use cases**:\n- Grouping agents by specialization\n- Separating general-purpose from task-specific agents\n- Loading agents from plugin dependencies\n\n#### hooks\n\n**Type**: String (path to JSON file) or Object (inline configuration)\n**Default**: `\"./hooks/hooks.json\"`\n\nHook configuration location or inline definition.\n\n**File path**:\n```json\n{\n  \"hooks\": \"./config/hooks.json\"\n}\n```\n\n**Inline configuration**:\n```json\n{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n**Use cases**:\n- Simple plugins: Inline configuration (< 50 lines)\n- Complex plugins: External JSON file\n- Multiple hook sets: Separate files for different contexts\n\n#### mcpServers\n\n**Type**: String (path to JSON file) or Object (inline configuration)\n**Default**: `./.mcp.json`\n\nMCP server configuration location or inline definition.\n\n**File path**:\n```json\n{\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Inline configuration**:\n```json\n{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/github-mcp.js\"],\n      \"env\": {\n        \"GITHUB_TOKEN\": \"${GITHUB_TOKEN}\"\n      }\n    }\n  }\n}\n```\n\n**Use cases**:\n- Simple plugins: Single inline server (< 20 lines)\n- Complex plugins: External `.mcp.json` file\n- Multiple servers: Always use external file\n\n## Path Resolution\n\n### Relative Path Rules\n\nAll paths in component fields must follow these rules:\n\n1. **Must be relative**: No absolute paths\n2. **Must start with `./`**: Indicates relative to plugin root\n3. **Cannot use `../`**: No parent directory navigation\n4. **Forward slashes only**: Even on Windows\n\n**Examples**:\n- âœ… `\"./commands\"`\n- âœ… `\"./src/commands\"`\n- âœ… `\"./configs/hooks.json\"`\n- âŒ `\"/Users/name/plugin/commands\"`\n- âŒ `\"commands\"` (missing `./`)\n- âŒ `\"../shared/commands\"`\n- âŒ `\".\\\\commands\"` (backslash)\n\n### Resolution Order\n\nWhen Claude Code loads components:\n\n1. **Default directories**: Scans standard locations first\n   - `./commands/`\n   - `./agents/`\n   - `./skills/`\n   - `./hooks/hooks.json`\n   - `./.mcp.json`\n\n2. **Custom paths**: Scans paths specified in manifest\n   - Paths from `commands` field\n   - Paths from `agents` field\n   - Files from `hooks` and `mcpServers` fields\n\n3. **Merge behavior**: Components from all locations load\n   - No overwriting\n   - All discovered components register\n   - Name conflicts cause errors\n\n## Validation\n\n### Manifest Validation\n\nClaude Code validates the manifest on plugin load:\n\n**Syntax validation**:\n- Valid JSON format\n- No syntax errors\n- Correct field types\n\n**Field validation**:\n- `name` field present and valid format\n- `version` follows semantic versioning (if present)\n- Paths are relative with `./` prefix\n- URLs are valid (if present)\n\n**Component validation**:\n- Referenced paths exist\n- Hook and MCP configurations are valid\n- No circular dependencies\n\n### Common Validation Errors\n\n**Invalid name format**:\n```json\n{\n  \"name\": \"My Plugin\"  // âŒ Contains spaces\n}\n```\nFix: Use kebab-case\n```json\n{\n  \"name\": \"my-plugin\"  // âœ…\n}\n```\n\n**Absolute path**:\n```json\n{\n  \"commands\": \"/Users/name/commands\"  // âŒ Absolute path\n}\n```\nFix: Use relative path\n```json\n{\n  \"commands\": \"./commands\"  // âœ…\n}\n```\n\n**Missing ./ prefix**:\n```json\n{\n  \"hooks\": \"hooks/hooks.json\"  // âŒ No ./\n}\n```\nFix: Add ./ prefix\n```json\n{\n  \"hooks\": \"./hooks/hooks.json\"  // âœ…\n}\n```\n\n**Invalid version**:\n```json\n{\n  \"version\": \"1.0\"  // âŒ Not semantic versioning\n}\n```\nFix: Use MAJOR.MINOR.PATCH\n```json\n{\n  \"version\": \"1.0.0\"  // âœ…\n}\n```\n\n## Minimal vs. Complete Examples\n\n### Minimal Plugin\n\nBare minimum for a working plugin:\n\n```json\n{\n  \"name\": \"hello-world\"\n}\n```\n\nRelies entirely on default directory discovery.\n\n### Recommended Plugin\n\nGood metadata for distribution:\n\n```json\n{\n  \"name\": \"code-review-assistant\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Automates code review with style checks and suggestions\",\n  \"author\": {\n    \"name\": \"Jane Developer\",\n    \"email\": \"jane@example.com\"\n  },\n  \"homepage\": \"https://docs.example.com/code-review\",\n  \"repository\": \"https://github.com/janedev/code-review-assistant\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"code-review\", \"automation\", \"quality\", \"ci-cd\"]\n}\n```\n\n### Complete Plugin\n\nFull configuration with all features:\n\n```json\n{\n  \"name\": \"enterprise-devops\",\n  \"version\": \"2.3.1\",\n  \"description\": \"Comprehensive DevOps automation for enterprise CI/CD pipelines\",\n  \"author\": {\n    \"name\": \"DevOps Team\",\n    \"email\": \"devops@company.com\",\n    \"url\": \"https://company.com/devops\"\n  },\n  \"homepage\": \"https://docs.company.com/plugins/devops\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/company/devops-plugin.git\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"keywords\": [\n    \"devops\",\n    \"ci-cd\",\n    \"automation\",\n    \"kubernetes\",\n    \"docker\",\n    \"deployment\"\n  ],\n  \"commands\": [\n    \"./commands\",\n    \"./admin-commands\"\n  ],\n  \"agents\": \"./specialized-agents\",\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n## Best Practices\n\n### Metadata\n\n1. **Always include version**: Track changes and updates\n2. **Write clear descriptions**: Help users understand plugin purpose\n3. **Provide contact information**: Enable user support\n4. **Link to documentation**: Reduce support burden\n5. **Choose appropriate license**: Match project goals\n\n### Paths\n\n1. **Use defaults when possible**: Minimize configuration\n2. **Organize logically**: Group related components\n3. **Document custom paths**: Explain why non-standard layout used\n4. **Test path resolution**: Verify on multiple systems\n\n### Maintenance\n\n1. **Bump version on changes**: Follow semantic versioning\n2. **Update keywords**: Reflect new functionality\n3. **Keep description current**: Match actual capabilities\n4. **Maintain changelog**: Track version history\n5. **Update repository links**: Keep URLs current\n\n### Distribution\n\n1. **Complete metadata before publishing**: All fields filled\n2. **Test on clean install**: Verify plugin works without dev environment\n3. **Validate manifest**: Use validation tools\n4. **Include README**: Document installation and usage\n5. **Specify license file**: Include LICENSE file in plugin root\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-structure/SKILL.md","content":"---\nname: Plugin Structure\ndescription: This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.\nversion: 0.1.0\n---\n\n# Plugin Structure for Claude Code\n\n## Overview\n\nClaude Code plugins follow a standardized directory structure with automatic component discovery. Understanding this structure enables creating well-organized, maintainable plugins that integrate seamlessly with Claude Code.\n\n**Key concepts:**\n- Conventional directory layout for automatic discovery\n- Manifest-driven configuration in `.claude-plugin/plugin.json`\n- Component-based organization (commands, agents, skills, hooks)\n- Portable path references using `${CLAUDE_PLUGIN_ROOT}`\n- Explicit vs. auto-discovered component loading\n\n## Directory Structure\n\nEvery Claude Code plugin follows this organizational pattern:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Required: Plugin manifest\nâ”œâ”€â”€ commands/                 # Slash commands (.md files)\nâ”œâ”€â”€ agents/                   # Subagent definitions (.md files)\nâ”œâ”€â”€ skills/                   # Agent skills (subdirectories)\nâ”‚   â””â”€â”€ skill-name/\nâ”‚       â””â”€â”€ SKILL.md         # Required for each skill\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json           # Event handler configuration\nâ”œâ”€â”€ .mcp.json                # MCP server definitions\nâ””â”€â”€ scripts/                 # Helper scripts and utilities\n```\n\n**Critical rules:**\n\n1. **Manifest location**: The `plugin.json` manifest MUST be in `.claude-plugin/` directory\n2. **Component locations**: All component directories (commands, agents, skills, hooks) MUST be at plugin root level, NOT nested inside `.claude-plugin/`\n3. **Optional components**: Only create directories for components the plugin actually uses\n4. **Naming convention**: Use kebab-case for all directory and file names\n\n## Plugin Manifest (plugin.json)\n\nThe manifest defines plugin metadata and configuration. Located at `.claude-plugin/plugin.json`:\n\n### Required Fields\n\n```json\n{\n  \"name\": \"plugin-name\"\n}\n```\n\n**Name requirements:**\n- Use kebab-case format (lowercase with hyphens)\n- Must be unique across installed plugins\n- No spaces or special characters\n- Example: `code-review-assistant`, `test-runner`, `api-docs`\n\n### Recommended Metadata\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Brief explanation of plugin purpose\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\",\n    \"url\": \"https://example.com\"\n  },\n  \"homepage\": \"https://docs.example.com\",\n  \"repository\": \"https://github.com/user/plugin-name\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"testing\", \"automation\", \"ci-cd\"]\n}\n```\n\n**Version format**: Follow semantic versioning (MAJOR.MINOR.PATCH)\n**Keywords**: Use for plugin discovery and categorization\n\n### Component Path Configuration\n\nSpecify custom paths for components (supplements default directories):\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"commands\": \"./custom-commands\",\n  \"agents\": [\"./agents\", \"./specialized-agents\"],\n  \"hooks\": \"./config/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n```\n\n**Important**: Custom paths supplement defaultsâ€”they don't replace them. Components in both default directories and custom paths will load.\n\n**Path rules:**\n- Must be relative to plugin root\n- Must start with `./`\n- Cannot use absolute paths\n- Support arrays for multiple locations\n\n## Component Organization\n\n### Commands\n\n**Location**: `commands/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `commands/` load automatically\n\n**Example structure**:\n```\ncommands/\nâ”œâ”€â”€ review.md        # /review command\nâ”œâ”€â”€ test.md          # /test command\nâ””â”€â”€ deploy.md        # /deploy command\n```\n\n**File format**:\n```markdown\n---\nname: command-name\ndescription: Command description\n---\n\nCommand implementation instructions...\n```\n\n**Usage**: Commands integrate as native slash commands in Claude Code\n\n### Agents\n\n**Location**: `agents/` directory\n**Format**: Markdown files with YAML frontmatter\n**Auto-discovery**: All `.md` files in `agents/` load automatically\n\n**Example structure**:\n```\nagents/\nâ”œâ”€â”€ code-reviewer.md\nâ”œâ”€â”€ test-generator.md\nâ””â”€â”€ refactorer.md\n```\n\n**File format**:\n```markdown\n---\ndescription: Agent role and expertise\ncapabilities:\n  - Specific task 1\n  - Specific task 2\n---\n\nDetailed agent instructions and knowledge...\n```\n\n**Usage**: Users can invoke agents manually, or Claude Code selects them automatically based on task context\n\n### Skills\n\n**Location**: `skills/` directory with subdirectories per skill\n**Format**: Each skill in its own directory with `SKILL.md` file\n**Auto-discovery**: All `SKILL.md` files in skill subdirectories load automatically\n\n**Example structure**:\n```\nskills/\nâ”œâ”€â”€ api-testing/\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ scripts/\nâ”‚   â”‚   â””â”€â”€ test-runner.py\nâ”‚   â””â”€â”€ references/\nâ”‚       â””â”€â”€ api-spec.md\nâ””â”€â”€ database-migrations/\n    â”œâ”€â”€ SKILL.md\n    â””â”€â”€ examples/\n        â””â”€â”€ migration-template.sql\n```\n\n**SKILL.md format**:\n```markdown\n---\nname: Skill Name\ndescription: When to use this skill\nversion: 1.0.0\n---\n\nSkill instructions and guidance...\n```\n\n**Supporting files**: Skills can include scripts, references, examples, or assets in subdirectories\n\n**Usage**: Claude Code autonomously activates skills based on task context matching the description\n\n### Hooks\n\n**Location**: `hooks/hooks.json` or inline in `plugin.json`\n**Format**: JSON configuration defining event handlers\n**Registration**: Hooks register automatically when plugin enables\n\n**Example structure**:\n```\nhooks/\nâ”œâ”€â”€ hooks.json           # Hook configuration\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate.sh      # Hook script\n    â””â”€â”€ check-style.sh   # Hook script\n```\n\n**Configuration format**:\n```json\n{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh\",\n      \"timeout\": 30\n    }]\n  }]\n}\n```\n\n**Available events**: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n\n**Usage**: Hooks execute automatically in response to Claude Code events\n\n### MCP Servers\n\n**Location**: `.mcp.json` at plugin root or inline in `plugin.json`\n**Format**: JSON configuration for MCP server definitions\n**Auto-start**: Servers start automatically when plugin enables\n\n**Example format**:\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n**Usage**: MCP servers integrate seamlessly with Claude Code's tool system\n\n## Portable Path References\n\n### ${CLAUDE_PLUGIN_ROOT}\n\nUse `${CLAUDE_PLUGIN_ROOT}` environment variable for all intra-plugin path references:\n\n```json\n{\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/run.sh\"\n}\n```\n\n**Why it matters**: Plugins install in different locations depending on:\n- User installation method (marketplace, local, npm)\n- Operating system conventions\n- User preferences\n\n**Where to use it**:\n- Hook command paths\n- MCP server command arguments\n- Script execution references\n- Resource file paths\n\n**Never use**:\n- Hardcoded absolute paths (`/Users/name/plugins/...`)\n- Relative paths from working directory (`./scripts/...` in commands)\n- Home directory shortcuts (`~/plugins/...`)\n\n### Path Resolution Rules\n\n**In manifest JSON fields** (hooks, MCP servers):\n```json\n\"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tool.sh\"\n```\n\n**In component files** (commands, agents, skills):\n```markdown\nReference scripts at: ${CLAUDE_PLUGIN_ROOT}/scripts/helper.py\n```\n\n**In executed scripts**:\n```bash\n#!/bin/bash\n# ${CLAUDE_PLUGIN_ROOT} available as environment variable\nsource \"${CLAUDE_PLUGIN_ROOT}/lib/common.sh\"\n```\n\n## File Naming Conventions\n\n### Component Files\n\n**Commands**: Use kebab-case `.md` files\n- `code-review.md` â†’ `/code-review`\n- `run-tests.md` â†’ `/run-tests`\n- `api-docs.md` â†’ `/api-docs`\n\n**Agents**: Use kebab-case `.md` files describing role\n- `test-generator.md`\n- `code-reviewer.md`\n- `performance-analyzer.md`\n\n**Skills**: Use kebab-case directory names\n- `api-testing/`\n- `database-migrations/`\n- `error-handling/`\n\n### Supporting Files\n\n**Scripts**: Use descriptive kebab-case names with appropriate extensions\n- `validate-input.sh`\n- `generate-report.py`\n- `process-data.js`\n\n**Documentation**: Use kebab-case markdown files\n- `api-reference.md`\n- `migration-guide.md`\n- `best-practices.md`\n\n**Configuration**: Use standard names\n- `hooks.json`\n- `.mcp.json`\n- `plugin.json`\n\n## Auto-Discovery Mechanism\n\nClaude Code automatically discovers and loads components:\n\n1. **Plugin manifest**: Reads `.claude-plugin/plugin.json` when plugin enables\n2. **Commands**: Scans `commands/` directory for `.md` files\n3. **Agents**: Scans `agents/` directory for `.md` files\n4. **Skills**: Scans `skills/` for subdirectories containing `SKILL.md`\n5. **Hooks**: Loads configuration from `hooks/hooks.json` or manifest\n6. **MCP servers**: Loads configuration from `.mcp.json` or manifest\n\n**Discovery timing**:\n- Plugin installation: Components register with Claude Code\n- Plugin enable: Components become available for use\n- No restart required: Changes take effect on next Claude Code session\n\n**Override behavior**: Custom paths in `plugin.json` supplement (not replace) default directories\n\n## Best Practices\n\n### Organization\n\n1. **Logical grouping**: Group related components together\n   - Put test-related commands, agents, and skills together\n   - Create subdirectories in `scripts/` for different purposes\n\n2. **Minimal manifest**: Keep `plugin.json` lean\n   - Only specify custom paths when necessary\n   - Rely on auto-discovery for standard layouts\n   - Use inline configuration only for simple cases\n\n3. **Documentation**: Include README files\n   - Plugin root: Overall purpose and usage\n   - Component directories: Specific guidance\n   - Script directories: Usage and requirements\n\n### Naming\n\n1. **Consistency**: Use consistent naming across components\n   - If command is `test-runner`, name related agent `test-runner-agent`\n   - Match skill directory names to their purpose\n\n2. **Clarity**: Use descriptive names that indicate purpose\n   - Good: `api-integration-testing/`, `code-quality-checker.md`\n   - Avoid: `utils/`, `misc.md`, `temp.sh`\n\n3. **Length**: Balance brevity with clarity\n   - Commands: 2-3 words (`review-pr`, `run-ci`)\n   - Agents: Describe role clearly (`code-reviewer`, `test-generator`)\n   - Skills: Topic-focused (`error-handling`, `api-design`)\n\n### Portability\n\n1. **Always use ${CLAUDE_PLUGIN_ROOT}**: Never hardcode paths\n2. **Test on multiple systems**: Verify on macOS, Linux, Windows\n3. **Document dependencies**: List required tools and versions\n4. **Avoid system-specific features**: Use portable bash/Python constructs\n\n### Maintenance\n\n1. **Version consistently**: Update version in plugin.json for releases\n2. **Deprecate gracefully**: Mark old components clearly before removal\n3. **Document breaking changes**: Note changes affecting existing users\n4. **Test thoroughly**: Verify all components work after changes\n\n## Common Patterns\n\n### Minimal Plugin\n\nSingle command with no dependencies:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json    # Just name field\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md       # Single command\n```\n\n### Full-Featured Plugin\n\nComplete plugin with all component types:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/          # User-facing commands\nâ”œâ”€â”€ agents/            # Specialized subagents\nâ”œâ”€â”€ skills/            # Auto-activating skills\nâ”œâ”€â”€ hooks/             # Event handlers\nâ”‚   â”œâ”€â”€ hooks.json\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ .mcp.json          # External integrations\nâ””â”€â”€ scripts/           # Shared utilities\n```\n\n### Skill-Focused Plugin\n\nPlugin providing only skills:\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ””â”€â”€ skills/\n    â”œâ”€â”€ skill-one/\n    â”‚   â””â”€â”€ SKILL.md\n    â””â”€â”€ skill-two/\n        â””â”€â”€ SKILL.md\n```\n\n## Troubleshooting\n\n**Component not loading**:\n- Verify file is in correct directory with correct extension\n- Check YAML frontmatter syntax (commands, agents, skills)\n- Ensure skill has `SKILL.md` (not `README.md` or other name)\n- Confirm plugin is enabled in Claude Code settings\n\n**Path resolution errors**:\n- Replace all hardcoded paths with `${CLAUDE_PLUGIN_ROOT}`\n- Verify paths are relative and start with `./` in manifest\n- Check that referenced files exist at specified paths\n- Test with `echo $CLAUDE_PLUGIN_ROOT` in hook scripts\n\n**Auto-discovery not working**:\n- Confirm directories are at plugin root (not in `.claude-plugin/`)\n- Check file naming follows conventions (kebab-case, correct extensions)\n- Verify custom paths in manifest are correct\n- Restart Claude Code to reload plugin configuration\n\n**Conflicts between plugins**:\n- Use unique, descriptive component names\n- Namespace commands with plugin name if needed\n- Document potential conflicts in plugin README\n- Consider command prefixes for related functionality\n\n---\n\nFor detailed examples and advanced patterns, see files in `references/` and `examples/` directories.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-settings/examples/example-settings.md","content":"# Example Plugin Settings File\n\n## Template: Basic Configuration\n\n**.claude/my-plugin.local.md:**\n\n```markdown\n---\nenabled: true\nmode: standard\n---\n\n# My Plugin Configuration\n\nPlugin is active in standard mode.\n```\n\n## Template: Advanced Configuration\n\n**.claude/my-plugin.local.md:**\n\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\nnotification_level: info\nretry_attempts: 3\ntimeout_seconds: 60\ncustom_path: \"/path/to/data\"\n---\n\n# My Plugin Advanced Configuration\n\nThis project uses custom plugin configuration with:\n- Standard validation mode\n- 1MB file size limit\n- JavaScript/TypeScript files allowed\n- Info-level logging\n- 3 retry attempts\n\n## Additional Notes\n\nContact @team-lead with questions about this configuration.\n```\n\n## Template: Agent State File\n\n**.claude/multi-agent-swarm.local.md:**\n\n```markdown\n---\nagent_name: database-implementation\ntask_number: 4.2\npr_number: 5678\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.5\", \"Task 4.1\"]\nadditional_instructions: \"Use PostgreSQL, not MySQL\"\n---\n\n# Task Assignment: Database Schema Implementation\n\nImplement the database schema for the new features module.\n\n## Requirements\n\n- Create migration files\n- Add indexes for performance\n- Write tests for constraints\n- Document schema in README\n\n## Success Criteria\n\n- Migrations run successfully\n- All tests pass\n- PR created with CI green\n- Schema documented\n\n## Coordination\n\nDepends on:\n- Task 3.5: API endpoint definitions\n- Task 4.1: Data model design\n\nReport status to coordinator session 'team-leader'.\n```\n\n## Template: Feature Flag Pattern\n\n**.claude/experimental-features.local.md:**\n\n```markdown\n---\nenabled: true\nfeatures:\n  - ai_suggestions\n  - auto_formatting\n  - advanced_refactoring\nexperimental_mode: false\n---\n\n# Experimental Features Configuration\n\nCurrent enabled features:\n- AI-powered code suggestions\n- Automatic code formatting\n- Advanced refactoring tools\n\nExperimental mode is OFF (stable features only).\n```\n\n## Usage in Hooks\n\nThese templates can be read by hooks:\n\n```bash\n# Check if plugin is configured\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured, skip hook\nfi\n\n# Read settings\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \".claude/my-plugin.local.md\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\n# Apply settings\nif [[ \"$ENABLED\" == \"true\" ]]; then\n  # Hook is active\n  # ...\nfi\n```\n\n## Gitignore\n\nAlways add to project `.gitignore`:\n\n```gitignore\n# Plugin settings (user-local, not committed)\n.claude/*.local.md\n.claude/*.local.json\n```\n\n## Editing Settings\n\nUsers can edit settings files manually:\n\n```bash\n# Edit settings\nvim .claude/my-plugin.local.md\n\n# Changes take effect after restart\nexit  # Exit Claude Code\nclaude  # Restart\n```\n\nChanges require Claude Code restart - hooks can't be hot-swapped.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-settings/examples/create-settings-command.md","content":"---\ndescription: \"Create plugin settings file with user preferences\"\nallowed-tools: [\"Write\", \"AskUserQuestion\"]\n---\n\n# Create Plugin Settings\n\nThis command helps users create a `.claude/my-plugin.local.md` settings file.\n\n## Steps\n\n### Step 1: Ask User for Preferences\n\nUse AskUserQuestion to gather configuration:\n\n```json\n{\n  \"questions\": [\n    {\n      \"question\": \"Enable plugin for this project?\",\n      \"header\": \"Enable Plugin\",\n      \"multiSelect\": false,\n      \"options\": [\n        {\n          \"label\": \"Yes\",\n          \"description\": \"Plugin will be active\"\n        },\n        {\n          \"label\": \"No\",\n          \"description\": \"Plugin will be disabled\"\n        }\n      ]\n    },\n    {\n      \"question\": \"Validation mode?\",\n      \"header\": \"Mode\",\n      \"multiSelect\": false,\n      \"options\": [\n        {\n          \"label\": \"Strict\",\n          \"description\": \"Maximum validation and security checks\"\n        },\n        {\n          \"label\": \"Standard\",\n          \"description\": \"Balanced validation (recommended)\"\n        },\n        {\n          \"label\": \"Lenient\",\n          \"description\": \"Minimal validation only\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### Step 2: Parse Answers\n\nExtract answers from AskUserQuestion result:\n\n- answers[\"0\"]: enabled (Yes/No)\n- answers[\"1\"]: mode (Strict/Standard/Lenient)\n\n### Step 3: Create Settings File\n\nUse Write tool to create `.claude/my-plugin.local.md`:\n\n```markdown\n---\nenabled: <true if Yes, false if No>\nvalidation_mode: <strict, standard, or lenient>\nmax_file_size: 1000000\nnotify_on_errors: true\n---\n\n# Plugin Configuration\n\nYour plugin is configured with <mode> validation mode.\n\nTo modify settings, edit this file and restart Claude Code.\n```\n\n### Step 4: Inform User\n\nTell the user:\n- Settings file created at `.claude/my-plugin.local.md`\n- Current configuration summary\n- How to edit manually if needed\n- Reminder: Restart Claude Code for changes to take effect\n- Settings file is gitignored (won't be committed)\n\n## Implementation Notes\n\nAlways validate user input before writing:\n- Check mode is valid\n- Validate numeric fields are numbers\n- Ensure paths don't have traversal attempts\n- Sanitize any free-text fields\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-settings/references/real-world-examples.md","content":"# Real-World Plugin Settings Examples\n\nDetailed analysis of how production plugins use the `.claude/plugin-name.local.md` pattern.\n\n## multi-agent-swarm Plugin\n\n### Settings File Structure\n\n**.claude/multi-agent-swarm.local.md:**\n\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: \"Use JWT tokens, not sessions\"\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\n\n## Requirements\n- JWT token generation and validation\n- Refresh token flow\n- Secure password hashing\n\n## Success Criteria\n- Auth endpoints implemented\n- Tests passing (100% coverage)\n- PR created and CI green\n- Documentation updated\n\n## Coordination\nDepends on Task 3.4 (user model).\nReport status to 'team-leader' session.\n```\n\n### How It's Used\n\n**File:** `hooks/agent-stop-notification.sh`\n\n**Purpose:** Send notifications to coordinator when agent becomes idle\n\n**Implementation:**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\nSWARM_STATE_FILE=\".claude/multi-agent-swarm.local.md\"\n\n# Quick exit if no swarm active\nif [[ ! -f \"$SWARM_STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Parse frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$SWARM_STATE_FILE\")\n\n# Extract configuration\nCOORDINATOR_SESSION=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nTASK_NUMBER=$(echo \"$FRONTMATTER\" | grep '^task_number:' | sed 's/task_number: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nPR_NUMBER=$(echo \"$FRONTMATTER\" | grep '^pr_number:' | sed 's/pr_number: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0\nfi\n\n# Send notification to coordinator\nNOTIFICATION=\"ðŸ¤– Agent ${AGENT_NAME} (Task ${TASK_NUMBER}, PR #${PR_NUMBER}) is idle.\"\n\nif tmux has-session -t \"$COORDINATOR_SESSION\" 2>/dev/null; then\n  tmux send-keys -t \"$COORDINATOR_SESSION\" \"$NOTIFICATION\" Enter\n  sleep 0.5\n  tmux send-keys -t \"$COORDINATOR_SESSION\" Enter\nfi\n\nexit 0\n```\n\n**Key patterns:**\n1. **Quick exit** (line 7-9): Returns immediately if file doesn't exist\n2. **Field extraction** (lines 11-17): Parses each frontmatter field\n3. **Enabled check** (lines 19-21): Respects enabled flag\n4. **Action based on settings** (lines 23-29): Uses coordinator_session to send notification\n\n### Creation\n\n**File:** `commands/launch-swarm.md`\n\nSettings files are created during swarm launch with:\n\n```bash\ncat > \"$WORKTREE_PATH/.claude/multi-agent-swarm.local.md\" <<EOF\n---\nagent_name: $AGENT_NAME\ntask_number: $TASK_ID\npr_number: TBD\ncoordinator_session: $COORDINATOR_SESSION\nenabled: true\ndependencies: [$DEPENDENCIES]\nadditional_instructions: \"$EXTRA_INSTRUCTIONS\"\n---\n\n# Task: $TASK_DESCRIPTION\n\n$TASK_DETAILS\nEOF\n```\n\n### Updates\n\nPR number updated after PR creation:\n\n```bash\n# Update pr_number field\nsed \"s/^pr_number: .*/pr_number: $PR_NUM/\" \\\n  \".claude/multi-agent-swarm.local.md\" > temp.md\nmv temp.md \".claude/multi-agent-swarm.local.md\"\n```\n\n## ralph-wiggum Plugin\n\n### Settings File Structure\n\n**.claude/ralph-loop.local.md:**\n\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\nstarted_at: \"2025-01-15T14:30:00Z\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\nDocument any changes needed in CLAUDE.md.\n```\n\n### How It's Used\n\n**File:** `hooks/stop-hook.sh`\n\n**Purpose:** Prevent session exit and loop Claude's output back as input\n\n**Implementation:**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\nRALPH_STATE_FILE=\".claude/ralph-loop.local.md\"\n\n# Quick exit if no active loop\nif [[ ! -f \"$RALPH_STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Parse frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$RALPH_STATE_FILE\")\n\n# Extract configuration\nITERATION=$(echo \"$FRONTMATTER\" | grep '^iteration:' | sed 's/iteration: *//')\nMAX_ITERATIONS=$(echo \"$FRONTMATTER\" | grep '^max_iterations:' | sed 's/max_iterations: *//')\nCOMPLETION_PROMISE=$(echo \"$FRONTMATTER\" | grep '^completion_promise:' | sed 's/completion_promise: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check max iterations\nif [[ $MAX_ITERATIONS -gt 0 ]] && [[ $ITERATION -ge $MAX_ITERATIONS ]]; then\n  echo \"ðŸ›‘ Ralph loop: Max iterations ($MAX_ITERATIONS) reached.\"\n  rm \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Get transcript and check for completion promise\nTRANSCRIPT_PATH=$(echo \"$HOOK_INPUT\" | jq -r '.transcript_path')\nLAST_OUTPUT=$(grep '\"role\":\"assistant\"' \"$TRANSCRIPT_PATH\" | tail -1 | jq -r '.message.content | map(select(.type == \"text\")) | map(.text) | join(\"\\n\")')\n\n# Check for completion\nif [[ \"$COMPLETION_PROMISE\" != \"null\" ]] && [[ -n \"$COMPLETION_PROMISE\" ]]; then\n  PROMISE_TEXT=$(echo \"$LAST_OUTPUT\" | perl -0777 -pe 's/.*?<promise>(.*?)<\\/promise>.*/$1/s; s/^\\s+|\\s+$//g')\n\n  if [[ \"$PROMISE_TEXT\" = \"$COMPLETION_PROMISE\" ]]; then\n    echo \"âœ… Ralph loop: Detected completion\"\n    rm \"$RALPH_STATE_FILE\"\n    exit 0\n  fi\nfi\n\n# Continue loop - increment iteration\nNEXT_ITERATION=$((ITERATION + 1))\n\n# Extract prompt from markdown body\nPROMPT_TEXT=$(awk '/^---$/{i++; next} i>=2' \"$RALPH_STATE_FILE\")\n\n# Update iteration counter\nTEMP_FILE=\"${RALPH_STATE_FILE}.tmp.$$\"\nsed \"s/^iteration: .*/iteration: $NEXT_ITERATION/\" \"$RALPH_STATE_FILE\" > \"$TEMP_FILE\"\nmv \"$TEMP_FILE\" \"$RALPH_STATE_FILE\"\n\n# Block exit and feed prompt back\njq -n \\\n  --arg prompt \"$PROMPT_TEXT\" \\\n  --arg msg \"ðŸ”„ Ralph iteration $NEXT_ITERATION\" \\\n  '{\n    \"decision\": \"block\",\n    \"reason\": $prompt,\n    \"systemMessage\": $msg\n  }'\n\nexit 0\n```\n\n**Key patterns:**\n1. **Quick exit** (line 7-9): Skip if not active\n2. **Iteration tracking** (lines 11-20): Count and enforce max iterations\n3. **Promise detection** (lines 25-33): Check for completion signal in output\n4. **Prompt extraction** (line 38): Read markdown body as next prompt\n5. **State update** (lines 40-43): Increment iteration atomically\n6. **Loop continuation** (lines 45-53): Block exit and feed prompt back\n\n### Creation\n\n**File:** `scripts/setup-ralph-loop.sh`\n\n```bash\n#!/bin/bash\nPROMPT=\"$1\"\nMAX_ITERATIONS=\"${2:-0}\"\nCOMPLETION_PROMISE=\"${3:-}\"\n\n# Create state file\ncat > \".claude/ralph-loop.local.md\" <<EOF\n---\niteration: 1\nmax_iterations: $MAX_ITERATIONS\ncompletion_promise: \"$COMPLETION_PROMISE\"\nstarted_at: \"$(date -Iseconds)\"\n---\n\n$PROMPT\nEOF\n\necho \"Ralph loop initialized: .claude/ralph-loop.local.md\"\n```\n\n## Pattern Comparison\n\n| Feature | multi-agent-swarm | ralph-wiggum |\n|---------|-------------------|--------------|\n| **File** | `.claude/multi-agent-swarm.local.md` | `.claude/ralph-loop.local.md` |\n| **Purpose** | Agent coordination state | Loop iteration state |\n| **Frontmatter** | Agent metadata | Loop configuration |\n| **Body** | Task assignment | Prompt to loop |\n| **Updates** | PR number, status | Iteration counter |\n| **Deletion** | Manual or on completion | On loop exit |\n| **Hook** | Stop (notifications) | Stop (loop control) |\n\n## Best Practices from Real Plugins\n\n### 1. Quick Exit Pattern\n\nBoth plugins check file existence first:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Not active\nfi\n```\n\n**Why:** Avoids errors when plugin isn't configured and performs fast.\n\n### 2. Enabled Flag\n\nBoth use an `enabled` field for explicit control:\n\n```yaml\nenabled: true\n```\n\n**Why:** Allows temporary deactivation without deleting file.\n\n### 3. Atomic Updates\n\nBoth use temp file + atomic move:\n\n```bash\nTEMP_FILE=\"${FILE}.tmp.$$\"\nsed \"s/^field: .*/field: $NEW_VALUE/\" \"$FILE\" > \"$TEMP_FILE\"\nmv \"$TEMP_FILE\" \"$FILE\"\n```\n\n**Why:** Prevents corruption if process is interrupted.\n\n### 4. Quote Handling\n\nBoth strip surrounding quotes from YAML values:\n\n```bash\nsed 's/^\"\\(.*\\)\"$/\\1/'\n```\n\n**Why:** YAML allows both `field: value` and `field: \"value\"`.\n\n### 5. Error Handling\n\nBoth handle missing/corrupt files gracefully:\n\n```bash\nif [[ ! -f \"$FILE\" ]]; then\n  exit 0  # No error, just not configured\nfi\n\nif [[ -z \"$CRITICAL_FIELD\" ]]; then\n  echo \"Settings file corrupt\" >&2\n  rm \"$FILE\"  # Clean up\n  exit 0\nfi\n```\n\n**Why:** Fails gracefully instead of crashing.\n\n## Anti-Patterns to Avoid\n\n### âŒ Hardcoded Paths\n\n```bash\n# BAD\nFILE=\"/Users/alice/.claude/my-plugin.local.md\"\n\n# GOOD\nFILE=\".claude/my-plugin.local.md\"\n```\n\n### âŒ Unquoted Variables\n\n```bash\n# BAD\necho $VALUE\n\n# GOOD\necho \"$VALUE\"\n```\n\n### âŒ Non-Atomic Updates\n\n```bash\n# BAD: Can corrupt file if interrupted\nsed -i \"s/field: .*/field: $VALUE/\" \"$FILE\"\n\n# GOOD: Atomic\nTEMP_FILE=\"${FILE}.tmp.$$\"\nsed \"s/field: .*/field: $VALUE/\" \"$FILE\" > \"$TEMP_FILE\"\nmv \"$TEMP_FILE\" \"$FILE\"\n```\n\n### âŒ No Default Values\n\n```bash\n# BAD: Fails if field missing\nif [[ $MAX -gt 100 ]]; then\n  # MAX might be empty!\nfi\n\n# GOOD: Provide default\nMAX=${MAX:-10}\n```\n\n### âŒ Ignoring Edge Cases\n\n```bash\n# BAD: Assumes exactly 2 --- markers\nsed -n '/^---$/,/^---$/{ /^---$/d; p; }'\n\n# GOOD: Handles --- in body\nawk '/^---$/{i++; next} i>=2'  # For body\n```\n\n## Conclusion\n\nThe `.claude/plugin-name.local.md` pattern provides:\n- Simple, human-readable configuration\n- Version-control friendly (gitignored)\n- Per-project settings\n- Easy parsing with standard bash tools\n- Supports both structured config (YAML) and freeform content (markdown)\n\nUse this pattern for any plugin that needs user-configurable behavior or state persistence.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-settings/references/parsing-techniques.md","content":"# Settings File Parsing Techniques\n\nComplete guide to parsing `.claude/plugin-name.local.md` files in bash scripts.\n\n## File Structure\n\nSettings files use markdown with YAML frontmatter:\n\n```markdown\n---\nfield1: value1\nfield2: \"value with spaces\"\nnumeric_field: 42\nboolean_field: true\nlist_field: [\"item1\", \"item2\", \"item3\"]\n---\n\n# Markdown Content\n\nThis body content can be extracted separately.\nIt's useful for prompts, documentation, or additional context.\n```\n\n## Parsing Frontmatter\n\n### Extract Frontmatter Block\n\n```bash\n#!/bin/bash\nFILE=\".claude/my-plugin.local.md\"\n\n# Extract everything between --- markers (excluding the markers themselves)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n**How it works:**\n- `sed -n` - Suppress automatic printing\n- `/^---$/,/^---$/` - Range from first `---` to second `---`\n- `{ /^---$/d; p; }` - Delete the `---` lines, print everything else\n\n### Extract Individual Fields\n\n**String fields:**\n```bash\n# Simple value\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//')\n\n# Quoted value (removes surrounding quotes)\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\n# Use in condition\nif [[ \"$ENABLED\" == \"true\" ]]; then\n  # Enabled\nfi\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate it's a number\nif [[ \"$MAX\" =~ ^[0-9]+$ ]]; then\n  # Use in numeric comparison\n  if [[ $MAX -gt 100 ]]; then\n    # Too large\n  fi\nfi\n```\n\n**List fields (simple):**\n```bash\n# YAML: list: [\"item1\", \"item2\", \"item3\"]\nLIST=$(echo \"$FRONTMATTER\" | grep '^list:' | sed 's/list: *//')\n# Result: [\"item1\", \"item2\", \"item3\"]\n\n# For simple checks:\nif [[ \"$LIST\" == *\"item1\"* ]]; then\n  # List contains item1\nfi\n```\n\n**List fields (proper parsing with jq):**\n```bash\n# For proper list handling, use yq or convert to JSON\n# This requires yq to be installed (brew install yq)\n\n# Extract list as JSON array\nLIST=$(echo \"$FRONTMATTER\" | yq -o json '.list' 2>/dev/null)\n\n# Iterate over items\necho \"$LIST\" | jq -r '.[]' | while read -r item; do\n  echo \"Processing: $item\"\ndone\n```\n\n## Parsing Markdown Body\n\n### Extract Body Content\n\n```bash\n#!/bin/bash\nFILE=\".claude/my-plugin.local.md\"\n\n# Extract everything after the closing ---\n# Counts --- markers: first is opening, second is closing, everything after is body\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n**How it works:**\n- `/^---$/` - Match `---` lines\n- `{i++; next}` - Increment counter and skip the `---` line\n- `i>=2` - Print all lines after second `---`\n\n**Handles edge case:** If `---` appears in the markdown body, it still works because we only count the first two `---` at the start.\n\n### Use Body as Prompt\n\n```bash\n# Extract body\nPROMPT=$(awk '/^---$/{i++; next} i>=2' \"$RALPH_STATE_FILE\")\n\n# Feed back to Claude\necho '{\"decision\": \"block\", \"reason\": \"'\"$PROMPT\"'\"}' | jq .\n```\n\n**Important:** Use `jq -n --arg` for safer JSON construction with user content:\n\n```bash\nPROMPT=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n\n# Safe JSON construction\njq -n --arg prompt \"$PROMPT\" '{\n  \"decision\": \"block\",\n  \"reason\": $prompt\n}'\n```\n\n## Common Parsing Patterns\n\n### Pattern: Field with Default\n\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Use default if empty\nif [[ -z \"$VALUE\" ]]; then\n  VALUE=\"default_value\"\nfi\n```\n\n### Pattern: Optional Field\n\n```bash\nOPTIONAL=$(echo \"$FRONTMATTER\" | grep '^optional_field:' | sed 's/optional_field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Only use if present\nif [[ -n \"$OPTIONAL\" ]] && [[ \"$OPTIONAL\" != \"null\" ]]; then\n  # Field is set, use it\n  echo \"Optional field: $OPTIONAL\"\nfi\n```\n\n### Pattern: Multiple Fields at Once\n\n```bash\n# Parse all fields in one pass\nwhile IFS=': ' read -r key value; do\n  # Remove quotes if present\n  value=$(echo \"$value\" | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n  case \"$key\" in\n    enabled)\n      ENABLED=\"$value\"\n      ;;\n    mode)\n      MODE=\"$value\"\n      ;;\n    max_size)\n      MAX_SIZE=\"$value\"\n      ;;\n  esac\ndone <<< \"$FRONTMATTER\"\n```\n\n## Updating Settings Files\n\n### Atomic Updates\n\nAlways use temp file + atomic move to prevent corruption:\n\n```bash\n#!/bin/bash\nFILE=\".claude/my-plugin.local.md\"\nNEW_VALUE=\"updated_value\"\n\n# Create temp file\nTEMP_FILE=\"${FILE}.tmp.$$\"\n\n# Update field using sed\nsed \"s/^field_name: .*/field_name: $NEW_VALUE/\" \"$FILE\" > \"$TEMP_FILE\"\n\n# Atomic replace\nmv \"$TEMP_FILE\" \"$FILE\"\n```\n\n### Update Single Field\n\n```bash\n# Increment iteration counter\nCURRENT=$(echo \"$FRONTMATTER\" | grep '^iteration:' | sed 's/iteration: *//')\nNEXT=$((CURRENT + 1))\n\n# Update file\nTEMP_FILE=\"${FILE}.tmp.$$\"\nsed \"s/^iteration: .*/iteration: $NEXT/\" \"$FILE\" > \"$TEMP_FILE\"\nmv \"$TEMP_FILE\" \"$FILE\"\n```\n\n### Update Multiple Fields\n\n```bash\n# Update several fields at once\nTEMP_FILE=\"${FILE}.tmp.$$\"\n\nsed -e \"s/^iteration: .*/iteration: $NEXT_ITERATION/\" \\\n    -e \"s/^pr_number: .*/pr_number: $PR_NUMBER/\" \\\n    -e \"s/^status: .*/status: $NEW_STATUS/\" \\\n    \"$FILE\" > \"$TEMP_FILE\"\n\nmv \"$TEMP_FILE\" \"$FILE\"\n```\n\n## Validation Techniques\n\n### Validate File Exists and Is Readable\n\n```bash\nFILE=\".claude/my-plugin.local.md\"\n\nif [[ ! -f \"$FILE\" ]]; then\n  echo \"Settings file not found\" >&2\n  exit 1\nfi\n\nif [[ ! -r \"$FILE\" ]]; then\n  echo \"Settings file not readable\" >&2\n  exit 1\nfi\n```\n\n### Validate Frontmatter Structure\n\n```bash\n# Count --- markers (should be exactly 2 at start)\nMARKER_COUNT=$(grep -c '^---$' \"$FILE\" 2>/dev/null || echo \"0\")\n\nif [[ $MARKER_COUNT -lt 2 ]]; then\n  echo \"Invalid settings file: missing frontmatter markers\" >&2\n  exit 1\nfi\n```\n\n### Validate Field Values\n\n```bash\nMODE=$(echo \"$FRONTMATTER\" | grep '^mode:' | sed 's/mode: *//')\n\ncase \"$MODE\" in\n  strict|standard|lenient)\n    # Valid mode\n    ;;\n  *)\n    echo \"Invalid mode: $MODE (must be strict, standard, or lenient)\" >&2\n    exit 1\n    ;;\nesac\n```\n\n### Validate Numeric Ranges\n\n```bash\nMAX_SIZE=$(echo \"$FRONTMATTER\" | grep '^max_size:' | sed 's/max_size: *//')\n\nif ! [[ \"$MAX_SIZE\" =~ ^[0-9]+$ ]]; then\n  echo \"max_size must be a number\" >&2\n  exit 1\nfi\n\nif [[ $MAX_SIZE -lt 1 ]] || [[ $MAX_SIZE -gt 10000000 ]]; then\n  echo \"max_size out of range (1-10000000)\" >&2\n  exit 1\nfi\n```\n\n## Edge Cases and Gotchas\n\n### Quotes in Values\n\nYAML allows both quoted and unquoted strings:\n\n```yaml\n# These are equivalent:\nfield1: value\nfield2: \"value\"\nfield3: 'value'\n```\n\n**Handle both:**\n```bash\n# Remove surrounding quotes if present\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/' | sed \"s/^'\\\\(.*\\\\)'$/\\\\1/\")\n```\n\n### --- in Markdown Body\n\nIf the markdown body contains `---`, the parsing still works because we only match the first two:\n\n```markdown\n---\nfield: value\n---\n\n# Body\n\nHere's a separator:\n---\n\nMore content after the separator.\n```\n\nThe `awk '/^---$/{i++; next} i>=2'` pattern handles this correctly.\n\n### Empty Values\n\nHandle missing or empty fields:\n\n```yaml\nfield1:\nfield2: \"\"\nfield3: null\n```\n\n**Parsing:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field1:' | sed 's/field1: *//')\n# VALUE will be empty string\n\n# Check for empty/null\nif [[ -z \"$VALUE\" ]] || [[ \"$VALUE\" == \"null\" ]]; then\n  VALUE=\"default\"\nfi\n```\n\n### Special Characters\n\nValues with special characters need careful handling:\n\n```yaml\nmessage: \"Error: Something went wrong!\"\npath: \"/path/with spaces/file.txt\"\nregex: \"^[a-zA-Z0-9_]+$\"\n```\n\n**Safe parsing:**\n```bash\n# Always quote variables when using\nMESSAGE=$(echo \"$FRONTMATTER\" | grep '^message:' | sed 's/message: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\necho \"Message: $MESSAGE\"  # Quoted!\n```\n\n## Performance Optimization\n\n### Cache Parsed Values\n\nIf reading settings multiple times:\n\n```bash\n# Parse once\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Extract multiple fields from cached frontmatter\nFIELD1=$(echo \"$FRONTMATTER\" | grep '^field1:' | sed 's/field1: *//')\nFIELD2=$(echo \"$FRONTMATTER\" | grep '^field2:' | sed 's/field2: *//')\nFIELD3=$(echo \"$FRONTMATTER\" | grep '^field3:' | sed 's/field3: *//')\n```\n\n**Don't:** Re-parse file for each field.\n\n### Lazy Loading\n\nOnly parse settings when needed:\n\n```bash\n#!/bin/bash\ninput=$(cat)\n\n# Quick checks first (no file I/O)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\nif [[ \"$tool_name\" != \"Write\" ]]; then\n  exit 0  # Not a write operation, skip\nfi\n\n# Only now check settings file\nif [[ -f \".claude/my-plugin.local.md\" ]]; then\n  # Parse settings\n  # ...\nfi\n```\n\n## Debugging\n\n### Print Parsed Values\n\n```bash\n#!/bin/bash\nset -x  # Enable debug tracing\n\nFILE=\".claude/my-plugin.local.md\"\n\nif [[ -f \"$FILE\" ]]; then\n  echo \"Settings file found\" >&2\n\n  FRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n  echo \"Frontmatter:\" >&2\n  echo \"$FRONTMATTER\" >&2\n\n  ENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n  echo \"Enabled: $ENABLED\" >&2\nfi\n```\n\n### Validate Parsing\n\n```bash\n# Show what was parsed\necho \"Parsed values:\" >&2\necho \"  enabled: $ENABLED\" >&2\necho \"  mode: $MODE\" >&2\necho \"  max_size: $MAX_SIZE\" >&2\n\n# Verify expected values\nif [[ \"$ENABLED\" != \"true\" ]] && [[ \"$ENABLED\" != \"false\" ]]; then\n  echo \"âš ï¸  Unexpected enabled value: $ENABLED\" >&2\nfi\n```\n\n## Alternative: Using yq\n\nFor complex YAML, consider using `yq`:\n\n```bash\n# Install: brew install yq\n\n# Parse YAML properly\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Extract fields with yq\nENABLED=$(echo \"$FRONTMATTER\" | yq '.enabled')\nMODE=$(echo \"$FRONTMATTER\" | yq '.mode')\nLIST=$(echo \"$FRONTMATTER\" | yq -o json '.list_field')\n\n# Iterate list properly\necho \"$LIST\" | jq -r '.[]' | while read -r item; do\n  echo \"Item: $item\"\ndone\n```\n\n**Pros:**\n- Proper YAML parsing\n- Handles complex structures\n- Better list/object support\n\n**Cons:**\n- Requires yq installation\n- Additional dependency\n- May not be available on all systems\n\n**Recommendation:** Use sed/grep for simple fields, yq for complex structures.\n\n## Complete Example\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Configuration\nSETTINGS_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$SETTINGS_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\n  MAX_SIZE=1000000\nelse\n  # Parse frontmatter\n  FRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$SETTINGS_FILE\")\n\n  # Extract fields with defaults\n  ENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n  ENABLED=${ENABLED:-true}\n\n  MODE=$(echo \"$FRONTMATTER\" | grep '^mode:' | sed 's/mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n  MODE=${MODE:-standard}\n\n  MAX_SIZE=$(echo \"$FRONTMATTER\" | grep '^max_size:' | sed 's/max_size: *//')\n  MAX_SIZE=${MAX_SIZE:-1000000}\n\n  # Validate values\n  if [[ \"$ENABLED\" != \"true\" ]] && [[ \"$ENABLED\" != \"false\" ]]; then\n    echo \"âš ï¸  Invalid enabled value, using default\" >&2\n    ENABLED=true\n  fi\n\n  if ! [[ \"$MAX_SIZE\" =~ ^[0-9]+$ ]]; then\n    echo \"âš ï¸  Invalid max_size, using default\" >&2\n    MAX_SIZE=1000000\n  fi\nfi\n\n# Quick exit if disabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0\nfi\n\n# Use configuration\necho \"Configuration loaded: mode=$MODE, max_size=$MAX_SIZE\" >&2\n\n# Apply logic based on settings\ncase \"$MODE\" in\n  strict)\n    # Strict validation\n    ;;\n  standard)\n    # Standard validation\n    ;;\n  lenient)\n    # Lenient validation\n    ;;\nesac\n```\n\nThis provides robust settings handling with defaults, validation, and error recovery.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/plugin-settings/SKILL.md","content":"---\nname: Plugin Settings\ndescription: This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.\nversion: 0.1.0\n---\n\n# Plugin Settings Pattern for Claude Code Plugins\n\n## Overview\n\nPlugins can store user-configurable settings and state in `.claude/plugin-name.local.md` files within the project directory. This pattern uses YAML frontmatter for structured configuration and markdown content for prompts or additional context.\n\n**Key characteristics:**\n- File location: `.claude/plugin-name.local.md` in project root\n- Structure: YAML frontmatter + markdown body\n- Purpose: Per-project plugin configuration and state\n- Usage: Read from hooks, commands, and agents\n- Lifecycle: User-managed (not in git, should be in `.gitignore`)\n\n## File Structure\n\n### Basic Template\n\n```markdown\n---\nenabled: true\nsetting1: value1\nsetting2: value2\nnumeric_setting: 42\nlist_setting: [\"item1\", \"item2\"]\n---\n\n# Additional Context\n\nThis markdown body can contain:\n- Task descriptions\n- Additional instructions\n- Prompts to feed back to Claude\n- Documentation or notes\n```\n\n### Example: Plugin State File\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nenabled: true\nstrict_mode: false\nmax_retries: 3\nnotification_level: info\ncoordinator_session: team-leader\n---\n\n# Plugin Configuration\n\nThis plugin is configured for standard validation mode.\nContact @team-lead with questions.\n```\n\n## Reading Settings Files\n\n### From Hooks (Bash Scripts)\n\n**Pattern: Check existence and parse frontmatter**\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# Define state file path\nSTATE_FILE=\".claude/my-plugin.local.md\"\n\n# Quick exit if file doesn't exist\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0  # Plugin not configured, skip\nfi\n\n# Parse YAML frontmatter (between --- markers)\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\n\n# Extract individual fields\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\nSTRICT_MODE=$(echo \"$FRONTMATTER\" | grep '^strict_mode:' | sed 's/strict_mode: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Check if enabled\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Use configuration in hook logic\nif [[ \"$STRICT_MODE\" == \"true\" ]]; then\n  # Apply strict validation\n  # ...\nfi\n```\n\nSee `examples/read-settings-hook.sh` for complete working example.\n\n### From Commands\n\nCommands can read settings files to customize behavior:\n\n```markdown\n---\ndescription: Process data with plugin\nallowed-tools: [\"Read\", \"Bash\"]\n---\n\n# Process Command\n\nSteps:\n1. Check if settings exist at `.claude/my-plugin.local.md`\n2. Read configuration using Read tool\n3. Parse YAML frontmatter to extract settings\n4. Apply settings to processing logic\n5. Execute with configured behavior\n```\n\n### From Agents\n\nAgents can reference settings in their instructions:\n\n```markdown\n---\nname: configured-agent\ndescription: Agent that adapts to project settings\n---\n\nCheck for plugin settings at `.claude/my-plugin.local.md`.\nIf present, parse YAML frontmatter and adapt behavior according to:\n- enabled: Whether plugin is active\n- mode: Processing mode (strict, standard, lenient)\n- Additional configuration fields\n```\n\n## Parsing Techniques\n\n### Extract Frontmatter\n\n```bash\n# Extract everything between --- markers\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n```\n\n### Read Individual Fields\n\n**String fields:**\n```bash\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field_name:' | sed 's/field_name: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n**Boolean fields:**\n```bash\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n# Compare: if [[ \"$ENABLED\" == \"true\" ]]; then\n```\n\n**Numeric fields:**\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n# Use: if [[ $MAX -gt 100 ]]; then\n```\n\n### Read Markdown Body\n\nExtract content after second `---`:\n\n```bash\n# Get everything after closing ---\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n## Common Patterns\n\n### Pattern 1: Temporarily Active Hooks\n\nUse settings file to control hook activation:\n\n```bash\n#!/bin/bash\nSTATE_FILE=\".claude/security-scan.local.md\"\n\n# Quick exit if not configured\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  exit 0\nfi\n\n# Read enabled flag\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$STATE_FILE\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" != \"true\" ]]; then\n  exit 0  # Disabled\nfi\n\n# Run hook logic\n# ...\n```\n\n**Use case:** Enable/disable hooks without editing hooks.json (requires restart).\n\n### Pattern 2: Agent State Management\n\nStore agent-specific state and configuration:\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-agent\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\n---\n\n# Task Assignment\n\nImplement JWT authentication for the API.\n\n**Success Criteria:**\n- Authentication endpoints created\n- Tests passing\n- PR created and CI green\n```\n\nRead from hooks to coordinate agents:\n\n```bash\nAGENT_NAME=$(echo \"$FRONTMATTER\" | grep '^agent_name:' | sed 's/agent_name: *//')\nCOORDINATOR=$(echo \"$FRONTMATTER\" | grep '^coordinator_session:' | sed 's/coordinator_session: *//')\n\n# Send notification to coordinator\ntmux send-keys -t \"$COORDINATOR\" \"Agent $AGENT_NAME completed task\" Enter\n```\n\n### Pattern 3: Configuration-Driven Behavior\n\n**.claude/my-plugin.local.md:**\n```markdown\n---\nvalidation_level: strict\nmax_file_size: 1000000\nallowed_extensions: [\".js\", \".ts\", \".tsx\"]\nenable_logging: true\n---\n\n# Validation Configuration\n\nStrict mode enabled for this project.\nAll writes validated against security policies.\n```\n\nUse in hooks or commands:\n\n```bash\nLEVEL=$(echo \"$FRONTMATTER\" | grep '^validation_level:' | sed 's/validation_level: *//')\n\ncase \"$LEVEL\" in\n  strict)\n    # Apply strict validation\n    ;;\n  standard)\n    # Apply standard validation\n    ;;\n  lenient)\n    # Apply lenient validation\n    ;;\nesac\n```\n\n## Creating Settings Files\n\n### From Commands\n\nCommands can create settings files:\n\n```markdown\n# Setup Command\n\nSteps:\n1. Ask user for configuration preferences\n2. Create `.claude/my-plugin.local.md` with YAML frontmatter\n3. Set appropriate values based on user input\n4. Inform user that settings are saved\n5. Remind user to restart Claude Code for hooks to recognize changes\n```\n\n### Template Generation\n\nProvide template in plugin README:\n\n```markdown\n## Configuration\n\nCreate `.claude/my-plugin.local.md` in your project:\n\n\\`\\`\\`markdown\n---\nenabled: true\nmode: standard\nmax_retries: 3\n---\n\n# Plugin Configuration\n\nYour settings are active.\n\\`\\`\\`\n\nAfter creating or editing, restart Claude Code for changes to take effect.\n```\n\n## Best Practices\n\n### File Naming\n\nâœ… **DO:**\n- Use `.claude/plugin-name.local.md` format\n- Match plugin name exactly\n- Use `.local.md` suffix for user-local files\n\nâŒ **DON'T:**\n- Use different directory (not `.claude/`)\n- Use inconsistent naming\n- Use `.md` without `.local` (might be committed)\n\n### Gitignore\n\nAlways add to `.gitignore`:\n\n```gitignore\n.claude/*.local.md\n.claude/*.local.json\n```\n\nDocument this in plugin README.\n\n### Defaults\n\nProvide sensible defaults when settings file doesn't exist:\n\n```bash\nif [[ ! -f \"$STATE_FILE\" ]]; then\n  # Use defaults\n  ENABLED=true\n  MODE=standard\nelse\n  # Read from file\n  # ...\nfi\n```\n\n### Validation\n\nValidate settings values:\n\n```bash\nMAX=$(echo \"$FRONTMATTER\" | grep '^max_value:' | sed 's/max_value: *//')\n\n# Validate numeric range\nif ! [[ \"$MAX\" =~ ^[0-9]+$ ]] || [[ $MAX -lt 1 ]] || [[ $MAX -gt 100 ]]; then\n  echo \"âš ï¸  Invalid max_value in settings (must be 1-100)\" >&2\n  MAX=10  # Use default\nfi\n```\n\n### Restart Requirement\n\n**Important:** Settings changes require Claude Code restart.\n\nDocument in your README:\n\n```markdown\n## Changing Settings\n\nAfter editing `.claude/my-plugin.local.md`:\n1. Save the file\n2. Exit Claude Code\n3. Restart: `claude` or `cc`\n4. New settings will be loaded\n```\n\nHooks cannot be hot-swapped within a session.\n\n## Security Considerations\n\n### Sanitize User Input\n\nWhen writing settings files from user input:\n\n```bash\n# Escape quotes in user input\nSAFE_VALUE=$(echo \"$USER_INPUT\" | sed 's/\"/\\\\\"/g')\n\n# Write to file\ncat > \"$STATE_FILE\" <<EOF\n---\nuser_setting: \"$SAFE_VALUE\"\n---\nEOF\n```\n\n### Validate File Paths\n\nIf settings contain file paths:\n\n```bash\nFILE_PATH=$(echo \"$FRONTMATTER\" | grep '^data_file:' | sed 's/data_file: *//')\n\n# Check for path traversal\nif [[ \"$FILE_PATH\" == *\"..\"* ]]; then\n  echo \"âš ï¸  Invalid path in settings (path traversal)\" >&2\n  exit 2\nfi\n```\n\n### Permissions\n\nSettings files should be:\n- Readable by user only (`chmod 600`)\n- Not committed to git\n- Not shared between users\n\n## Real-World Examples\n\n### multi-agent-swarm Plugin\n\n**.claude/multi-agent-swarm.local.md:**\n```markdown\n---\nagent_name: auth-implementation\ntask_number: 3.5\npr_number: 1234\ncoordinator_session: team-leader\nenabled: true\ndependencies: [\"Task 3.4\"]\nadditional_instructions: Use JWT tokens, not sessions\n---\n\n# Task: Implement Authentication\n\nBuild JWT-based authentication for the REST API.\nCoordinate with auth-agent on shared types.\n```\n\n**Hook usage (agent-stop-notification.sh):**\n- Checks if file exists (line 15-18: quick exit if not)\n- Parses frontmatter to get coordinator_session, agent_name, enabled\n- Sends notifications to coordinator if enabled\n- Allows quick activation/deactivation via `enabled: true/false`\n\n### ralph-wiggum Plugin\n\n**.claude/ralph-loop.local.md:**\n```markdown\n---\niteration: 1\nmax_iterations: 10\ncompletion_promise: \"All tests passing and build successful\"\n---\n\nFix all the linting errors in the project.\nMake sure tests pass after each fix.\n```\n\n**Hook usage (stop-hook.sh):**\n- Checks if file exists (line 15-18: quick exit if not active)\n- Reads iteration count and max_iterations\n- Extracts completion_promise for loop termination\n- Reads body as the prompt to feed back\n- Updates iteration count on each loop\n\n## Quick Reference\n\n### File Location\n\n```\nproject-root/\nâ””â”€â”€ .claude/\n    â””â”€â”€ plugin-name.local.md\n```\n\n### Frontmatter Parsing\n\n```bash\n# Extract frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$FILE\")\n\n# Read field\nVALUE=$(echo \"$FRONTMATTER\" | grep '^field:' | sed 's/field: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n```\n\n### Body Parsing\n\n```bash\n# Extract body (after second ---)\nBODY=$(awk '/^---$/{i++; next} i>=2' \"$FILE\")\n```\n\n### Quick Exit Pattern\n\n```bash\nif [[ ! -f \".claude/my-plugin.local.md\" ]]; then\n  exit 0  # Not configured\nfi\n```\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed implementation patterns:\n\n- **`references/parsing-techniques.md`** - Complete guide to parsing YAML frontmatter and markdown bodies\n- **`references/real-world-examples.md`** - Deep dive into multi-agent-swarm and ralph-wiggum implementations\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`read-settings-hook.sh`** - Hook that reads and uses settings\n- **`create-settings-command.md`** - Command that creates settings file\n- **`example-settings.md`** - Template settings file\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-settings.sh`** - Validate settings file structure\n- **`parse-frontmatter.sh`** - Extract frontmatter fields\n\n## Implementation Workflow\n\nTo add settings to a plugin:\n\n1. Design settings schema (which fields, types, defaults)\n2. Create template file in plugin documentation\n3. Add gitignore entry for `.claude/*.local.md`\n4. Implement settings parsing in hooks/commands\n5. Use quick-exit pattern (check file exists, check enabled field)\n6. Document settings in plugin README with template\n7. Remind users that changes require Claude Code restart\n\nFocus on keeping settings simple and providing good defaults when settings file doesn't exist.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/skill-development/references/skill-creator-original.md","content":"---\nname: skill-creator\ndescription: Guide for creating effective skills. This skill should be used when users want to create a new skill (or update an existing skill) that extends Claude's capabilities with specialized knowledge, workflows, or tool integrations.\nlicense: Complete terms in LICENSE.txt\n---\n\n# Skill Creator\n\nThis skill provides guidance for creating effective skills.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Initializing the Skill\n\nAt this point, it is time to actually create the skill.\n\nSkip this step only if the skill being developed already exists, and iteration or packaging is needed. In this case, continue to the next step.\n\nWhen creating a new skill from scratch, always run the `init_skill.py` script. The script conveniently generates a new template skill directory that automatically includes everything a skill requires, making the skill creation process much more efficient and reliable.\n\nUsage:\n\n```bash\nscripts/init_skill.py <skill-name> --path <output-directory>\n```\n\nThe script:\n\n- Creates the skill directory at the specified path\n- Generates a SKILL.md template with proper frontmatter and TODO placeholders\n- Creates example resource directories: `scripts/`, `references/`, and `assets/`\n- Adds example files in each directory that can be customized or deleted\n\nAfter initialization, customize or remove the generated SKILL.md and example files as needed.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-generated or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. The initialization script creates example files in `scripts/`, `references/`, and `assets/` to demonstrate structure, but most skills won't need all of them.\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\nTo complete SKILL.md, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used?\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n### Step 5: Packaging a Skill\n\nOnce the skill is ready, it should be packaged into a distributable zip file that gets shared with the user. The packaging process automatically validates the skill first to ensure it meets all requirements:\n\n```bash\nscripts/package_skill.py <path/to/skill-folder>\n```\n\nOptional output directory specification:\n\n```bash\nscripts/package_skill.py <path/to/skill-folder> ./dist\n```\n\nThe packaging script will:\n\n1. **Validate** the skill automatically, checking:\n   - YAML frontmatter format and required fields\n   - Skill naming conventions and directory structure\n   - Description completeness and quality\n   - File organization and resource references\n\n2. **Package** the skill if validation passes, creating a zip file named after the skill (e.g., `my-skill.zip`) that includes all files and maintains the proper directory structure for distribution.\n\nIf validation fails, the script will report the errors and exit without creating a package. Fix any validation errors and run the packaging command again.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/skill-development/SKILL.md","content":"---\nname: Skill Development\ndescription: This skill should be used when the user wants to \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\", or needs guidance on skill structure, progressive disclosure, or skill development best practices for Claude Code plugins.\nversion: 0.1.0\n---\n\n# Skill Development for Claude Code Plugins\n\nThis skill provides guidance for creating effective skills for Claude Code plugins.\n\n## About Skills\n\nSkills are modular, self-contained packages that extend Claude's capabilities by providing\nspecialized knowledge, workflows, and tools. Think of them as \"onboarding guides\" for specific\ndomains or tasksâ€”they transform Claude from a general-purpose agent into a specialized agent\nequipped with procedural knowledge that no model can fully possess.\n\n### What Skills Provide\n\n1. Specialized workflows - Multi-step procedures for specific domains\n2. Tool integrations - Instructions for working with specific file formats or APIs\n3. Domain expertise - Company-specific knowledge, schemas, business logic\n4. Bundled resources - Scripts, references, and assets for complex and repetitive tasks\n\n### Anatomy of a Skill\n\nEvery skill consists of a required SKILL.md file and optional bundled resources:\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md (required)\nâ”‚   â”œâ”€â”€ YAML frontmatter metadata (required)\nâ”‚   â”‚   â”œâ”€â”€ name: (required)\nâ”‚   â”‚   â””â”€â”€ description: (required)\nâ”‚   â””â”€â”€ Markdown instructions (required)\nâ””â”€â”€ Bundled Resources (optional)\n    â”œâ”€â”€ scripts/          - Executable code (Python/Bash/etc.)\n    â”œâ”€â”€ references/       - Documentation intended to be loaded into context as needed\n    â””â”€â”€ assets/           - Files used in output (templates, icons, fonts, etc.)\n```\n\n#### SKILL.md (required)\n\n**Metadata Quality:** The `name` and `description` in YAML frontmatter determine when Claude will use the skill. Be specific about what the skill does and when to use it. Use the third-person (e.g. \"This skill should be used when...\" instead of \"Use this skill when...\").\n\n#### Bundled Resources (optional)\n\n##### Scripts (`scripts/`)\n\nExecutable code (Python/Bash/etc.) for tasks that require deterministic reliability or are repeatedly rewritten.\n\n- **When to include**: When the same code is being rewritten repeatedly or deterministic reliability is needed\n- **Example**: `scripts/rotate_pdf.py` for PDF rotation tasks\n- **Benefits**: Token efficient, deterministic, may be executed without loading into context\n- **Note**: Scripts may still need to be read by Claude for patching or environment-specific adjustments\n\n##### References (`references/`)\n\nDocumentation and reference material intended to be loaded as needed into context to inform Claude's process and thinking.\n\n- **When to include**: For documentation that Claude should reference while working\n- **Examples**: `references/finance.md` for financial schemas, `references/mnda.md` for company NDA template, `references/policies.md` for company policies, `references/api_docs.md` for API specifications\n- **Use cases**: Database schemas, API documentation, domain knowledge, company policies, detailed workflow guides\n- **Benefits**: Keeps SKILL.md lean, loaded only when Claude determines it's needed\n- **Best practice**: If files are large (>10k words), include grep search patterns in SKILL.md\n- **Avoid duplication**: Information should live in either SKILL.md or references files, not both. Prefer references files for detailed information unless it's truly core to the skillâ€”this keeps SKILL.md lean while making information discoverable without hogging the context window. Keep only essential procedural instructions and workflow guidance in SKILL.md; move detailed reference material, schemas, and examples to references files.\n\n##### Assets (`assets/`)\n\nFiles not intended to be loaded into context, but rather used within the output Claude produces.\n\n- **When to include**: When the skill needs files that will be used in the final output\n- **Examples**: `assets/logo.png` for brand assets, `assets/slides.pptx` for PowerPoint templates, `assets/frontend-template/` for HTML/React boilerplate, `assets/font.ttf` for typography\n- **Use cases**: Templates, images, icons, boilerplate code, fonts, sample documents that get copied or modified\n- **Benefits**: Separates output resources from documentation, enables Claude to use files without loading them into context\n\n### Progressive Disclosure Design Principle\n\nSkills use a three-level loading system to manage context efficiently:\n\n1. **Metadata (name + description)** - Always in context (~100 words)\n2. **SKILL.md body** - When skill triggers (<5k words)\n3. **Bundled resources** - As needed by Claude (Unlimited*)\n\n*Unlimited because scripts can be executed without reading into context window.\n\n## Skill Creation Process\n\nTo create a skill, follow the \"Skill Creation Process\" in order, skipping steps only if there is a clear reason why they are not applicable.\n\n### Step 1: Understanding the Skill with Concrete Examples\n\nSkip this step only when the skill's usage patterns are already clearly understood. It remains valuable even when working with an existing skill.\n\nTo create an effective skill, clearly understand concrete examples of how the skill will be used. This understanding can come from either direct user examples or generated examples that are validated with user feedback.\n\nFor example, when building an image-editor skill, relevant questions include:\n\n- \"What functionality should the image-editor skill support? Editing, rotating, anything else?\"\n- \"Can you give some examples of how this skill would be used?\"\n- \"I can imagine users asking for things like 'Remove the red-eye from this image' or 'Rotate this image'. Are there other ways you imagine this skill being used?\"\n- \"What would a user say that should trigger this skill?\"\n\nTo avoid overwhelming users, avoid asking too many questions in a single message. Start with the most important questions and follow up as needed for better effectiveness.\n\nConclude this step when there is a clear sense of the functionality the skill should support.\n\n### Step 2: Planning the Reusable Skill Contents\n\nTo turn concrete examples into an effective skill, analyze each example by:\n\n1. Considering how to execute on the example from scratch\n2. Identifying what scripts, references, and assets would be helpful when executing these workflows repeatedly\n\nExample: When building a `pdf-editor` skill to handle queries like \"Help me rotate this PDF,\" the analysis shows:\n\n1. Rotating a PDF requires re-writing the same code each time\n2. A `scripts/rotate_pdf.py` script would be helpful to store in the skill\n\nExample: When designing a `frontend-webapp-builder` skill for queries like \"Build me a todo app\" or \"Build me a dashboard to track my steps,\" the analysis shows:\n\n1. Writing a frontend webapp requires the same boilerplate HTML/React each time\n2. An `assets/hello-world/` template containing the boilerplate HTML/React project files would be helpful to store in the skill\n\nExample: When building a `big-query` skill to handle queries like \"How many users have logged in today?\" the analysis shows:\n\n1. Querying BigQuery requires re-discovering the table schemas and relationships each time\n2. A `references/schema.md` file documenting the table schemas would be helpful to store in the skill\n\n**For Claude Code plugins:** When building a hooks skill, the analysis shows:\n1. Developers repeatedly need to validate hooks.json and test hook scripts\n2. `scripts/validate-hook-schema.sh` and `scripts/test-hook.sh` utilities would be helpful\n3. `references/patterns.md` for detailed hook patterns to avoid bloating SKILL.md\n\nTo establish the skill's contents, analyze each concrete example to create a list of the reusable resources to include: scripts, references, and assets.\n\n### Step 3: Create Skill Structure\n\nFor Claude Code plugins, create the skill directory structure:\n\n```bash\nmkdir -p plugin-name/skills/skill-name/{references,examples,scripts}\ntouch plugin-name/skills/skill-name/SKILL.md\n```\n\n**Note:** Unlike the generic skill-creator which uses `init_skill.py`, plugin skills are created directly in the plugin's `skills/` directory with a simpler manual structure.\n\n### Step 4: Edit the Skill\n\nWhen editing the (newly-created or existing) skill, remember that the skill is being created for another instance of Claude to use. Focus on including information that would be beneficial and non-obvious to Claude. Consider what procedural knowledge, domain-specific details, or reusable assets would help another Claude instance execute these tasks more effectively.\n\n#### Start with Reusable Skill Contents\n\nTo begin implementation, start with the reusable resources identified above: `scripts/`, `references/`, and `assets/` files. Note that this step may require user input. For example, when implementing a `brand-guidelines` skill, the user may need to provide brand assets or templates to store in `assets/`, or documentation to store in `references/`.\n\nAlso, delete any example files and directories not needed for the skill. Create only the directories you actually need (references/, examples/, scripts/).\n\n#### Update SKILL.md\n\n**Writing Style:** Write the entire skill using **imperative/infinitive form** (verb-first instructions), not second person. Use objective, instructional language (e.g., \"To accomplish X, do Y\" rather than \"You should do X\" or \"If you need to do X\"). This maintains consistency and clarity for AI consumption.\n\n**Description (Frontmatter):** Use third-person format with specific trigger phrases:\n\n```yaml\n---\nname: Skill Name\ndescription: This skill should be used when the user asks to \"specific phrase 1\", \"specific phrase 2\", \"specific phrase 3\". Include exact phrases users would say that should trigger this skill. Be concrete and specific.\nversion: 0.1.0\n---\n```\n\n**Good description examples:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", or mentions hook events (PreToolUse, PostToolUse, Stop).\n```\n\n**Bad description examples:**\n```yaml\ndescription: Use this skill when working with hooks.  # Wrong person, vague\ndescription: Load when user needs hook help.  # Not third person\ndescription: Provides hook guidance.  # No trigger phrases\n```\n\nTo complete SKILL.md body, answer the following questions:\n\n1. What is the purpose of the skill, in a few sentences?\n2. When should the skill be used? (Include this in frontmatter description with specific triggers)\n3. In practice, how should Claude use the skill? All reusable skill contents developed above should be referenced so that Claude knows how to use them.\n\n**Keep SKILL.md lean:** Target 1,500-2,000 words for the body. Move detailed content to references/:\n- Detailed patterns â†’ `references/patterns.md`\n- Advanced techniques â†’ `references/advanced.md`\n- Migration guides â†’ `references/migration.md`\n- API references â†’ `references/api-reference.md`\n\n**Reference resources in SKILL.md:**\n```markdown\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and techniques, consult:\n- **`references/patterns.md`** - Common patterns\n- **`references/advanced.md`** - Advanced use cases\n\n### Example Files\n\nWorking examples in `examples/`:\n- **`example-script.sh`** - Working example\n```\n\n### Step 5: Validate and Test\n\n**For plugin skills, validation is different from generic skills:**\n\n1. **Check structure**: Skill directory in `plugin-name/skills/skill-name/`\n2. **Validate SKILL.md**: Has frontmatter with name and description\n3. **Check trigger phrases**: Description includes specific user queries\n4. **Verify writing style**: Body uses imperative/infinitive form, not second person\n5. **Test progressive disclosure**: SKILL.md is lean (~1,500-2,000 words), detailed content in references/\n6. **Check references**: All referenced files exist\n7. **Validate examples**: Examples are complete and correct\n8. **Test scripts**: Scripts are executable and work correctly\n\n**Use the skill-reviewer agent:**\n```\nAsk: \"Review my skill and check if it follows best practices\"\n```\n\nThe skill-reviewer agent will check description quality, content organization, and progressive disclosure.\n\n### Step 6: Iterate\n\nAfter testing the skill, users may request improvements. Often this happens right after using the skill, with fresh context of how the skill performed.\n\n**Iteration workflow:**\n1. Use the skill on real tasks\n2. Notice struggles or inefficiencies\n3. Identify how SKILL.md or bundled resources should be updated\n4. Implement changes and test again\n\n**Common improvements:**\n- Strengthen trigger phrases in description\n- Move long sections from SKILL.md to references/\n- Add missing examples or scripts\n- Clarify ambiguous instructions\n- Add edge case handling\n\n## Plugin-Specific Considerations\n\n### Skill Location in Plugins\n\nPlugin skills live in the plugin's `skills/` directory:\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ commands/\nâ”œâ”€â”€ agents/\nâ””â”€â”€ skills/\n    â””â”€â”€ my-skill/\n        â”œâ”€â”€ SKILL.md\n        â”œâ”€â”€ references/\n        â”œâ”€â”€ examples/\n        â””â”€â”€ scripts/\n```\n\n### Auto-Discovery\n\nClaude Code automatically discovers skills:\n- Scans `skills/` directory\n- Finds subdirectories containing `SKILL.md`\n- Loads skill metadata (name + description) always\n- Loads SKILL.md body when skill triggers\n- Loads references/examples when needed\n\n### No Packaging Needed\n\nPlugin skills are distributed as part of the plugin, not as separate ZIP files. Users get skills when they install the plugin.\n\n### Testing in Plugins\n\nTest skills by installing plugin locally:\n\n```bash\n# Test with --plugin-dir\ncc --plugin-dir /path/to/plugin\n\n# Ask questions that should trigger the skill\n# Verify skill loads correctly\n```\n\n## Examples from Plugin-Dev\n\nStudy the skills in this plugin as examples of best practices:\n\n**hook-development skill:**\n- Excellent trigger phrases: \"create a hook\", \"add a PreToolUse hook\", etc.\n- Lean SKILL.md (1,651 words)\n- 3 references/ files for detailed content\n- 3 examples/ of working hooks\n- 3 scripts/ utilities\n\n**agent-development skill:**\n- Strong triggers: \"create an agent\", \"agent frontmatter\", etc.\n- Focused SKILL.md (1,438 words)\n- References include the AI generation prompt from Claude Code\n- Complete agent examples\n\n**plugin-settings skill:**\n- Specific triggers: \"plugin settings\", \".local.md files\", \"YAML frontmatter\"\n- References show real implementations (multi-agent-swarm, ralph-wiggum)\n- Working parsing scripts\n\nEach demonstrates progressive disclosure and strong triggering.\n\n## Progressive Disclosure in Practice\n\n### What Goes in SKILL.md\n\n**Include (always loaded when skill triggers):**\n- Core concepts and overview\n- Essential procedures and workflows\n- Quick reference tables\n- Pointers to references/examples/scripts\n- Most common use cases\n\n**Keep under 3,000 words, ideally 1,500-2,000 words**\n\n### What Goes in references/\n\n**Move to references/ (loaded as needed):**\n- Detailed patterns and advanced techniques\n- Comprehensive API documentation\n- Migration guides\n- Edge cases and troubleshooting\n- Extensive examples and walkthroughs\n\n**Each reference file can be large (2,000-5,000+ words)**\n\n### What Goes in examples/\n\n**Working code examples:**\n- Complete, runnable scripts\n- Configuration files\n- Template files\n- Real-world usage examples\n\n**Users can copy and adapt these directly**\n\n### What Goes in scripts/\n\n**Utility scripts:**\n- Validation tools\n- Testing helpers\n- Parsing utilities\n- Automation scripts\n\n**Should be executable and documented**\n\n## Writing Style Requirements\n\n### Imperative/Infinitive Form\n\nWrite using verb-first instructions, not second person:\n\n**Correct (imperative):**\n```\nTo create a hook, define the event type.\nConfigure the MCP server with authentication.\nValidate settings before use.\n```\n\n**Incorrect (second person):**\n```\nYou should create a hook by defining the event type.\nYou need to configure the MCP server.\nYou must validate settings before use.\n```\n\n### Third-Person in Description\n\nThe frontmatter description must use third person:\n\n**Correct:**\n```yaml\ndescription: This skill should be used when the user asks to \"create X\", \"configure Y\"...\n```\n\n**Incorrect:**\n```yaml\ndescription: Use this skill when you want to create X...\ndescription: Load this skill when user asks...\n```\n\n### Objective, Instructional Language\n\nFocus on what to do, not who should do it:\n\n**Correct:**\n```\nParse the frontmatter using sed.\nExtract fields with grep.\nValidate values before use.\n```\n\n**Incorrect:**\n```\nYou can parse the frontmatter...\nClaude should extract fields...\nThe user might validate values...\n```\n\n## Validation Checklist\n\nBefore finalizing a skill:\n\n**Structure:**\n- [ ] SKILL.md file exists with valid YAML frontmatter\n- [ ] Frontmatter has `name` and `description` fields\n- [ ] Markdown body is present and substantial\n- [ ] Referenced files actually exist\n\n**Description Quality:**\n- [ ] Uses third person (\"This skill should be used when...\")\n- [ ] Includes specific trigger phrases users would say\n- [ ] Lists concrete scenarios (\"create X\", \"configure Y\")\n- [ ] Not vague or generic\n\n**Content Quality:**\n- [ ] SKILL.md body uses imperative/infinitive form\n- [ ] Body is focused and lean (1,500-2,000 words ideal, <5k max)\n- [ ] Detailed content moved to references/\n- [ ] Examples are complete and working\n- [ ] Scripts are executable and documented\n\n**Progressive Disclosure:**\n- [ ] Core concepts in SKILL.md\n- [ ] Detailed docs in references/\n- [ ] Working code in examples/\n- [ ] Utilities in scripts/\n- [ ] SKILL.md references these resources\n\n**Testing:**\n- [ ] Skill triggers on expected user queries\n- [ ] Content is helpful for intended tasks\n- [ ] No duplicated information across files\n- [ ] References load when needed\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Weak Trigger Description\n\nâŒ **Bad:**\n```yaml\ndescription: Provides guidance for working with hooks.\n```\n\n**Why bad:** Vague, no specific trigger phrases, not third person\n\nâœ… **Good:**\n```yaml\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", or mentions hook events. Provides comprehensive hooks API guidance.\n```\n\n**Why good:** Third person, specific phrases, concrete scenarios\n\n### Mistake 2: Too Much in SKILL.md\n\nâŒ **Bad:**\n```\nskill-name/\nâ””â”€â”€ SKILL.md  (8,000 words - everything in one file)\n```\n\n**Why bad:** Bloats context when skill loads, detailed content always loaded\n\nâœ… **Good:**\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md  (1,800 words - core essentials)\nâ””â”€â”€ references/\n    â”œâ”€â”€ patterns.md (2,500 words)\n    â””â”€â”€ advanced.md (3,700 words)\n```\n\n**Why good:** Progressive disclosure, detailed content loaded only when needed\n\n### Mistake 3: Second Person Writing\n\nâŒ **Bad:**\n```markdown\nYou should start by reading the configuration file.\nYou need to validate the input.\nYou can use the grep tool to search.\n```\n\n**Why bad:** Second person, not imperative form\n\nâœ… **Good:**\n```markdown\nStart by reading the configuration file.\nValidate the input before processing.\nUse the grep tool to search for patterns.\n```\n\n**Why good:** Imperative form, direct instructions\n\n### Mistake 4: Missing Resource References\n\nâŒ **Bad:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n[No mention of references/ or examples/]\n```\n\n**Why bad:** Claude doesn't know references exist\n\nâœ… **Good:**\n```markdown\n# SKILL.md\n\n[Core content]\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns.md`** - Detailed patterns\n- **`references/advanced.md`** - Advanced techniques\n\n### Examples\n- **`examples/script.sh`** - Working example\n```\n\n**Why good:** Claude knows where to find additional information\n\n## Quick Reference\n\n### Minimal Skill\n\n```\nskill-name/\nâ””â”€â”€ SKILL.md\n```\n\nGood for: Simple knowledge, no complex resources needed\n\n### Standard Skill (Recommended)\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â””â”€â”€ detailed-guide.md\nâ””â”€â”€ examples/\n    â””â”€â”€ working-example.sh\n```\n\nGood for: Most plugin skills with detailed documentation\n\n### Complete Skill\n\n```\nskill-name/\nâ”œâ”€â”€ SKILL.md\nâ”œâ”€â”€ references/\nâ”‚   â”œâ”€â”€ patterns.md\nâ”‚   â””â”€â”€ advanced.md\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ example1.sh\nâ”‚   â””â”€â”€ example2.json\nâ””â”€â”€ scripts/\n    â””â”€â”€ validate.sh\n```\n\nGood for: Complex domains with validation utilities\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Use third-person in description (\"This skill should be used when...\")\n- Include specific trigger phrases (\"create X\", \"configure Y\")\n- Keep SKILL.md lean (1,500-2,000 words)\n- Use progressive disclosure (move details to references/)\n- Write in imperative/infinitive form\n- Reference supporting files clearly\n- Provide working examples\n- Create utility scripts for common operations\n- Study plugin-dev's skills as templates\n\nâŒ **DON'T:**\n- Use second person anywhere\n- Have vague trigger conditions\n- Put everything in SKILL.md (>3,000 words without references/)\n- Write in second person (\"You should...\")\n- Leave resources unreferenced\n- Include broken or incomplete examples\n- Skip validation\n\n## Additional Resources\n\n### Study These Skills\n\nPlugin-dev's skills demonstrate best practices:\n- `../hook-development/` - Progressive disclosure, utilities\n- `../agent-development/` - AI-assisted creation, references\n- `../mcp-integration/` - Comprehensive references\n- `../plugin-settings/` - Real-world examples\n- `../command-development/` - Clear critical concepts\n- `../plugin-structure/` - Good organization\n\n### Reference Files\n\nFor complete skill-creator methodology:\n- **`references/skill-creator-original.md`** - Full original skill-creator content\n\n## Implementation Workflow\n\nTo create a skill for your plugin:\n\n1. **Understand use cases**: Identify concrete examples of skill usage\n2. **Plan resources**: Determine what scripts/references/examples needed\n3. **Create structure**: `mkdir -p skills/skill-name/{references,examples,scripts}`\n4. **Write SKILL.md**:\n   - Frontmatter with third-person description and trigger phrases\n   - Lean body (1,500-2,000 words) in imperative form\n   - Reference supporting files\n5. **Add resources**: Create references/, examples/, scripts/ as needed\n6. **Validate**: Check description, writing style, organization\n7. **Test**: Verify skill loads on expected triggers\n8. **Iterate**: Improve based on usage\n\nFocus on strong trigger descriptions, progressive disclosure, and imperative writing style for effective skills that load when needed and provide targeted guidance.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/agent-development/examples/agent-creation-prompt.md","content":"# AI-Assisted Agent Generation Template\n\nUse this template to generate agents using Claude with the agent creation system prompt.\n\n## Usage Pattern\n\n### Step 1: Describe Your Agent Need\n\nThink about:\n- What task should the agent handle?\n- When should it be triggered?\n- Should it be proactive or reactive?\n- What are the key responsibilities?\n\n### Step 2: Use the Generation Prompt\n\nSend this to Claude (with the agent-creation-system-prompt loaded):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nReturn ONLY the JSON object, no other text.\n```\n\n**Replace [YOUR DESCRIPTION] with your agent requirements.**\n\n### Step 3: Claude Returns JSON\n\nClaude will return:\n\n```json\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are... **Your Core Responsibilities:**...\"\n}\n```\n\n### Step 4: Convert to Agent File\n\nCreate `agents/[identifier].md`:\n\n```markdown\n---\nname: [identifier from JSON]\ndescription: [whenToUse from JSON]\nmodel: inherit\ncolor: [choose: blue/cyan/green/yellow/magenta/red]\ntools: [\"Read\", \"Write\", \"Grep\"]  # Optional: restrict tools\n---\n\n[systemPrompt from JSON]\n```\n\n## Example 1: Code Review Agent\n\n**Your request:**\n```\nI need an agent that reviews code changes for quality issues, security vulnerabilities, and adherence to best practices. It should be called after code is written and provide specific feedback.\n```\n\n**Claude generates:**\n```json\n{\n  \"identifier\": \"code-quality-reviewer\",\n  \"whenToUse\": \"Use this agent when the user has written code and needs quality review, or explicitly asks to review code changes. Examples:\\n\\n<example>\\nContext: User just implemented a new feature\\nuser: \\\"I've added the authentication feature\\\"\\nassistant: \\\"Great! Let me review the code quality.\\\"\\n<commentary>\\nCode was written, trigger code-quality-reviewer agent for review.\\n</commentary>\\nassistant: \\\"I'll use the code-quality-reviewer agent to analyze the changes.\\\"\\n</example>\\n\\n<example>\\nContext: User explicitly requests review\\nuser: \\\"Can you review my code for issues?\\\"\\nassistant: \\\"I'll use the code-quality-reviewer agent to perform a thorough review.\\\"\\n<commentary>\\nExplicit review request triggers the agent.\\n</commentary>\\n</example>\",\n  \"systemPrompt\": \"You are an expert code quality reviewer specializing in identifying issues in software implementations.\\n\\n**Your Core Responsibilities:**\\n1. Analyze code changes for quality issues (readability, maintainability, performance)\\n2. Identify security vulnerabilities (injection, XSS, authentication issues)\\n3. Check adherence to project best practices and coding standards\\n4. Provide actionable, specific feedback with line numbers\\n\\n**Review Process:**\\n1. Read the code changes using available tools\\n2. Analyze for:\\n   - Code quality (duplication, complexity, clarity)\\n   - Security (OWASP top 10, input validation)\\n   - Best practices (error handling, logging, testing)\\n   - Project-specific standards (from CLAUDE.md)\\n3. Identify issues with severity (critical/major/minor)\\n4. Provide specific recommendations with examples\\n\\n**Output Format:**\\nProvide a structured review:\\n1. Summary (2-3 sentences)\\n2. Critical Issues (must fix)\\n3. Major Issues (should fix)\\n4. Minor Issues (nice to fix)\\n5. Positive observations\\n6. Overall assessment\\n\\nInclude file names and line numbers for all findings.\"\n}\n```\n\n**You create:**\n\nFile: `agents/code-quality-reviewer.md`\n\n```markdown\n---\nname: code-quality-reviewer\ndescription: Use this agent when the user has written code and needs quality review, or explicitly asks to review code changes. Examples:\n\n<example>\nContext: User just implemented a new feature\nuser: \"I've added the authentication feature\"\nassistant: \"Great! Let me review the code quality.\"\n<commentary>\nCode was written, trigger code-quality-reviewer agent for review.\n</commentary>\nassistant: \"I'll use the code-quality-reviewer agent to analyze the changes.\"\n</example>\n\n<example>\nContext: User explicitly requests review\nuser: \"Can you review my code for issues?\"\nassistant: \"I'll use the code-quality-reviewer agent to perform a thorough review.\"\n<commentary>\nExplicit review request triggers the agent.\n</commentary>\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Grep\", \"Glob\"]\n---\n\nYou are an expert code quality reviewer specializing in identifying issues in software implementations.\n\n**Your Core Responsibilities:**\n1. Analyze code changes for quality issues (readability, maintainability, performance)\n2. Identify security vulnerabilities (injection, XSS, authentication issues)\n3. Check adherence to project best practices and coding standards\n4. Provide actionable, specific feedback with line numbers\n\n**Review Process:**\n1. Read the code changes using available tools\n2. Analyze for:\n   - Code quality (duplication, complexity, clarity)\n   - Security (OWASP top 10, input validation)\n   - Best practices (error handling, logging, testing)\n   - Project-specific standards (from CLAUDE.md)\n3. Identify issues with severity (critical/major/minor)\n4. Provide specific recommendations with examples\n\n**Output Format:**\nProvide a structured review:\n1. Summary (2-3 sentences)\n2. Critical Issues (must fix)\n3. Major Issues (should fix)\n4. Minor Issues (nice to fix)\n5. Positive observations\n6. Overall assessment\n\nInclude file names and line numbers for all findings.\n```\n\n## Example 2: Test Generation Agent\n\n**Your request:**\n```\nCreate an agent that generates unit tests for code. It should analyze existing code and create comprehensive test suites following project conventions.\n```\n\n**Claude generates:**\n```json\n{\n  \"identifier\": \"test-generator\",\n  \"whenToUse\": \"Use this agent when the user asks to generate tests, needs test coverage, or has written code that needs testing. Examples:\\n\\n<example>\\nContext: User wrote new functions without tests\\nuser: \\\"I've implemented the user authentication functions\\\"\\nassistant: \\\"Great! Let me generate tests for these functions.\\\"\\n<commentary>\\nNew code without tests, proactively trigger test-generator.\\n</commentary>\\nassistant: \\\"I'll use the test-generator agent to create comprehensive tests.\\\"\\n</example>\",\n  \"systemPrompt\": \"You are an expert test engineer specializing in creating comprehensive unit tests...\\n\\n**Your Core Responsibilities:**\\n1. Analyze code to understand behavior\\n2. Generate test cases covering happy paths and edge cases\\n3. Follow project testing conventions\\n4. Ensure high code coverage\\n\\n**Test Generation Process:**\\n1. Read target code\\n2. Identify testable units (functions, classes, methods)\\n3. Design test cases (inputs, expected outputs, edge cases)\\n4. Generate tests following project patterns\\n5. Add assertions and error cases\\n\\n**Output Format:**\\nGenerate complete test files with:\\n- Test suite structure\\n- Setup/teardown if needed\\n- Descriptive test names\\n- Comprehensive assertions\"\n}\n```\n\n**You create:** `agents/test-generator.md` with the structure above.\n\n## Example 3: Documentation Agent\n\n**Your request:**\n```\nBuild an agent that writes and updates API documentation. It should analyze code and generate clear, comprehensive docs.\n```\n\n**Result:** Agent file with identifier `api-docs-writer`, appropriate examples, and system prompt for documentation generation.\n\n## Tips for Effective Agent Generation\n\n### Be Specific in Your Request\n\n**Vague:**\n```\n\"I need an agent that helps with code\"\n```\n\n**Specific:**\n```\n\"I need an agent that reviews pull requests for type safety issues in TypeScript, checking for proper type annotations, avoiding 'any', and ensuring correct generic usage\"\n```\n\n### Include Triggering Preferences\n\nTell Claude when the agent should activate:\n\n```\n\"Create an agent that generates tests. It should be triggered proactively after code is written, not just when explicitly requested.\"\n```\n\n### Mention Project Context\n\n```\n\"Create a code review agent. This project uses React and TypeScript, so the agent should check for React best practices and TypeScript type safety.\"\n```\n\n### Define Output Expectations\n\n```\n\"Create an agent that analyzes performance. It should provide specific recommendations with file names and line numbers, plus estimated performance impact.\"\n```\n\n## Validation After Generation\n\nAlways validate generated agents:\n\n```bash\n# Validate structure\n./scripts/validate-agent.sh agents/your-agent.md\n\n# Check triggering works\n# Test with scenarios from examples\n```\n\n## Iterating on Generated Agents\n\nIf generated agent needs improvement:\n\n1. Identify what's missing or wrong\n2. Manually edit the agent file\n3. Focus on:\n   - Better examples in description\n   - More specific system prompt\n   - Clearer process steps\n   - Better output format definition\n4. Re-validate\n5. Test again\n\n## Advantages of AI-Assisted Generation\n\n- **Comprehensive**: Claude includes edge cases and quality checks\n- **Consistent**: Follows proven patterns\n- **Fast**: Seconds vs manual writing\n- **Examples**: Auto-generates triggering examples\n- **Complete**: Provides full system prompt structure\n\n## When to Edit Manually\n\nEdit generated agents when:\n- Need very specific project patterns\n- Require custom tool combinations\n- Want unique persona or style\n- Integrating with existing agents\n- Need precise triggering conditions\n\nStart with generation, then refine manually for best results.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/agent-development/examples/complete-agent-examples.md","content":"# Complete Agent Examples\n\nFull, production-ready agent examples for common use cases. Use these as templates for your own agents.\n\n## Example 1: Code Review Agent\n\n**File:** `agents/code-reviewer.md`\n\n```markdown\n---\nname: code-reviewer\ndescription: Use this agent when the user has written code and needs quality review, security analysis, or best practices validation. Examples:\n\n<example>\nContext: User just implemented a new feature\nuser: \"I've added the payment processing feature\"\nassistant: \"Great! Let me review the implementation.\"\n<commentary>\nCode written for payment processing (security-critical). Proactively trigger\ncode-reviewer agent to check for security issues and best practices.\n</commentary>\nassistant: \"I'll use the code-reviewer agent to analyze the payment code.\"\n</example>\n\n<example>\nContext: User explicitly requests code review\nuser: \"Can you review my code for issues?\"\nassistant: \"I'll use the code-reviewer agent to perform a comprehensive review.\"\n<commentary>\nExplicit code review request triggers the agent.\n</commentary>\n</example>\n\n<example>\nContext: Before committing code\nuser: \"I'm ready to commit these changes\"\nassistant: \"Let me review them first.\"\n<commentary>\nBefore commit, proactively review code quality.\n</commentary>\nassistant: \"I'll use the code-reviewer agent to validate the changes.\"\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Grep\", \"Glob\"]\n---\n\nYou are an expert code quality reviewer specializing in identifying issues, security vulnerabilities, and opportunities for improvement in software implementations.\n\n**Your Core Responsibilities:**\n1. Analyze code changes for quality issues (readability, maintainability, complexity)\n2. Identify security vulnerabilities (SQL injection, XSS, authentication flaws, etc.)\n3. Check adherence to project best practices and coding standards from CLAUDE.md\n4. Provide specific, actionable feedback with file and line number references\n5. Recognize and commend good practices\n\n**Code Review Process:**\n1. **Gather Context**: Use Glob to find recently modified files (git diff, git status)\n2. **Read Code**: Use Read tool to examine changed files\n3. **Analyze Quality**:\n   - Check for code duplication (DRY principle)\n   - Assess complexity and readability\n   - Verify error handling\n   - Check for proper logging\n4. **Security Analysis**:\n   - Scan for injection vulnerabilities (SQL, command, XSS)\n   - Check authentication and authorization\n   - Verify input validation and sanitization\n   - Look for hardcoded secrets or credentials\n5. **Best Practices**:\n   - Follow project-specific standards from CLAUDE.md\n   - Check naming conventions\n   - Verify test coverage\n   - Assess documentation\n6. **Categorize Issues**: Group by severity (critical/major/minor)\n7. **Generate Report**: Format according to output template\n\n**Quality Standards:**\n- Every issue includes file path and line number (e.g., `src/auth.ts:42`)\n- Issues categorized by severity with clear criteria\n- Recommendations are specific and actionable (not vague)\n- Include code examples in recommendations when helpful\n- Balance criticism with recognition of good practices\n\n**Output Format:**\n## Code Review Summary\n[2-3 sentence overview of changes and overall quality]\n\n## Critical Issues (Must Fix)\n- `src/file.ts:42` - [Issue description] - [Why critical] - [How to fix]\n\n## Major Issues (Should Fix)\n- `src/file.ts:15` - [Issue description] - [Impact] - [Recommendation]\n\n## Minor Issues (Consider Fixing)\n- `src/file.ts:88` - [Issue description] - [Suggestion]\n\n## Positive Observations\n- [Good practice 1]\n- [Good practice 2]\n\n## Overall Assessment\n[Final verdict and recommendations]\n\n**Edge Cases:**\n- No issues found: Provide positive validation, mention what was checked\n- Too many issues (>20): Group by type, prioritize top 10 critical/major\n- Unclear code intent: Note ambiguity and request clarification\n- Missing context (no CLAUDE.md): Apply general best practices\n- Large changeset: Focus on most impactful files first\n```\n\n## Example 2: Test Generator Agent\n\n**File:** `agents/test-generator.md`\n\n```markdown\n---\nname: test-generator\ndescription: Use this agent when the user has written code without tests, explicitly asks for test generation, or needs test coverage improvement. Examples:\n\n<example>\nContext: User implemented functions without tests\nuser: \"I've added the data validation functions\"\nassistant: \"Let me generate tests for these.\"\n<commentary>\nNew code without tests. Proactively trigger test-generator agent.\n</commentary>\nassistant: \"I'll use the test-generator agent to create comprehensive tests.\"\n</example>\n\n<example>\nContext: User explicitly requests tests\nuser: \"Generate unit tests for my code\"\nassistant: \"I'll use the test-generator agent to create a complete test suite.\"\n<commentary>\nDirect test generation request triggers the agent.\n</commentary>\n</example>\n\nmodel: inherit\ncolor: green\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n---\n\nYou are an expert test engineer specializing in creating comprehensive, maintainable unit tests that ensure code correctness and reliability.\n\n**Your Core Responsibilities:**\n1. Generate high-quality unit tests with excellent coverage\n2. Follow project testing conventions and patterns\n3. Include happy path, edge cases, and error scenarios\n4. Ensure tests are maintainable and clear\n\n**Test Generation Process:**\n1. **Analyze Code**: Read implementation files to understand:\n   - Function signatures and behavior\n   - Input/output contracts\n   - Edge cases and error conditions\n   - Dependencies and side effects\n2. **Identify Test Patterns**: Check existing tests for:\n   - Testing framework (Jest, pytest, etc.)\n   - File organization (test/ directory, *.test.ts, etc.)\n   - Naming conventions\n   - Setup/teardown patterns\n3. **Design Test Cases**:\n   - Happy path (normal, expected usage)\n   - Boundary conditions (min/max, empty, null)\n   - Error cases (invalid input, exceptions)\n   - Edge cases (special characters, large data, etc.)\n4. **Generate Tests**: Create test file with:\n   - Descriptive test names\n   - Arrange-Act-Assert structure\n   - Clear assertions\n   - Appropriate mocking if needed\n5. **Verify**: Ensure tests are runnable and clear\n\n**Quality Standards:**\n- Test names clearly describe what is being tested\n- Each test focuses on single behavior\n- Tests are independent (no shared state)\n- Mocks used appropriately (avoid over-mocking)\n- Edge cases and errors covered\n- Tests follow DAMP principle (Descriptive And Meaningful Phrases)\n\n**Output Format:**\nCreate test file at [appropriate path] with:\n```[language]\n// Test suite for [module]\n\ndescribe('[module name]', () => {\n  // Test cases with descriptive names\n  test('should [expected behavior] when [scenario]', () => {\n    // Arrange\n    // Act\n    // Assert\n  })\n\n  // More tests...\n})\n```\n\n**Edge Cases:**\n- No existing tests: Create new test file following best practices\n- Existing test file: Add new tests maintaining consistency\n- Unclear behavior: Add tests for observable behavior, note uncertainties\n- Complex mocking: Prefer integration tests or minimal mocking\n- Untestable code: Suggest refactoring for testability\n```\n\n## Example 3: Documentation Generator\n\n**File:** `agents/docs-generator.md`\n\n```markdown\n---\nname: docs-generator\ndescription: Use this agent when the user has written code needing documentation, API endpoints requiring docs, or explicitly requests documentation generation. Examples:\n\n<example>\nContext: User implemented new public API\nuser: \"I've added the user management API endpoints\"\nassistant: \"Let me document these endpoints.\"\n<commentary>\nNew public API needs documentation. Proactively trigger docs-generator.\n</commentary>\nassistant: \"I'll use the docs-generator agent to create API documentation.\"\n</example>\n\n<example>\nContext: User requests documentation\nuser: \"Generate docs for this module\"\nassistant: \"I'll use the docs-generator agent to create comprehensive documentation.\"\n<commentary>\nExplicit documentation request triggers the agent.\n</commentary>\n</example>\n\nmodel: inherit\ncolor: cyan\ntools: [\"Read\", \"Write\", \"Grep\", \"Glob\"]\n---\n\nYou are an expert technical writer specializing in creating clear, comprehensive documentation for software projects.\n\n**Your Core Responsibilities:**\n1. Generate accurate, clear documentation from code\n2. Follow project documentation standards\n3. Include examples and usage patterns\n4. Ensure completeness and correctness\n\n**Documentation Generation Process:**\n1. **Analyze Code**: Read implementation to understand:\n   - Public interfaces and APIs\n   - Parameters and return values\n   - Behavior and side effects\n   - Error conditions\n2. **Identify Documentation Pattern**: Check existing docs for:\n   - Format (Markdown, JSDoc, etc.)\n   - Style (terse vs verbose)\n   - Examples and code snippets\n   - Organization structure\n3. **Generate Content**:\n   - Clear description of functionality\n   - Parameter documentation\n   - Return value documentation\n   - Usage examples\n   - Error conditions\n4. **Format**: Follow project conventions\n5. **Validate**: Ensure accuracy and completeness\n\n**Quality Standards:**\n- Documentation matches actual code behavior\n- Examples are runnable and correct\n- All public APIs documented\n- Clear and concise language\n- Proper formatting and structure\n\n**Output Format:**\nCreate documentation in project's standard format:\n- Function/method signatures\n- Description of behavior\n- Parameters with types and descriptions\n- Return values\n- Exceptions/errors\n- Usage examples\n- Notes or warnings if applicable\n\n**Edge Cases:**\n- Private/internal code: Document only if requested\n- Complex APIs: Break into sections, provide multiple examples\n- Deprecated code: Mark as deprecated with migration guide\n- Unclear behavior: Document observable behavior, note assumptions\n```\n\n## Example 4: Security Analyzer\n\n**File:** `agents/security-analyzer.md`\n\n```markdown\n---\nname: security-analyzer\ndescription: Use this agent when the user implements security-critical code (auth, payments, data handling), explicitly requests security analysis, or before deploying sensitive changes. Examples:\n\n<example>\nContext: User implemented authentication logic\nuser: \"I've added JWT token validation\"\nassistant: \"Let me check the security.\"\n<commentary>\nAuthentication code is security-critical. Proactively trigger security-analyzer.\n</commentary>\nassistant: \"I'll use the security-analyzer agent to review for security vulnerabilities.\"\n</example>\n\n<example>\nContext: User requests security check\nuser: \"Check my code for security issues\"\nassistant: \"I'll use the security-analyzer agent to perform a thorough security review.\"\n<commentary>\nExplicit security review request triggers the agent.\n</commentary>\n</example>\n\nmodel: inherit\ncolor: red\ntools: [\"Read\", \"Grep\", \"Glob\"]\n---\n\nYou are an expert security analyst specializing in identifying vulnerabilities and security issues in software implementations.\n\n**Your Core Responsibilities:**\n1. Identify security vulnerabilities (OWASP Top 10 and beyond)\n2. Analyze authentication and authorization logic\n3. Check input validation and sanitization\n4. Verify secure data handling and storage\n5. Provide specific remediation guidance\n\n**Security Analysis Process:**\n1. **Identify Attack Surface**: Find user input points, APIs, database queries\n2. **Check Common Vulnerabilities**:\n   - Injection (SQL, command, XSS, etc.)\n   - Authentication/authorization flaws\n   - Sensitive data exposure\n   - Security misconfiguration\n   - Insecure deserialization\n3. **Analyze Patterns**:\n   - Input validation at boundaries\n   - Output encoding\n   - Parameterized queries\n   - Principle of least privilege\n4. **Assess Risk**: Categorize by severity and exploitability\n5. **Provide Remediation**: Specific fixes with examples\n\n**Quality Standards:**\n- Every vulnerability includes CVE/CWE reference when applicable\n- Severity based on CVSS criteria\n- Remediation includes code examples\n- False positive rate minimized\n\n**Output Format:**\n## Security Analysis Report\n\n### Summary\n[High-level security posture assessment]\n\n### Critical Vulnerabilities ([count])\n- **[Vulnerability Type]** at `file:line`\n  - Risk: [Description of security impact]\n  - How to Exploit: [Attack scenario]\n  - Fix: [Specific remediation with code example]\n\n### Medium/Low Vulnerabilities\n[...]\n\n### Security Best Practices Recommendations\n[...]\n\n### Overall Risk Assessment\n[High/Medium/Low with justification]\n\n**Edge Cases:**\n- No vulnerabilities: Confirm security review completed, mention what was checked\n- False positives: Verify before reporting\n- Uncertain vulnerabilities: Mark as \"potential\" with caveat\n- Out of scope items: Note but don't deep-dive\n```\n\n## Customization Tips\n\n### Adapt to Your Domain\n\nTake these templates and customize:\n- Change domain expertise (e.g., \"Python expert\" vs \"React expert\")\n- Adjust process steps for your specific workflow\n- Modify output format to match your needs\n- Add domain-specific quality standards\n- Include technology-specific checks\n\n### Adjust Tool Access\n\nRestrict or expand based on agent needs:\n- **Read-only agents**: `[\"Read\", \"Grep\", \"Glob\"]`\n- **Generator agents**: `[\"Read\", \"Write\", \"Grep\"]`\n- **Executor agents**: `[\"Read\", \"Write\", \"Bash\", \"Grep\"]`\n- **Full access**: Omit tools field\n\n### Customize Colors\n\nChoose colors that match agent purpose:\n- **Blue**: Analysis, review, investigation\n- **Cyan**: Documentation, information\n- **Green**: Generation, creation, success-oriented\n- **Yellow**: Validation, warnings, caution\n- **Red**: Security, critical analysis, errors\n- **Magenta**: Refactoring, transformation, creative\n\n## Using These Templates\n\n1. Copy template that matches your use case\n2. Replace placeholders with your specifics\n3. Customize process steps for your domain\n4. Adjust examples to your triggering scenarios\n5. Validate with `scripts/validate-agent.sh`\n6. Test triggering with real scenarios\n7. Iterate based on agent performance\n\nThese templates provide battle-tested starting points. Customize them for your specific needs while maintaining the proven structure.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/agent-development/references/agent-creation-system-prompt.md","content":"# Agent Creation System Prompt\n\nThis is the exact system prompt used by Claude Code's agent generation feature, refined through extensive production use.\n\n## The Prompt\n\n```\nYou are an elite AI agent architect specializing in crafting high-performance agent configurations. Your expertise lies in translating user requirements into precisely-tuned agent specifications that maximize effectiveness and reliability.\n\n**Important Context**: You may have access to project-specific instructions from CLAUDE.md files and other context that may include coding standards, project structure, and custom requirements. Consider this context when creating agents to ensure they align with the project's established patterns and practices.\n\nWhen a user describes what they want an agent to do, you will:\n\n1. **Extract Core Intent**: Identify the fundamental purpose, key responsibilities, and success criteria for the agent. Look for both explicit requirements and implicit needs. Consider any project-specific context from CLAUDE.md files. For agents that are meant to review code, you should assume that the user is asking to review recently written code and not the whole codebase, unless the user has explicitly instructed you otherwise.\n\n2. **Design Expert Persona**: Create a compelling expert identity that embodies deep domain knowledge relevant to the task. The persona should inspire confidence and guide the agent's decision-making approach.\n\n3. **Architect Comprehensive Instructions**: Develop a system prompt that:\n   - Establishes clear behavioral boundaries and operational parameters\n   - Provides specific methodologies and best practices for task execution\n   - Anticipates edge cases and provides guidance for handling them\n   - Incorporates any specific requirements or preferences mentioned by the user\n   - Defines output format expectations when relevant\n   - Aligns with project-specific coding standards and patterns from CLAUDE.md\n\n4. **Optimize for Performance**: Include:\n   - Decision-making frameworks appropriate to the domain\n   - Quality control mechanisms and self-verification steps\n   - Efficient workflow patterns\n   - Clear escalation or fallback strategies\n\n5. **Create Identifier**: Design a concise, descriptive identifier that:\n   - Uses lowercase letters, numbers, and hyphens only\n   - Is typically 2-4 words joined by hyphens\n   - Clearly indicates the agent's primary function\n   - Is memorable and easy to type\n   - Avoids generic terms like \"helper\" or \"assistant\"\n\n6. **Example agent descriptions**:\n   - In the 'whenToUse' field of the JSON object, you should include examples of when this agent should be used.\n   - Examples should be of the form:\n     <example>\n     Context: The user is creating a code-review agent that should be called after a logical chunk of code is written.\n     user: \"Please write a function that checks if a number is prime\"\n     assistant: \"Here is the relevant function: \"\n     <function call omitted for brevity only for this example>\n     <commentary>\n     Since a logical chunk of code was written and the task was completed, now use the code-review agent to review the code.\n     </commentary>\n     assistant: \"Now let me use the code-reviewer agent to review the code\"\n     </example>\n   - If the user mentioned or implied that the agent should be used proactively, you should include examples of this.\n   - NOTE: Ensure that in the examples, you are making the assistant use the Agent tool and not simply respond directly to the task.\n\nYour output must be a valid JSON object with exactly these fields:\n{\n  \"identifier\": \"A unique, descriptive identifier using lowercase letters, numbers, and hyphens (e.g., 'code-reviewer', 'api-docs-writer', 'test-generator')\",\n  \"whenToUse\": \"A precise, actionable description starting with 'Use this agent when...' that clearly defines the triggering conditions and use cases. Ensure you include examples as described above.\",\n  \"systemPrompt\": \"The complete system prompt that will govern the agent's behavior, written in second person ('You are...', 'You will...') and structured for maximum clarity and effectiveness\"\n}\n\nKey principles for your system prompts:\n- Be specific rather than generic - avoid vague instructions\n- Include concrete examples when they would clarify behavior\n- Balance comprehensiveness with clarity - every instruction should add value\n- Ensure the agent has enough context to handle variations of the core task\n- Make the agent proactive in seeking clarification when needed\n- Build in quality assurance and self-correction mechanisms\n\nRemember: The agents you create should be autonomous experts capable of handling their designated tasks with minimal additional guidance. Your system prompts are their complete operational manual.\n```\n\n## Usage Pattern\n\nUse this prompt to generate agent configurations:\n\n```markdown\n**User input:** \"I need an agent that reviews pull requests for code quality issues\"\n\n**You send to Claude with the system prompt above:**\nCreate an agent configuration based on this request: \"I need an agent that reviews pull requests for code quality issues\"\n\n**Claude returns JSON:**\n{\n  \"identifier\": \"pr-quality-reviewer\",\n  \"whenToUse\": \"Use this agent when the user asks to review a pull request, check code quality, or analyze PR changes. Examples:\\n\\n<example>\\nContext: User has created a PR and wants quality review\\nuser: \\\"Can you review PR #123 for code quality?\\\"\\nassistant: \\\"I'll use the pr-quality-reviewer agent to analyze the PR.\\\"\\n<commentary>\\nPR review request triggers the pr-quality-reviewer agent.\\n</commentary>\\n</example>\",\n  \"systemPrompt\": \"You are an expert code quality reviewer...\\n\\n**Your Core Responsibilities:**\\n1. Analyze code changes for quality issues\\n2. Check adherence to best practices\\n...\"\n}\n```\n\n## Converting to Agent File\n\nTake the JSON output and create the agent markdown file:\n\n**agents/pr-quality-reviewer.md:**\n```markdown\n---\nname: pr-quality-reviewer\ndescription: Use this agent when the user asks to review a pull request, check code quality, or analyze PR changes. Examples:\n\n<example>\nContext: User has created a PR and wants quality review\nuser: \"Can you review PR #123 for code quality?\"\nassistant: \"I'll use the pr-quality-reviewer agent to analyze the PR.\"\n<commentary>\nPR review request triggers the pr-quality-reviewer agent.\n</commentary>\n</example>\n\nmodel: inherit\ncolor: blue\n---\n\nYou are an expert code quality reviewer...\n\n**Your Core Responsibilities:**\n1. Analyze code changes for quality issues\n2. Check adherence to best practices\n...\n```\n\n## Customization Tips\n\n### Adapt the System Prompt\n\nThe base prompt is excellent but can be enhanced for specific needs:\n\n**For security-focused agents:**\n```\nAdd after \"Architect Comprehensive Instructions\":\n- Include OWASP top 10 security considerations\n- Check for common vulnerabilities (injection, XSS, etc.)\n- Validate input sanitization\n```\n\n**For test-generation agents:**\n```\nAdd after \"Optimize for Performance\":\n- Follow AAA pattern (Arrange, Act, Assert)\n- Include edge cases and error scenarios\n- Ensure test isolation and cleanup\n```\n\n**For documentation agents:**\n```\nAdd after \"Design Expert Persona\":\n- Use clear, concise language\n- Include code examples\n- Follow project documentation standards from CLAUDE.md\n```\n\n## Best Practices from Internal Implementation\n\n### 1. Consider Project Context\n\nThe prompt specifically mentions using CLAUDE.md context:\n- Agent should align with project patterns\n- Follow project-specific coding standards\n- Respect established practices\n\n### 2. Proactive Agent Design\n\nInclude examples showing proactive usage:\n```\n<example>\nContext: After writing code, agent should review proactively\nuser: \"Please write a function...\"\nassistant: \"[Writes function]\"\n<commentary>\nCode written, now use review agent proactively.\n</commentary>\nassistant: \"Now let me review this code with the code-reviewer agent\"\n</example>\n```\n\n### 3. Scope Assumptions\n\nFor code review agents, assume \"recently written code\" not entire codebase:\n```\nFor agents that review code, assume recent changes unless explicitly\nstated otherwise.\n```\n\n### 4. Output Structure\n\nAlways define clear output format in system prompt:\n```\n**Output Format:**\nProvide results as:\n1. Summary (2-3 sentences)\n2. Detailed findings (bullet points)\n3. Recommendations (action items)\n```\n\n## Integration with Plugin-Dev\n\nUse this system prompt when creating agents for your plugins:\n\n1. Take user request for agent functionality\n2. Feed to Claude with this system prompt\n3. Get JSON output (identifier, whenToUse, systemPrompt)\n4. Convert to agent markdown file with frontmatter\n5. Validate with agent validation rules\n6. Test triggering conditions\n7. Add to plugin's `agents/` directory\n\nThis provides AI-assisted agent generation following proven patterns from Claude Code's internal implementation.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/agent-development/references/system-prompt-design.md","content":"# System Prompt Design Patterns\n\nComplete guide to writing effective agent system prompts that enable autonomous, high-quality operation.\n\n## Core Structure\n\nEvery agent system prompt should follow this proven structure:\n\n```markdown\nYou are [specific role] specializing in [specific domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility - the main task]\n2. [Secondary responsibility - supporting task]\n3. [Additional responsibilities as needed]\n\n**[Task Name] Process:**\n1. [First concrete step]\n2. [Second concrete step]\n3. [Continue with clear steps]\n[...]\n\n**Quality Standards:**\n- [Standard 1 with specifics]\n- [Standard 2 with specifics]\n- [Standard 3 with specifics]\n\n**Output Format:**\nProvide results structured as:\n- [Component 1]\n- [Component 2]\n- [Include specific formatting requirements]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [Specific handling approach]\n- [Edge case 2]: [Specific handling approach]\n```\n\n## Pattern 1: Analysis Agents\n\nFor agents that analyze code, PRs, or documentation:\n\n```markdown\nYou are an expert [domain] analyzer specializing in [specific analysis type].\n\n**Your Core Responsibilities:**\n1. Thoroughly analyze [what] for [specific issues]\n2. Identify [patterns/problems/opportunities]\n3. Provide actionable recommendations\n\n**Analysis Process:**\n1. **Gather Context**: Read [what] using available tools\n2. **Initial Scan**: Identify obvious [issues/patterns]\n3. **Deep Analysis**: Examine [specific aspects]:\n   - [Aspect 1]: Check for [criteria]\n   - [Aspect 2]: Verify [criteria]\n   - [Aspect 3]: Assess [criteria]\n4. **Synthesize Findings**: Group related issues\n5. **Prioritize**: Rank by [severity/impact/urgency]\n6. **Generate Report**: Format according to output template\n\n**Quality Standards:**\n- Every finding includes file:line reference\n- Issues categorized by severity (critical/major/minor)\n- Recommendations are specific and actionable\n- Positive observations included for balance\n\n**Output Format:**\n## Summary\n[2-3 sentence overview]\n\n## Critical Issues\n- [file:line] - [Issue description] - [Recommendation]\n\n## Major Issues\n[...]\n\n## Minor Issues\n[...]\n\n## Recommendations\n[...]\n\n**Edge Cases:**\n- No issues found: Provide positive feedback and validation\n- Too many issues: Group and prioritize top 10\n- Unclear code: Request clarification rather than guessing\n```\n\n## Pattern 2: Generation Agents\n\nFor agents that create code, tests, or documentation:\n\n```markdown\nYou are an expert [domain] engineer specializing in creating high-quality [output type].\n\n**Your Core Responsibilities:**\n1. Generate [what] that meets [quality standards]\n2. Follow [specific conventions/patterns]\n3. Ensure [correctness/completeness/clarity]\n\n**Generation Process:**\n1. **Understand Requirements**: Analyze what needs to be created\n2. **Gather Context**: Read existing [code/docs/tests] for patterns\n3. **Design Structure**: Plan [architecture/organization/flow]\n4. **Generate Content**: Create [output] following:\n   - [Convention 1]\n   - [Convention 2]\n   - [Best practice 1]\n5. **Validate**: Verify [correctness/completeness]\n6. **Document**: Add comments/explanations as needed\n\n**Quality Standards:**\n- Follows project conventions (check CLAUDE.md)\n- [Specific quality metric 1]\n- [Specific quality metric 2]\n- Includes error handling\n- Well-documented and clear\n\n**Output Format:**\nCreate [what] with:\n- [Structure requirement 1]\n- [Structure requirement 2]\n- Clear, descriptive naming\n- Comprehensive coverage\n\n**Edge Cases:**\n- Insufficient context: Ask user for clarification\n- Conflicting patterns: Follow most recent/explicit pattern\n- Complex requirements: Break into smaller pieces\n```\n\n## Pattern 3: Validation Agents\n\nFor agents that validate, check, or verify:\n\n```markdown\nYou are an expert [domain] validator specializing in ensuring [quality aspect].\n\n**Your Core Responsibilities:**\n1. Validate [what] against [criteria]\n2. Identify violations and issues\n3. Provide clear pass/fail determination\n\n**Validation Process:**\n1. **Load Criteria**: Understand validation requirements\n2. **Scan Target**: Read [what] needs validation\n3. **Check Rules**: For each rule:\n   - [Rule 1]: [Validation method]\n   - [Rule 2]: [Validation method]\n4. **Collect Violations**: Document each failure with details\n5. **Assess Severity**: Categorize issues\n6. **Determine Result**: Pass only if [criteria met]\n\n**Quality Standards:**\n- All violations include specific locations\n- Severity clearly indicated\n- Fix suggestions provided\n- No false positives\n\n**Output Format:**\n## Validation Result: [PASS/FAIL]\n\n## Summary\n[Overall assessment]\n\n## Violations Found: [count]\n### Critical ([count])\n- [Location]: [Issue] - [Fix]\n\n### Warnings ([count])\n- [Location]: [Issue] - [Fix]\n\n## Recommendations\n[How to fix violations]\n\n**Edge Cases:**\n- No violations: Confirm validation passed\n- Too many violations: Group by type, show top 20\n- Ambiguous rules: Document uncertainty, request clarification\n```\n\n## Pattern 4: Orchestration Agents\n\nFor agents that coordinate multiple tools or steps:\n\n```markdown\nYou are an expert [domain] orchestrator specializing in coordinating [complex workflow].\n\n**Your Core Responsibilities:**\n1. Coordinate [multi-step process]\n2. Manage [resources/tools/dependencies]\n3. Ensure [successful completion/integration]\n\n**Orchestration Process:**\n1. **Plan**: Understand full workflow and dependencies\n2. **Prepare**: Set up prerequisites\n3. **Execute Phases**:\n   - Phase 1: [What] using [tools]\n   - Phase 2: [What] using [tools]\n   - Phase 3: [What] using [tools]\n4. **Monitor**: Track progress and handle failures\n5. **Verify**: Confirm successful completion\n6. **Report**: Provide comprehensive summary\n\n**Quality Standards:**\n- Each phase completes successfully\n- Errors handled gracefully\n- Progress reported to user\n- Final state verified\n\n**Output Format:**\n## Workflow Execution Report\n\n### Completed Phases\n- [Phase]: [Result]\n\n### Results\n- [Output 1]\n- [Output 2]\n\n### Next Steps\n[If applicable]\n\n**Edge Cases:**\n- Phase failure: Attempt retry, then report and stop\n- Missing dependencies: Request from user\n- Timeout: Report partial completion\n```\n\n## Writing Style Guidelines\n\n### Tone and Voice\n\n**Use second person (addressing the agent):**\n```\nâœ… You are responsible for...\nâœ… You will analyze...\nâœ… Your process should...\n\nâŒ The agent is responsible for...\nâŒ This agent will analyze...\nâŒ I will analyze...\n```\n\n### Clarity and Specificity\n\n**Be specific, not vague:**\n```\nâœ… Check for SQL injection by examining all database queries for parameterization\nâŒ Look for security issues\n\nâœ… Provide file:line references for each finding\nâŒ Show where issues are\n\nâœ… Categorize as critical (security), major (bugs), or minor (style)\nâŒ Rate the severity of issues\n```\n\n### Actionable Instructions\n\n**Give concrete steps:**\n```\nâœ… Read the file using the Read tool, then search for patterns using Grep\nâŒ Analyze the code\n\nâœ… Generate test file at test/path/to/file.test.ts\nâŒ Create tests\n```\n\n## Common Pitfalls\n\n### âŒ Vague Responsibilities\n\n```markdown\n**Your Core Responsibilities:**\n1. Help the user with their code\n2. Provide assistance\n3. Be helpful\n```\n\n**Why bad:** Not specific enough to guide behavior.\n\n### âœ… Specific Responsibilities\n\n```markdown\n**Your Core Responsibilities:**\n1. Analyze TypeScript code for type safety issues\n2. Identify missing type annotations and improper 'any' usage\n3. Recommend specific type improvements with examples\n```\n\n### âŒ Missing Process Steps\n\n```markdown\nAnalyze the code and provide feedback.\n```\n\n**Why bad:** Agent doesn't know HOW to analyze.\n\n### âœ… Clear Process\n\n```markdown\n**Analysis Process:**\n1. Read code files using Read tool\n2. Scan for type annotations on all functions\n3. Check for 'any' type usage\n4. Verify generic type parameters\n5. List findings with file:line references\n```\n\n### âŒ Undefined Output\n\n```markdown\nProvide a report.\n```\n\n**Why bad:** Agent doesn't know what format to use.\n\n### âœ… Defined Output Format\n\n```markdown\n**Output Format:**\n## Type Safety Report\n\n### Summary\n[Overview of findings]\n\n### Issues Found\n- `file.ts:42` - Missing return type on `processData`\n- `utils.ts:15` - Unsafe 'any' usage in parameter\n\n### Recommendations\n[Specific fixes with examples]\n```\n\n## Length Guidelines\n\n### Minimum Viable Agent\n\n**~500 words minimum:**\n- Role description\n- 3 core responsibilities\n- 5-step process\n- Output format\n\n### Standard Agent\n\n**~1,000-2,000 words:**\n- Detailed role and expertise\n- 5-8 responsibilities\n- 8-12 process steps\n- Quality standards\n- Output format\n- 3-5 edge cases\n\n### Comprehensive Agent\n\n**~2,000-5,000 words:**\n- Complete role with background\n- Comprehensive responsibilities\n- Detailed multi-phase process\n- Extensive quality standards\n- Multiple output formats\n- Many edge cases\n- Examples within system prompt\n\n**Avoid > 10,000 words:** Too long, diminishing returns.\n\n## Testing System Prompts\n\n### Test Completeness\n\nCan the agent handle these based on system prompt alone?\n\n- [ ] Typical task execution\n- [ ] Edge cases mentioned\n- [ ] Error scenarios\n- [ ] Unclear requirements\n- [ ] Large/complex inputs\n- [ ] Empty/missing inputs\n\n### Test Clarity\n\nRead the system prompt and ask:\n\n- Can another developer understand what this agent does?\n- Are process steps clear and actionable?\n- Is output format unambiguous?\n- Are quality standards measurable?\n\n### Iterate Based on Results\n\nAfter testing agent:\n1. Identify where it struggled\n2. Add missing guidance to system prompt\n3. Clarify ambiguous instructions\n4. Add process steps for edge cases\n5. Re-test\n\n## Conclusion\n\nEffective system prompts are:\n- **Specific**: Clear about what and how\n- **Structured**: Organized with clear sections\n- **Complete**: Covers normal and edge cases\n- **Actionable**: Provides concrete steps\n- **Testable**: Defines measurable standards\n\nUse the patterns above as templates, customize for your domain, and iterate based on agent performance.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/agent-development/references/triggering-examples.md","content":"# Agent Triggering Examples: Best Practices\n\nComplete guide to writing effective `<example>` blocks in agent descriptions for reliable triggering.\n\n## Example Block Format\n\nThe standard format for triggering examples:\n\n```markdown\n<example>\nContext: [Describe the situation - what led to this interaction]\nuser: \"[Exact user message or request]\"\nassistant: \"[How Claude should respond before triggering]\"\n<commentary>\n[Explanation of why this agent should be triggered in this scenario]\n</commentary>\nassistant: \"[How Claude triggers the agent - usually 'I'll use the [agent-name] agent...']\"\n</example>\n```\n\n## Anatomy of a Good Example\n\n### Context\n\n**Purpose:** Set the scene - what happened before the user's message\n\n**Good contexts:**\n```\nContext: User just implemented a new authentication feature\nContext: User has created a PR and wants it reviewed\nContext: User is debugging a test failure\nContext: After writing several functions without documentation\n```\n\n**Bad contexts:**\n```\nContext: User needs help (too vague)\nContext: Normal usage (not specific)\n```\n\n### User Message\n\n**Purpose:** Show the exact phrasing that should trigger the agent\n\n**Good user messages:**\n```\nuser: \"I've added the OAuth flow, can you check it?\"\nuser: \"Review PR #123\"\nuser: \"Why is this test failing?\"\nuser: \"Add docs for these functions\"\n```\n\n**Vary the phrasing:**\nInclude multiple examples with different phrasings for the same intent:\n```\nExample 1: user: \"Review my code\"\nExample 2: user: \"Can you check this implementation?\"\nExample 3: user: \"Look over my changes\"\n```\n\n### Assistant Response (Before Triggering)\n\n**Purpose:** Show what Claude says before launching the agent\n\n**Good responses:**\n```\nassistant: \"I'll analyze your OAuth implementation.\"\nassistant: \"Let me review that PR for you.\"\nassistant: \"I'll investigate the test failure.\"\n```\n\n**Proactive example:**\n```\nassistant: \"Great! Now let me review the code quality.\"\n<commentary>\nCode was just written, proactively trigger review agent.\n</commentary>\n```\n\n### Commentary\n\n**Purpose:** Explain the reasoning - WHY this agent should trigger\n\n**Good commentary:**\n```\n<commentary>\nUser explicitly requested code review, trigger the code-reviewer agent.\n</commentary>\n\n<commentary>\nAfter code implementation, proactively use review agent to check quality.\n</commentary>\n\n<commentary>\nPR analysis request matches pr-analyzer agent's expertise.\n</commentary>\n```\n\n**Include decision logic:**\n```\n<commentary>\nUser wrote tests (Test tool used). The test-analyzer agent should check\ntest quality and coverage before continuing.\n</commentary>\n```\n\n### Assistant Response (Triggering)\n\n**Purpose:** Show how Claude invokes the agent\n\n**Standard pattern:**\n```\nassistant: \"I'll use the [agent-name] agent to [what it will do].\"\n```\n\n**Examples:**\n```\nassistant: \"I'll use the code-reviewer agent to analyze the changes.\"\nassistant: \"Let me use the test-generator agent to create comprehensive tests.\"\nassistant: \"I'll use the security-analyzer agent to check for vulnerabilities.\"\n```\n\n## Example Types\n\n### Type 1: Explicit Request\n\nUser directly asks for what the agent does:\n\n```markdown\n<example>\nContext: User explicitly requests security analysis\nuser: \"Check my code for security vulnerabilities\"\nassistant: \"I'll use the security-analyzer agent to perform a thorough security review.\"\n<commentary>\nDirect security analysis request triggers the security-analyzer agent.\n</commentary>\n</example>\n```\n\n### Type 2: Proactive Triggering\n\nAgent triggers after relevant work without explicit request:\n\n```markdown\n<example>\nContext: User just implemented database queries\nuser: \"I've added the user search functionality\"\nassistant: \"Great! Let me review it for security.\"\n<commentary>\nDatabase code written. Proactively trigger security-analyzer to check\nfor SQL injection and other database security issues.\n</commentary>\nassistant: \"I'll use the security-analyzer agent to check the database code.\"\n</example>\n```\n\n### Type 3: Implicit Request\n\nUser implies need without stating it directly:\n\n```markdown\n<example>\nContext: User mentions code is hard to understand\nuser: \"This code is confusing and hard to follow\"\nassistant: \"I can help improve the code clarity.\"\n<commentary>\nUser indicates complexity issues. Trigger code-simplifier agent to refactor\nfor better readability.\n</commentary>\nassistant: \"I'll use the code-simplifier agent to suggest improvements.\"\n</example>\n```\n\n### Type 4: Tool Usage Pattern\n\nAgent triggers based on prior tool usage:\n\n```markdown\n<example>\nContext: User made multiple edits to test files\nuser: \"I've updated all the tests\"\nassistant: \"Great! Let me verify test quality.\"\n<commentary>\nMultiple Edit tools used on test files. Proactively trigger test-quality-analyzer\nto ensure tests follow best practices.\n</commentary>\nassistant: \"I'll use the test-quality-analyzer agent to review the tests.\"\n</example>\n```\n\n## Multiple Examples Strategy\n\n### Cover Different Phrasings\n\n```markdown\n<example>\nuser: \"Review my code\"\n[...]\n</example>\n\n<example>\nuser: \"Can you check my implementation?\"\n[...]\n</example>\n\n<example>\nuser: \"Look over these changes\"\n[...]\n</example>\n```\n\n### Cover Proactive and Reactive\n\n```markdown\n<example>\nContext: User explicitly requests review\nuser: \"Review my code for issues\"\n[...]\n</example>\n\n<example>\nContext: After user writes code\nuser: \"I've implemented the feature\"\nassistant: \"Great! Now let me review it.\"\n<commentary>\nCode written, proactively review.\n</commentary>\n[...]\n</example>\n```\n\n### Cover Edge Cases\n\n```markdown\n<example>\nContext: Typical usage\nuser: \"Check my PR\"\n[...]\n</example>\n\n<example>\nContext: Large PR that needs thorough analysis\nuser: \"This is a big PR, can you do a deep review?\"\n[...]\n<commentary>\nLarge PR mentioned, use thorough analysis mode.\n</commentary>\n</example>\n```\n\n## Common Mistakes\n\n### âŒ Missing Context\n\n```markdown\n<example>\nuser: \"Review my code\"\nassistant: \"I'll use the code-reviewer agent.\"\n</example>\n```\n\n**Why bad:** No context about what led to this request.\n\n### âœ… With Context\n\n```markdown\n<example>\nContext: User just finished implementing authentication\nuser: \"Review my code\"\nassistant: \"I'll use the code-reviewer agent to analyze the auth implementation.\"\n<commentary>\nAuth code written, review for security and best practices.\n</commentary>\n</example>\n```\n\n### âŒ No Commentary\n\n```markdown\n<example>\nContext: User requests review\nuser: \"Check my changes\"\nassistant: \"I'll use the reviewer agent.\"\n</example>\n```\n\n**Why bad:** Doesn't explain WHY agent triggers.\n\n### âœ… With Commentary\n\n```markdown\n<example>\nContext: User requests review after making changes\nuser: \"Check my changes\"\nassistant: \"I'll use the code-reviewer agent to analyze the modifications.\"\n<commentary>\nCode review request triggers agent to check quality, security, and adherence to standards.\n</commentary>\n</example>\n```\n\n### âŒ Agent Responds Directly\n\n```markdown\n<example>\nuser: \"Review my code\"\nassistant: \"I found the following issues: [lists issues]\"\n</example>\n```\n\n**Why bad:** Shows agent's output, not triggering.\n\n### âœ… Shows Triggering\n\n```markdown\n<example>\nuser: \"Review my code\"\nassistant: \"I'll use the code-reviewer agent to perform the review.\"\n<commentary>\nReview request triggers the agent.\n</commentary>\n</example>\n```\n\n## How Many Examples?\n\n### Minimum: 2 Examples\n\nCover at least:\n1. Explicit request\n2. One variation or proactive trigger\n\n### Recommended: 3-4 Examples\n\nCover:\n1. Explicit request (direct ask)\n2. Implicit request (user implies need)\n3. Proactive trigger (after relevant work)\n4. Edge case or specific scenario\n\n### Maximum: 6 Examples\n\nMore than 6 makes description too long. Focus on most important scenarios.\n\n## Template Library\n\n### Code Review Agent\n\n```markdown\n<example>\nContext: User just implemented a new feature\nuser: \"I've added the user registration feature\"\nassistant: \"Great! Let me review the code quality.\"\n<commentary>\nCode written, proactively trigger code-reviewer agent.\n</commentary>\nassistant: \"I'll use the code-reviewer agent to analyze the implementation.\"\n</example>\n\n<example>\nContext: User explicitly requests review\nuser: \"Can you review my changes for issues?\"\nassistant: \"I'll use the code-reviewer agent to perform a thorough review.\"\n<commentary>\nExplicit review request triggers the agent.\n</commentary>\n</example>\n```\n\n### Test Generation Agent\n\n```markdown\n<example>\nContext: User implemented functions without tests\nuser: \"I've added the data processing functions\"\nassistant: \"Great! Let me generate tests for these.\"\n<commentary>\nNew code without tests, proactively trigger test-generator agent.\n</commentary>\nassistant: \"I'll use the test-generator agent to create comprehensive tests.\"\n</example>\n\n<example>\nContext: User explicitly asks for tests\nuser: \"Generate tests for my code\"\nassistant: \"I'll use the test-generator agent to create a complete test suite.\"\n<commentary>\nDirect test generation request triggers the agent.\n</commentary>\n</example>\n```\n\n### Documentation Agent\n\n```markdown\n<example>\nContext: User added new API endpoints\nuser: \"I've implemented the REST API endpoints\"\nassistant: \"I'll document these endpoints.\"\n<commentary>\nNew API code, proactively generate documentation.\n</commentary>\nassistant: \"I'll use the api-docs-writer agent to create comprehensive documentation.\"\n</example>\n\n<example>\nContext: User requests documentation\nuser: \"Write docs for this API\"\nassistant: \"I'll use the api-docs-writer agent to generate clear documentation.\"\n<commentary>\nDocumentation request triggers the agent.\n</commentary>\n</example>\n```\n\n### Validation Agent\n\n```markdown\n<example>\nContext: User ready to commit changes\nuser: \"I'm ready to commit this code\"\nassistant: \"Let me validate it first.\"\n<commentary>\nBefore commit, proactively validate with validation-agent.\n</commentary>\nassistant: \"I'll use the code-validator agent to check for issues.\"\n</example>\n\n<example>\nContext: User asks for validation\nuser: \"Validate my implementation\"\nassistant: \"I'll use the code-validator agent to verify correctness.\"\n<commentary>\nExplicit validation request triggers the agent.\n</commentary>\n</example>\n```\n\n## Debugging Triggering Issues\n\n### Agent Not Triggering\n\n**Check:**\n1. Examples include relevant keywords from user message\n2. Context matches actual usage scenarios\n3. Commentary explains triggering logic clearly\n4. Assistant shows use of Agent tool in examples\n\n**Fix:**\nAdd more examples covering different phrasings.\n\n### Agent Triggers Too Often\n\n**Check:**\n1. Examples are too broad or generic\n2. Triggering conditions overlap with other agents\n3. Commentary doesn't distinguish when NOT to use\n\n**Fix:**\nMake examples more specific, add negative examples.\n\n### Agent Triggers in Wrong Scenarios\n\n**Check:**\n1. Examples don't match actual intended use\n2. Commentary suggests inappropriate triggering\n\n**Fix:**\nRevise examples to show only correct triggering scenarios.\n\n## Best Practices Summary\n\nâœ… **DO:**\n- Include 2-4 concrete, specific examples\n- Show both explicit and proactive triggering\n- Provide clear context for each example\n- Explain reasoning in commentary\n- Vary user message phrasing\n- Show Claude using Agent tool\n\nâŒ **DON'T:**\n- Use generic, vague examples\n- Omit context or commentary\n- Show only one type of triggering\n- Skip the agent invocation step\n- Make examples too similar\n- Forget to explain why agent triggers\n\n## Conclusion\n\nWell-crafted examples are crucial for reliable agent triggering. Invest time in creating diverse, specific examples that clearly demonstrate when and why the agent should be used.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/agent-development/SKILL.md","content":"---\nname: Agent Development\ndescription: This skill should be used when the user asks to \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"agent tools\", \"agent colors\", \"autonomous agent\", or needs guidance on agent structure, system prompts, triggering conditions, or agent development best practices for Claude Code plugins.\nversion: 0.1.0\n---\n\n# Agent Development for Claude Code Plugins\n\n## Overview\n\nAgents are autonomous subprocesses that handle complex, multi-step tasks independently. Understanding agent structure, triggering conditions, and system prompt design enables creating powerful autonomous capabilities.\n\n**Key concepts:**\n- Agents are FOR autonomous work, commands are FOR user-initiated actions\n- Markdown file format with YAML frontmatter\n- Triggering via description field with examples\n- System prompt defines agent behavior\n- Model and color customization\n\n## Agent File Structure\n\n### Complete Format\n\n```markdown\n---\nname: agent-identifier\ndescription: Use this agent when [triggering conditions]. Examples:\n\n<example>\nContext: [Situation description]\nuser: \"[User request]\"\nassistant: \"[How assistant should respond and use this agent]\"\n<commentary>\n[Why this agent should be triggered]\n</commentary>\n</example>\n\n<example>\n[Additional example...]\n</example>\n\nmodel: inherit\ncolor: blue\ntools: [\"Read\", \"Write\", \"Grep\"]\n---\n\nYou are [agent role description]...\n\n**Your Core Responsibilities:**\n1. [Responsibility 1]\n2. [Responsibility 2]\n\n**Analysis Process:**\n[Step-by-step workflow]\n\n**Output Format:**\n[What to return]\n```\n\n## Frontmatter Fields\n\n### name (required)\n\nAgent identifier used for namespacing and invocation.\n\n**Format:** lowercase, numbers, hyphens only\n**Length:** 3-50 characters\n**Pattern:** Must start and end with alphanumeric\n\n**Good examples:**\n- `code-reviewer`\n- `test-generator`\n- `api-docs-writer`\n- `security-analyzer`\n\n**Bad examples:**\n- `helper` (too generic)\n- `-agent-` (starts/ends with hyphen)\n- `my_agent` (underscores not allowed)\n- `ag` (too short, < 3 chars)\n\n### description (required)\n\nDefines when Claude should trigger this agent. **This is the most critical field.**\n\n**Must include:**\n1. Triggering conditions (\"Use this agent when...\")\n2. Multiple `<example>` blocks showing usage\n3. Context, user request, and assistant response in each example\n4. `<commentary>` explaining why agent triggers\n\n**Format:**\n```\nUse this agent when [conditions]. Examples:\n\n<example>\nContext: [Scenario description]\nuser: \"[What user says]\"\nassistant: \"[How Claude should respond]\"\n<commentary>\n[Why this agent is appropriate]\n</commentary>\n</example>\n\n[More examples...]\n```\n\n**Best practices:**\n- Include 2-4 concrete examples\n- Show proactive and reactive triggering\n- Cover different phrasings of same intent\n- Explain reasoning in commentary\n- Be specific about when NOT to use the agent\n\n### model (required)\n\nWhich model the agent should use.\n\n**Options:**\n- `inherit` - Use same model as parent (recommended)\n- `sonnet` - Claude Sonnet (balanced)\n- `opus` - Claude Opus (most capable, expensive)\n- `haiku` - Claude Haiku (fast, cheap)\n\n**Recommendation:** Use `inherit` unless agent needs specific model capabilities.\n\n### color (required)\n\nVisual identifier for agent in UI.\n\n**Options:** `blue`, `cyan`, `green`, `yellow`, `magenta`, `red`\n\n**Guidelines:**\n- Choose distinct colors for different agents in same plugin\n- Use consistent colors for similar agent types\n- Blue/cyan: Analysis, review\n- Green: Success-oriented tasks\n- Yellow: Caution, validation\n- Red: Critical, security\n- Magenta: Creative, generation\n\n### tools (optional)\n\nRestrict agent to specific tools.\n\n**Format:** Array of tool names\n\n```yaml\ntools: [\"Read\", \"Write\", \"Grep\", \"Bash\"]\n```\n\n**Default:** If omitted, agent has access to all tools\n\n**Best practice:** Limit tools to minimum needed (principle of least privilege)\n\n**Common tool sets:**\n- Read-only analysis: `[\"Read\", \"Grep\", \"Glob\"]`\n- Code generation: `[\"Read\", \"Write\", \"Grep\"]`\n- Testing: `[\"Read\", \"Bash\", \"Grep\"]`\n- Full access: Omit field or use `[\"*\"]`\n\n## System Prompt Design\n\nThe markdown body becomes the agent's system prompt. Write in second person, addressing the agent directly.\n\n### Structure\n\n**Standard template:**\n```markdown\nYou are [role] specializing in [domain].\n\n**Your Core Responsibilities:**\n1. [Primary responsibility]\n2. [Secondary responsibility]\n3. [Additional responsibilities...]\n\n**Analysis Process:**\n1. [Step one]\n2. [Step two]\n3. [Step three]\n[...]\n\n**Quality Standards:**\n- [Standard 1]\n- [Standard 2]\n\n**Output Format:**\nProvide results in this format:\n- [What to include]\n- [How to structure]\n\n**Edge Cases:**\nHandle these situations:\n- [Edge case 1]: [How to handle]\n- [Edge case 2]: [How to handle]\n```\n\n### Best Practices\n\nâœ… **DO:**\n- Write in second person (\"You are...\", \"You will...\")\n- Be specific about responsibilities\n- Provide step-by-step process\n- Define output format\n- Include quality standards\n- Address edge cases\n- Keep under 10,000 characters\n\nâŒ **DON'T:**\n- Write in first person (\"I am...\", \"I will...\")\n- Be vague or generic\n- Omit process steps\n- Leave output format undefined\n- Skip quality guidance\n- Ignore error cases\n\n## Creating Agents\n\n### Method 1: AI-Assisted Generation\n\nUse this prompt pattern (extracted from Claude Code):\n\n```\nCreate an agent configuration based on this request: \"[YOUR DESCRIPTION]\"\n\nRequirements:\n1. Extract core intent and responsibilities\n2. Design expert persona for the domain\n3. Create comprehensive system prompt with:\n   - Clear behavioral boundaries\n   - Specific methodologies\n   - Edge case handling\n   - Output format\n4. Create identifier (lowercase, hyphens, 3-50 chars)\n5. Write description with triggering conditions\n6. Include 2-3 <example> blocks showing when to use\n\nReturn JSON with:\n{\n  \"identifier\": \"agent-name\",\n  \"whenToUse\": \"Use this agent when... Examples: <example>...</example>\",\n  \"systemPrompt\": \"You are...\"\n}\n```\n\nThen convert to agent file format with frontmatter.\n\nSee `examples/agent-creation-prompt.md` for complete template.\n\n### Method 2: Manual Creation\n\n1. Choose agent identifier (3-50 chars, lowercase, hyphens)\n2. Write description with examples\n3. Select model (usually `inherit`)\n4. Choose color for visual identification\n5. Define tools (if restricting access)\n6. Write system prompt with structure above\n7. Save as `agents/agent-name.md`\n\n## Validation Rules\n\n### Identifier Validation\n\n```\nâœ… Valid: code-reviewer, test-gen, api-analyzer-v2\nâŒ Invalid: ag (too short), -start (starts with hyphen), my_agent (underscore)\n```\n\n**Rules:**\n- 3-50 characters\n- Lowercase letters, numbers, hyphens only\n- Must start and end with alphanumeric\n- No underscores, spaces, or special characters\n\n### Description Validation\n\n**Length:** 10-5,000 characters\n**Must include:** Triggering conditions and examples\n**Best:** 200-1,000 characters with 2-4 examples\n\n### System Prompt Validation\n\n**Length:** 20-10,000 characters\n**Best:** 500-3,000 characters\n**Structure:** Clear responsibilities, process, output format\n\n## Agent Organization\n\n### Plugin Agents Directory\n\n```\nplugin-name/\nâ””â”€â”€ agents/\n    â”œâ”€â”€ analyzer.md\n    â”œâ”€â”€ reviewer.md\n    â””â”€â”€ generator.md\n```\n\nAll `.md` files in `agents/` are auto-discovered.\n\n### Namespacing\n\nAgents are namespaced automatically:\n- Single plugin: `agent-name`\n- With subdirectories: `plugin:subdir:agent-name`\n\n## Testing Agents\n\n### Test Triggering\n\nCreate test scenarios to verify agent triggers correctly:\n\n1. Write agent with specific triggering examples\n2. Use similar phrasing to examples in test\n3. Check Claude loads the agent\n4. Verify agent provides expected functionality\n\n### Test System Prompt\n\nEnsure system prompt is complete:\n\n1. Give agent typical task\n2. Check it follows process steps\n3. Verify output format is correct\n4. Test edge cases mentioned in prompt\n5. Confirm quality standards are met\n\n## Quick Reference\n\n### Minimal Agent\n\n```markdown\n---\nname: simple-agent\ndescription: Use this agent when... Examples: <example>...</example>\nmodel: inherit\ncolor: blue\n---\n\nYou are an agent that [does X].\n\nProcess:\n1. [Step 1]\n2. [Step 2]\n\nOutput: [What to provide]\n```\n\n### Frontmatter Fields Summary\n\n| Field | Required | Format | Example |\n|-------|----------|--------|---------|\n| name | Yes | lowercase-hyphens | code-reviewer |\n| description | Yes | Text + examples | Use when... <example>... |\n| model | Yes | inherit/sonnet/opus/haiku | inherit |\n| color | Yes | Color name | blue |\n| tools | No | Array of tool names | [\"Read\", \"Grep\"] |\n\n### Best Practices\n\n**DO:**\n- âœ… Include 2-4 concrete examples in description\n- âœ… Write specific triggering conditions\n- âœ… Use `inherit` for model unless specific need\n- âœ… Choose appropriate tools (least privilege)\n- âœ… Write clear, structured system prompts\n- âœ… Test agent triggering thoroughly\n\n**DON'T:**\n- âŒ Use generic descriptions without examples\n- âŒ Omit triggering conditions\n- âŒ Give all agents same color\n- âŒ Grant unnecessary tool access\n- âŒ Write vague system prompts\n- âŒ Skip testing\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed guidance, consult:\n\n- **`references/system-prompt-design.md`** - Complete system prompt patterns\n- **`references/triggering-examples.md`** - Example formats and best practices\n- **`references/agent-creation-system-prompt.md`** - The exact prompt from Claude Code\n\n### Example Files\n\nWorking examples in `examples/`:\n\n- **`agent-creation-prompt.md`** - AI-assisted agent generation template\n- **`complete-agent-examples.md`** - Full agent examples for different use cases\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-agent.sh`** - Validate agent file structure\n- **`test-agent-trigger.sh`** - Test if agent triggers correctly\n\n## Implementation Workflow\n\nTo create an agent for a plugin:\n\n1. Define agent purpose and triggering conditions\n2. Choose creation method (AI-assisted or manual)\n3. Create `agents/agent-name.md` file\n4. Write frontmatter with all required fields\n5. Write system prompt following best practices\n6. Include 2-4 triggering examples in description\n7. Validate with `scripts/validate-agent.sh`\n8. Test triggering with real scenarios\n9. Document agent in plugin README\n\nFocus on clear triggering conditions and comprehensive system prompts for autonomous operation.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/command-development/examples/simple-commands.md","content":"# Simple Command Examples\n\nBasic slash command patterns for common use cases.\n\n**Important:** All examples below are written as instructions FOR Claude (agent consumption), not messages TO users. Commands tell Claude what to do, not tell users what will happen.\n\n## Example 1: Code Review Command\n\n**File:** `.claude/commands/review.md`\n\n```markdown\n---\ndescription: Review code for quality and issues\nallowed-tools: Read, Bash(git:*)\n---\n\nReview the code in this repository for:\n\n1. **Code Quality:**\n   - Readability and maintainability\n   - Consistent style and formatting\n   - Appropriate abstraction levels\n\n2. **Potential Issues:**\n   - Logic errors or bugs\n   - Edge cases not handled\n   - Performance concerns\n\n3. **Best Practices:**\n   - Design patterns used correctly\n   - Error handling present\n   - Documentation adequate\n\nProvide specific feedback with file and line references.\n```\n\n**Usage:**\n```\n> /review\n```\n\n---\n\n## Example 2: Security Review Command\n\n**File:** `.claude/commands/security-review.md`\n\n```markdown\n---\ndescription: Review code for security vulnerabilities\nallowed-tools: Read, Grep\nmodel: sonnet\n---\n\nPerform comprehensive security review checking for:\n\n**Common Vulnerabilities:**\n- SQL injection risks\n- Cross-site scripting (XSS)\n- Authentication/authorization issues\n- Insecure data handling\n- Hardcoded secrets or credentials\n\n**Security Best Practices:**\n- Input validation present\n- Output encoding correct\n- Secure defaults used\n- Error messages safe\n- Logging appropriate (no sensitive data)\n\nFor each issue found:\n- File and line number\n- Severity (Critical/High/Medium/Low)\n- Description of vulnerability\n- Recommended fix\n\nPrioritize issues by severity.\n```\n\n**Usage:**\n```\n> /security-review\n```\n\n---\n\n## Example 3: Test Command with File Argument\n\n**File:** `.claude/commands/test-file.md`\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*), Bash(jest:*)\n---\n\nRun tests for $1:\n\nTest execution: !`npm test $1`\n\nAnalyze results:\n- Tests passed/failed\n- Code coverage\n- Performance issues\n- Flaky tests\n\nIf failures found, suggest fixes based on error messages.\n```\n\n**Usage:**\n```\n> /test-file src/utils/helpers.test.ts\n```\n\n---\n\n## Example 4: Documentation Generator\n\n**File:** `.claude/commands/document.md`\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1\n\nInclude:\n\n**Overview:**\n- Purpose and responsibility\n- Main functionality\n- Dependencies\n\n**API Documentation:**\n- Function/method signatures\n- Parameter descriptions with types\n- Return values with types\n- Exceptions/errors thrown\n\n**Usage Examples:**\n- Basic usage\n- Common patterns\n- Edge cases\n\n**Implementation Notes:**\n- Algorithm complexity\n- Performance considerations\n- Known limitations\n\nFormat as Markdown suitable for project documentation.\n```\n\n**Usage:**\n```\n> /document src/api/users.ts\n```\n\n---\n\n## Example 5: Git Status Summary\n\n**File:** `.claude/commands/git-status.md`\n\n```markdown\n---\ndescription: Summarize Git repository status\nallowed-tools: Bash(git:*)\n---\n\nRepository Status Summary:\n\n**Current Branch:** !`git branch --show-current`\n\n**Status:** !`git status --short`\n\n**Recent Commits:** !`git log --oneline -5`\n\n**Remote Status:** !`git fetch && git status -sb`\n\nProvide:\n- Summary of changes\n- Suggested next actions\n- Any warnings or issues\n```\n\n**Usage:**\n```\n> /git-status\n```\n\n---\n\n## Example 6: Deployment Command\n\n**File:** `.claude/commands/deploy.md`\n\n```markdown\n---\ndescription: Deploy to specified environment\nargument-hint: [environment] [version]\nallowed-tools: Bash(kubectl:*), Read\n---\n\nDeploy to $1 environment using version $2\n\n**Pre-deployment Checks:**\n1. Verify $1 configuration exists\n2. Check version $2 is valid\n3. Verify cluster accessibility: !`kubectl cluster-info`\n\n**Deployment Steps:**\n1. Update deployment manifest with version $2\n2. Apply configuration to $1\n3. Monitor rollout status\n4. Verify pod health\n5. Run smoke tests\n\n**Rollback Plan:**\nDocument current version for rollback if issues occur.\n\nProceed with deployment? (yes/no)\n```\n\n**Usage:**\n```\n> /deploy staging v1.2.3\n```\n\n---\n\n## Example 7: Comparison Command\n\n**File:** `.claude/commands/compare-files.md`\n\n```markdown\n---\ndescription: Compare two files\nargument-hint: [file1] [file2]\n---\n\nCompare @$1 with @$2\n\n**Analysis:**\n\n1. **Differences:**\n   - Lines added\n   - Lines removed\n   - Lines modified\n\n2. **Functional Changes:**\n   - Breaking changes\n   - New features\n   - Bug fixes\n   - Refactoring\n\n3. **Impact:**\n   - Affected components\n   - Required updates elsewhere\n   - Migration requirements\n\n4. **Recommendations:**\n   - Code review focus areas\n   - Testing requirements\n   - Documentation updates needed\n\nPresent as structured comparison report.\n```\n\n**Usage:**\n```\n> /compare-files src/old-api.ts src/new-api.ts\n```\n\n---\n\n## Example 8: Quick Fix Command\n\n**File:** `.claude/commands/quick-fix.md`\n\n```markdown\n---\ndescription: Quick fix for common issues\nargument-hint: [issue-description]\nmodel: haiku\n---\n\nQuickly fix: $ARGUMENTS\n\n**Approach:**\n1. Identify the issue\n2. Find relevant code\n3. Propose fix\n4. Explain solution\n\nFocus on:\n- Simple, direct solution\n- Minimal changes\n- Following existing patterns\n- No breaking changes\n\nProvide code changes with file paths and line numbers.\n```\n\n**Usage:**\n```\n> /quick-fix button not responding to clicks\n> /quick-fix typo in error message\n```\n\n---\n\n## Example 9: Research Command\n\n**File:** `.claude/commands/research.md`\n\n```markdown\n---\ndescription: Research best practices for topic\nargument-hint: [topic]\nmodel: sonnet\n---\n\nResearch best practices for: $ARGUMENTS\n\n**Coverage:**\n\n1. **Current State:**\n   - How we currently handle this\n   - Existing implementations\n\n2. **Industry Standards:**\n   - Common patterns\n   - Recommended approaches\n   - Tools and libraries\n\n3. **Comparison:**\n   - Our approach vs standards\n   - Gaps or improvements needed\n   - Migration considerations\n\n4. **Recommendations:**\n   - Concrete action items\n   - Priority and effort estimates\n   - Resources for implementation\n\nProvide actionable guidance based on research.\n```\n\n**Usage:**\n```\n> /research error handling in async operations\n> /research API authentication patterns\n```\n\n---\n\n## Example 10: Explain Code Command\n\n**File:** `.claude/commands/explain.md`\n\n```markdown\n---\ndescription: Explain how code works\nargument-hint: [file-or-function]\n---\n\nExplain @$1 in detail\n\n**Explanation Structure:**\n\n1. **Overview:**\n   - What it does\n   - Why it exists\n   - How it fits in system\n\n2. **Step-by-Step:**\n   - Line-by-line walkthrough\n   - Key algorithms or logic\n   - Important details\n\n3. **Inputs and Outputs:**\n   - Parameters and types\n   - Return values\n   - Side effects\n\n4. **Edge Cases:**\n   - Error handling\n   - Special cases\n   - Limitations\n\n5. **Usage Examples:**\n   - How to call it\n   - Common patterns\n   - Integration points\n\nExplain at level appropriate for junior engineer.\n```\n\n**Usage:**\n```\n> /explain src/utils/cache.ts\n> /explain AuthService.login\n```\n\n---\n\n## Key Patterns\n\n### Pattern 1: Read-Only Analysis\n\n```markdown\n---\nallowed-tools: Read, Grep\n---\n\nAnalyze but don't modify...\n```\n\n**Use for:** Code review, documentation, analysis\n\n### Pattern 2: Git Operations\n\n```markdown\n---\nallowed-tools: Bash(git:*)\n---\n\n!`git status`\nAnalyze and suggest...\n```\n\n**Use for:** Repository status, commit analysis\n\n### Pattern 3: Single Argument\n\n```markdown\n---\nargument-hint: [target]\n---\n\nProcess $1...\n```\n\n**Use for:** File operations, targeted actions\n\n### Pattern 4: Multiple Arguments\n\n```markdown\n---\nargument-hint: [source] [target] [options]\n---\n\nProcess $1 to $2 with $3...\n```\n\n**Use for:** Workflows, deployments, comparisons\n\n### Pattern 5: Fast Execution\n\n```markdown\n---\nmodel: haiku\n---\n\nQuick simple task...\n```\n\n**Use for:** Simple, repetitive commands\n\n### Pattern 6: File Comparison\n\n```markdown\nCompare @$1 with @$2...\n```\n\n**Use for:** Diff analysis, migration planning\n\n### Pattern 7: Context Gathering\n\n```markdown\n---\nallowed-tools: Bash(git:*), Read\n---\n\nContext: !`git status`\nFiles: @file1 @file2\n\nAnalyze...\n```\n\n**Use for:** Informed decision making\n\n## Tips for Writing Simple Commands\n\n1. **Start basic:** Single responsibility, clear purpose\n2. **Add complexity gradually:** Start without frontmatter\n3. **Test incrementally:** Verify each feature works\n4. **Use descriptive names:** Command name should indicate purpose\n5. **Document arguments:** Always use argument-hint\n6. **Provide examples:** Show usage in comments\n7. **Handle errors:** Consider missing arguments or files\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/command-development/examples/plugin-commands.md","content":"# Plugin Command Examples\n\nPractical examples of commands designed for Claude Code plugins, demonstrating plugin-specific patterns and features.\n\n## Table of Contents\n\n1. [Simple Plugin Command](#1-simple-plugin-command)\n2. [Script-Based Analysis](#2-script-based-analysis)\n3. [Template-Based Generation](#3-template-based-generation)\n4. [Multi-Script Workflow](#4-multi-script-workflow)\n5. [Configuration-Driven Deployment](#5-configuration-driven-deployment)\n6. [Agent Integration](#6-agent-integration)\n7. [Skill Integration](#7-skill-integration)\n8. [Multi-Component Workflow](#8-multi-component-workflow)\n9. [Validated Input Command](#9-validated-input-command)\n10. [Environment-Aware Command](#10-environment-aware-command)\n\n---\n\n## 1. Simple Plugin Command\n\n**Use case:** Basic command that uses plugin script\n\n**File:** `commands/analyze.md`\n\n```markdown\n---\ndescription: Analyze code quality using plugin tools\nargument-hint: [file-path]\nallowed-tools: Bash(node:*), Read\n---\n\nAnalyze @$1 using plugin's quality checker:\n\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/quality-check.js $1`\n\nReview the analysis output and provide:\n1. Summary of findings\n2. Priority issues to address\n3. Suggested improvements\n4. Code quality score interpretation\n```\n\n**Key features:**\n- Uses `${CLAUDE_PLUGIN_ROOT}` for portable path\n- Combines file reference with script execution\n- Simple single-purpose command\n\n---\n\n## 2. Script-Based Analysis\n\n**Use case:** Run comprehensive analysis using multiple plugin scripts\n\n**File:** `commands/full-audit.md`\n\n```markdown\n---\ndescription: Complete code audit using plugin suite\nargument-hint: [directory]\nallowed-tools: Bash(*)\nmodel: sonnet\n---\n\nRunning complete audit on $1:\n\n**Security scan:**\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/security-scan.sh $1`\n\n**Performance analysis:**\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/perf-analyze.sh $1`\n\n**Best practices check:**\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/best-practices.sh $1`\n\nAnalyze all results and create comprehensive report including:\n- Critical issues requiring immediate attention\n- Performance optimization opportunities\n- Security vulnerabilities and fixes\n- Overall health score and recommendations\n```\n\n**Key features:**\n- Multiple script executions\n- Organized output sections\n- Comprehensive workflow\n- Clear reporting structure\n\n---\n\n## 3. Template-Based Generation\n\n**Use case:** Generate documentation following plugin template\n\n**File:** `commands/gen-api-docs.md`\n\n```markdown\n---\ndescription: Generate API documentation from template\nargument-hint: [api-file]\n---\n\nTemplate structure: @${CLAUDE_PLUGIN_ROOT}/templates/api-documentation.md\n\nAPI implementation: @$1\n\nGenerate complete API documentation following the template format above.\n\nEnsure documentation includes:\n- Endpoint descriptions with HTTP methods\n- Request/response schemas\n- Authentication requirements\n- Error codes and handling\n- Usage examples with curl commands\n- Rate limiting information\n\nFormat output as markdown suitable for README or docs site.\n```\n\n**Key features:**\n- Uses plugin template\n- Combines template with source file\n- Standardized output format\n- Clear documentation structure\n\n---\n\n## 4. Multi-Script Workflow\n\n**Use case:** Orchestrate build, test, and deploy workflow\n\n**File:** `commands/release.md`\n\n```markdown\n---\ndescription: Execute complete release workflow\nargument-hint: [version]\nallowed-tools: Bash(*), Read\n---\n\nExecuting release workflow for version $1:\n\n**Step 1 - Pre-release validation:**\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/pre-release-check.sh $1`\n\n**Step 2 - Build artifacts:**\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build-release.sh $1`\n\n**Step 3 - Run test suite:**\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/run-tests.sh`\n\n**Step 4 - Package release:**\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh $1`\n\nReview all step outputs and report:\n1. Any failures or warnings\n2. Build artifacts location\n3. Test results summary\n4. Next steps for deployment\n5. Rollback plan if needed\n```\n\n**Key features:**\n- Multi-step workflow\n- Sequential script execution\n- Clear step numbering\n- Comprehensive reporting\n\n---\n\n## 5. Configuration-Driven Deployment\n\n**Use case:** Deploy using environment-specific plugin configuration\n\n**File:** `commands/deploy.md`\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nDeployment configuration for $1: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nCurrent git state: !`git rev-parse --short HEAD`\n\nBuild info: !`cat package.json | grep -E '(name|version)'`\n\nExecute deployment to $1 environment using configuration above.\n\nDeployment checklist:\n1. Validate configuration settings\n2. Build application for $1\n3. Run pre-deployment tests\n4. Deploy to target environment\n5. Run smoke tests\n6. Verify deployment success\n7. Update deployment log\n\nReport deployment status and any issues encountered.\n```\n\n**Key features:**\n- Environment-specific configuration\n- Dynamic config file loading\n- Pre-deployment validation\n- Structured checklist\n\n---\n\n## 6. Agent Integration\n\n**Use case:** Command that launches plugin agent for complex task\n\n**File:** `commands/deep-review.md`\n\n```markdown\n---\ndescription: Deep code review using plugin agent\nargument-hint: [file-or-directory]\n---\n\nInitiate comprehensive code review of @$1 using the code-reviewer agent.\n\nThe agent will perform:\n1. **Static analysis** - Check for code smells and anti-patterns\n2. **Security audit** - Identify potential vulnerabilities\n3. **Performance review** - Find optimization opportunities\n4. **Best practices** - Ensure code follows standards\n5. **Documentation check** - Verify adequate documentation\n\nThe agent has access to:\n- Plugin's linting rules: ${CLAUDE_PLUGIN_ROOT}/config/lint-rules.json\n- Security checklist: ${CLAUDE_PLUGIN_ROOT}/checklists/security.md\n- Performance guidelines: ${CLAUDE_PLUGIN_ROOT}/docs/performance.md\n\nNote: This uses the Task tool to launch the plugin's code-reviewer agent for thorough analysis.\n```\n\n**Key features:**\n- Delegates to plugin agent\n- Documents agent capabilities\n- References plugin resources\n- Clear scope definition\n\n---\n\n## 7. Skill Integration\n\n**Use case:** Command that leverages plugin skill for specialized knowledge\n\n**File:** `commands/document-api.md`\n\n```markdown\n---\ndescription: Document API following plugin standards\nargument-hint: [api-file]\n---\n\nAPI source code: @$1\n\nGenerate API documentation following the plugin's API documentation standards.\n\nUse the api-documentation-standards skill to ensure:\n- **OpenAPI compliance** - Follow OpenAPI 3.0 specification\n- **Consistent formatting** - Use plugin's documentation style\n- **Complete coverage** - Document all endpoints and schemas\n- **Example quality** - Provide realistic usage examples\n- **Error documentation** - Cover all error scenarios\n\nThe skill provides:\n- Standard documentation templates\n- API documentation best practices\n- Common patterns for this codebase\n- Quality validation criteria\n\nGenerate production-ready API documentation.\n```\n\n**Key features:**\n- Invokes plugin skill by name\n- Documents skill purpose\n- Clear expectations\n- Leverages skill knowledge\n\n---\n\n## 8. Multi-Component Workflow\n\n**Use case:** Complex workflow using agents, skills, and scripts\n\n**File:** `commands/complete-review.md`\n\n```markdown\n---\ndescription: Comprehensive review using all plugin components\nargument-hint: [file-path]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget file: @$1\n\nExecute comprehensive review workflow:\n\n**Phase 1: Automated Analysis**\nRun plugin analyzer: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\n**Phase 2: Deep Review (Agent)**\nLaunch the code-quality-reviewer agent for detailed analysis.\nAgent will examine:\n- Code structure and organization\n- Error handling patterns\n- Testing coverage\n- Documentation quality\n\n**Phase 3: Standards Check (Skill)**\nUse the coding-standards skill to validate:\n- Naming conventions\n- Code formatting\n- Best practices adherence\n- Framework-specific patterns\n\n**Phase 4: Report Generation**\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review-report.md\n\nCompile all findings into comprehensive report following template.\n\n**Phase 5: Recommendations**\nGenerate prioritized action items:\n1. Critical issues (must fix)\n2. Important improvements (should fix)\n3. Nice-to-have enhancements (could fix)\n\nInclude specific file locations and suggested changes for each item.\n```\n\n**Key features:**\n- Multi-phase workflow\n- Combines scripts, agents, skills\n- Template-based reporting\n- Prioritized outputs\n\n---\n\n## 9. Validated Input Command\n\n**Use case:** Command with input validation and error handling\n\n**File:** `commands/build-env.md`\n\n```markdown\n---\ndescription: Build for specific environment with validation\nargument-hint: [environment]\nallowed-tools: Bash(*)\n---\n\nValidate environment argument: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" && echo \"VALID\" || echo \"INVALID\"`\n\nCheck build script exists: !`test -x ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh && echo \"EXISTS\" || echo \"MISSING\"`\n\nVerify configuration available: !`test -f ${CLAUDE_PLUGIN_ROOT}/config/$1.json && echo \"FOUND\" || echo \"NOT_FOUND\"`\n\nIf all validations pass:\n\n**Configuration:** @${CLAUDE_PLUGIN_ROOT}/config/$1.json\n\n**Execute build:** !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh $1 2>&1`\n\n**Validation results:** !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate-build.sh $1 2>&1`\n\nReport build status and any issues.\n\nIf validations fail:\n- Explain which validation failed\n- Provide expected values/locations\n- Suggest corrective actions\n- Document troubleshooting steps\n```\n\n**Key features:**\n- Input validation\n- Resource existence checks\n- Error handling\n- Helpful error messages\n- Graceful failure handling\n\n---\n\n## 10. Environment-Aware Command\n\n**Use case:** Command that adapts behavior based on environment\n\n**File:** `commands/run-checks.md`\n\n```markdown\n---\ndescription: Run environment-appropriate checks\nargument-hint: [environment]\nallowed-tools: Bash(*), Read\n---\n\nEnvironment: $1\n\nLoad environment configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-checks.json\n\nDetermine check level: !`echo \"$1\" | grep -E \"^prod$\" && echo \"FULL\" || echo \"BASIC\"`\n\n**For production environment:**\n- Full test suite: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test-full.sh`\n- Security scan: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/security-scan.sh`\n- Performance audit: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/perf-check.sh`\n- Compliance check: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/compliance.sh`\n\n**For non-production environments:**\n- Basic tests: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test-basic.sh`\n- Quick lint: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/lint.sh`\n\nAnalyze results based on environment requirements:\n\n**Production:** All checks must pass with zero critical issues\n**Staging:** No critical issues, warnings acceptable\n**Development:** Focus on blocking issues only\n\nReport status and recommend proceed/block decision.\n```\n\n**Key features:**\n- Environment-aware logic\n- Conditional execution\n- Different validation levels\n- Appropriate reporting per environment\n\n---\n\n## Common Patterns Summary\n\n### Pattern: Plugin Script Execution\n```markdown\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/script-name.js $1`\n```\nUse for: Running plugin-provided Node.js scripts\n\n### Pattern: Plugin Configuration Loading\n```markdown\n@${CLAUDE_PLUGIN_ROOT}/config/config-name.json\n```\nUse for: Loading plugin configuration files\n\n### Pattern: Plugin Template Usage\n```markdown\n@${CLAUDE_PLUGIN_ROOT}/templates/template-name.md\n```\nUse for: Using plugin templates for generation\n\n### Pattern: Agent Invocation\n```markdown\nLaunch the [agent-name] agent for [task description].\n```\nUse for: Delegating complex tasks to plugin agents\n\n### Pattern: Skill Reference\n```markdown\nUse the [skill-name] skill to ensure [requirements].\n```\nUse for: Leveraging plugin skills for specialized knowledge\n\n### Pattern: Input Validation\n```markdown\nValidate input: !`echo \"$1\" | grep -E \"^pattern$\" && echo \"OK\" || echo \"ERROR\"`\n```\nUse for: Validating command arguments\n\n### Pattern: Resource Validation\n```markdown\nCheck exists: !`test -f ${CLAUDE_PLUGIN_ROOT}/path/file && echo \"YES\" || echo \"NO\"`\n```\nUse for: Verifying required plugin files exist\n\n---\n\n## Development Tips\n\n### Testing Plugin Commands\n\n1. **Test with plugin installed:**\n   ```bash\n   cd /path/to/plugin\n   claude /command-name args\n   ```\n\n2. **Verify ${CLAUDE_PLUGIN_ROOT} expansion:**\n   ```bash\n   # Add debug output to command\n   !`echo \"Plugin root: ${CLAUDE_PLUGIN_ROOT}\"`\n   ```\n\n3. **Test across different working directories:**\n   ```bash\n   cd /tmp && claude /command-name\n   cd /other/project && claude /command-name\n   ```\n\n4. **Validate resource availability:**\n   ```bash\n   # Check all plugin resources exist\n   !`ls -la ${CLAUDE_PLUGIN_ROOT}/scripts/`\n   !`ls -la ${CLAUDE_PLUGIN_ROOT}/config/`\n   ```\n\n### Common Mistakes to Avoid\n\n1. **Using relative paths instead of ${CLAUDE_PLUGIN_ROOT}:**\n   ```markdown\n   # Wrong\n   !`node ./scripts/analyze.js`\n\n   # Correct\n   !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js`\n   ```\n\n2. **Forgetting to allow required tools:**\n   ```markdown\n   # Missing allowed-tools\n   !`bash script.sh`  # Will fail without Bash permission\n\n   # Correct\n   ---\n   allowed-tools: Bash(*)\n   ---\n   !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n   ```\n\n3. **Not validating inputs:**\n   ```markdown\n   # Risky - no validation\n   Deploy to $1 environment\n\n   # Better - with validation\n   Validate: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n   Deploy to $1 environment (if valid)\n   ```\n\n4. **Hardcoding plugin paths:**\n   ```markdown\n   # Wrong - breaks on different installations\n   @/home/user/.claude/plugins/my-plugin/config.json\n\n   # Correct - works everywhere\n   @${CLAUDE_PLUGIN_ROOT}/config.json\n   ```\n\n---\n\nFor detailed plugin-specific features, see `references/plugin-features-reference.md`.\nFor general command development, see main `SKILL.md`.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/command-development/README.md","content":"# Command Development Skill\n\nComprehensive guidance on creating Claude Code slash commands, including file format, frontmatter options, dynamic arguments, and best practices.\n\n## Overview\n\nThis skill provides knowledge about:\n- Slash command file format and structure\n- YAML frontmatter configuration fields\n- Dynamic arguments ($ARGUMENTS, $1, $2, etc.)\n- File references with @ syntax\n- Bash execution with !` syntax\n- Command organization and namespacing\n- Best practices for command development\n- Plugin-specific features (${CLAUDE_PLUGIN_ROOT}, plugin patterns)\n- Integration with plugin components (agents, skills, hooks)\n- Validation patterns and error handling\n\n## Skill Structure\n\n### SKILL.md (~2,470 words)\n\nCore skill content covering:\n\n**Fundamentals:**\n- Command basics and locations\n- File format (Markdown with optional frontmatter)\n- YAML frontmatter fields overview\n- Dynamic arguments ($ARGUMENTS and positional)\n- File references (@ syntax)\n- Bash execution (!` syntax)\n- Command organization patterns\n- Best practices and common patterns\n- Troubleshooting\n\n**Plugin-Specific:**\n- ${CLAUDE_PLUGIN_ROOT} environment variable\n- Plugin command discovery and organization\n- Plugin command patterns (configuration, template, multi-script)\n- Integration with plugin components (agents, skills, hooks)\n- Validation patterns (argument, file, resource, error handling)\n\n### References\n\nDetailed documentation:\n\n- **frontmatter-reference.md**: Complete YAML frontmatter field specifications\n  - All field descriptions with types and defaults\n  - When to use each field\n  - Examples and best practices\n  - Validation and common errors\n\n- **plugin-features-reference.md**: Plugin-specific command features\n  - Plugin command discovery and organization\n  - ${CLAUDE_PLUGIN_ROOT} environment variable usage\n  - Plugin command patterns (configuration, template, multi-script)\n  - Integration with plugin agents, skills, and hooks\n  - Validation patterns and error handling\n\n### Examples\n\nPractical command examples:\n\n- **simple-commands.md**: 10 complete command examples\n  - Code review commands\n  - Testing commands\n  - Deployment commands\n  - Documentation generators\n  - Git integration commands\n  - Analysis and research commands\n\n- **plugin-commands.md**: 10 plugin-specific command examples\n  - Simple plugin commands with scripts\n  - Multi-script workflows\n  - Template-based generation\n  - Configuration-driven deployment\n  - Agent and skill integration\n  - Multi-component workflows\n  - Validated input commands\n  - Environment-aware commands\n\n## When This Skill Triggers\n\nClaude Code activates this skill when users:\n- Ask to \"create a slash command\" or \"add a command\"\n- Need to \"write a custom command\"\n- Want to \"define command arguments\"\n- Ask about \"command frontmatter\" or YAML configuration\n- Need to \"organize commands\" or use namespacing\n- Want to create commands with file references\n- Ask about \"bash execution in commands\"\n- Need command development best practices\n\n## Progressive Disclosure\n\nThe skill uses progressive disclosure:\n\n1. **SKILL.md** (~2,470 words): Core concepts, common patterns, and plugin features overview\n2. **References** (~13,500 words total): Detailed specifications\n   - frontmatter-reference.md (~1,200 words)\n   - plugin-features-reference.md (~1,800 words)\n   - interactive-commands.md (~2,500 words)\n   - advanced-workflows.md (~1,700 words)\n   - testing-strategies.md (~2,200 words)\n   - documentation-patterns.md (~2,000 words)\n   - marketplace-considerations.md (~2,200 words)\n3. **Examples** (~6,000 words total): Complete working command examples\n   - simple-commands.md\n   - plugin-commands.md\n\nClaude loads references and examples as needed based on task.\n\n## Command Basics Quick Reference\n\n### File Format\n\n```markdown\n---\ndescription: Brief description\nargument-hint: [arg1] [arg2]\nallowed-tools: Read, Bash(git:*)\n---\n\nCommand prompt content with:\n- Arguments: $1, $2, or $ARGUMENTS\n- Files: @path/to/file\n- Bash: !`command here`\n```\n\n### Locations\n\n- **Project**: `.claude/commands/` (shared with team)\n- **Personal**: `~/.claude/commands/` (your commands)\n- **Plugin**: `plugin-name/commands/` (plugin-specific)\n\n### Key Features\n\n**Dynamic arguments:**\n- `$ARGUMENTS` - All arguments as single string\n- `$1`, `$2`, `$3` - Positional arguments\n\n**File references:**\n- `@path/to/file` - Include file contents\n\n**Bash execution:**\n- `!`command`` - Execute and include output\n\n## Frontmatter Fields Quick Reference\n\n| Field | Purpose | Example |\n|-------|---------|---------|\n| `description` | Brief description for /help | `\"Review code for issues\"` |\n| `allowed-tools` | Restrict tool access | `Read, Bash(git:*)` |\n| `model` | Specify model | `sonnet`, `opus`, `haiku` |\n| `argument-hint` | Document arguments | `[pr-number] [priority]` |\n| `disable-model-invocation` | Manual-only command | `true` |\n\n## Common Patterns\n\n### Simple Review Command\n\n```markdown\n---\ndescription: Review code for issues\n---\n\nReview this code for quality and potential bugs.\n```\n\n### Command with Arguments\n\n```markdown\n---\ndescription: Deploy to environment\nargument-hint: [environment] [version]\n---\n\nDeploy to $1 environment using version $2\n```\n\n### Command with File Reference\n\n```markdown\n---\ndescription: Document file\nargument-hint: [file-path]\n---\n\nGenerate documentation for @$1\n```\n\n### Command with Bash Execution\n\n```markdown\n---\ndescription: Show Git status\nallowed-tools: Bash(git:*)\n---\n\nCurrent status: !`git status`\nRecent commits: !`git log --oneline -5`\n```\n\n## Development Workflow\n\n1. **Design command:**\n   - Define purpose and scope\n   - Determine required arguments\n   - Identify needed tools\n\n2. **Create file:**\n   - Choose appropriate location\n   - Create `.md` file with command name\n   - Write basic prompt\n\n3. **Add frontmatter:**\n   - Start minimal (just description)\n   - Add fields as needed (allowed-tools, etc.)\n   - Document arguments with argument-hint\n\n4. **Test command:**\n   - Invoke with `/command-name`\n   - Verify arguments work\n   - Check bash execution\n   - Test file references\n\n5. **Refine:**\n   - Improve prompt clarity\n   - Handle edge cases\n   - Add examples in comments\n   - Document requirements\n\n## Best Practices Summary\n\n1. **Single responsibility**: One command, one clear purpose\n2. **Clear descriptions**: Make discoverable in `/help`\n3. **Document arguments**: Always use argument-hint\n4. **Minimal tools**: Use most restrictive allowed-tools\n5. **Test thoroughly**: Verify all features work\n6. **Add comments**: Explain complex logic\n7. **Handle errors**: Consider missing arguments/files\n\n## Status\n\n**Completed enhancements:**\n- âœ“ Plugin command patterns (${CLAUDE_PLUGIN_ROOT}, discovery, organization)\n- âœ“ Integration patterns (agents, skills, hooks coordination)\n- âœ“ Validation patterns (input, file, resource validation, error handling)\n\n**Remaining enhancements (in progress):**\n- Advanced workflows (multi-step command sequences)\n- Testing strategies (how to test commands effectively)\n- Documentation patterns (command documentation best practices)\n- Marketplace considerations (publishing and distribution)\n\n## Maintenance\n\nTo update this skill:\n1. Keep SKILL.md focused on core fundamentals\n2. Move detailed specifications to references/\n3. Add new examples/ for different use cases\n4. Update frontmatter when new fields added\n5. Ensure imperative/infinitive form throughout\n6. Test examples work with current Claude Code\n\n## Version History\n\n**v0.1.0** (2025-01-15):\n- Initial release with basic command fundamentals\n- Frontmatter field reference\n- 10 simple command examples\n- Ready for plugin-specific pattern additions\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/command-development/references/advanced-workflows.md","content":"# Advanced Workflow Patterns\n\nMulti-step command sequences and composition patterns for complex workflows.\n\n## Overview\n\nAdvanced workflows combine multiple commands, coordinate state across invocations, and create sophisticated automation sequences. These patterns enable building complex functionality from simple command building blocks.\n\n## Multi-Step Command Patterns\n\n### Sequential Workflow Command\n\nCommands that guide users through multi-step processes:\n\n```markdown\n---\ndescription: Complete PR review workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read, Grep\n---\n\n# PR Review Workflow for #$1\n\n## Step 1: Fetch PR Details\n!`gh pr view $1 --json title,body,author,files`\n\n## Step 2: Review Files\nFiles changed: !`gh pr diff $1 --name-only`\n\nFor each file:\n- Check code quality\n- Verify tests exist\n- Review documentation\n\n## Step 3: Run Checks\nTest status: !`gh pr checks $1`\n\nVerify:\n- All tests passing\n- No merge conflicts\n- CI/CD successful\n\n## Step 4: Provide Feedback\n\nSummarize:\n- Issues found (critical/minor)\n- Suggestions for improvement\n- Approval recommendation\n\nWould you like to:\n1. Approve PR\n2. Request changes\n3. Leave comments only\n\nReply with your choice and I'll help complete the action.\n```\n\n**Key features:**\n- Numbered steps for clarity\n- Bash execution for context\n- Decision points for user input\n- Next action suggestions\n\n### State-Carrying Workflow\n\nCommands that maintain state between invocations:\n\n```markdown\n---\ndescription: Initialize deployment workflow\nallowed-tools: Write, Bash(git:*)\n---\n\n# Initialize Deployment\n\nCreating deployment tracking file...\n\nCurrent branch: !`git branch --show-current`\nLatest commit: !`git log -1 --format=%H`\n\nDeployment state saved to `.claude/deployment-state.local.md`:\n\n\\`\\`\\`markdown\n---\ninitialized: true\nbranch: $(git branch --show-current)\ncommit: $(git log -1 --format=%H)\ntimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nstatus: initialized\n---\n\n# Deployment Tracking\n\nBranch: $(git branch --show-current)\nStarted: $(date)\n\nNext steps:\n1. Run tests: /deploy-test\n2. Build: /deploy-build\n3. Deploy: /deploy-execute\n\\`\\`\\`\n\nState saved. Run `/deploy-test` to continue.\n```\n\n**Next command** (`/deploy-test`):\n```markdown\n---\ndescription: Run deployment tests\nallowed-tools: Read, Bash(npm:*)\n---\n\nReading deployment state from `.claude/deployment-state.local.md`...\n\nRunning tests: !`npm test`\n\nUpdating state to 'tested'...\n\nTests complete. Run `/deploy-build` to continue.\n```\n\n**Pattern benefits:**\n- Persistent state across commands\n- Clear workflow progression\n- Safety checkpoints\n- Resume capability\n\n### Conditional Workflow Branching\n\nCommands that adapt based on conditions:\n\n```markdown\n---\ndescription: Smart deployment workflow\nargument-hint: [environment]\nallowed-tools: Bash(git:*), Bash(npm:*), Read\n---\n\n# Deploy to $1\n\n## Pre-flight Checks\n\nBranch: !`git branch --show-current`\nStatus: !`git status --short`\n\n**Checking conditions:**\n\n1. Branch status:\n   - If main/master: Require approval\n   - If feature branch: Warning about target\n   - If hotfix: Fast-track process\n\n2. Tests:\n   !`npm test`\n   - If tests fail: STOP - fix tests first\n   - If tests pass: Continue\n\n3. Environment:\n   - If $1 = 'production': Extra validation\n   - If $1 = 'staging': Standard process\n   - If $1 = 'dev': Minimal checks\n\n**Workflow decision:**\nBased on above, proceeding with: [determined workflow]\n\n[Conditional steps based on environment and status]\n\nReady to deploy? (yes/no)\n```\n\n## Command Composition Patterns\n\n### Command Chaining\n\nCommands designed to work together:\n\n```markdown\n---\ndescription: Prepare for code review\n---\n\n# Prepare Code Review\n\nRunning preparation sequence:\n\n1. Format code: /format-code\n2. Run linter: /lint-code\n3. Run tests: /test-all\n4. Generate coverage: /coverage-report\n5. Create review summary: /review-summary\n\nThis is a meta-command. After completing each step above,\nI'll compile results and prepare comprehensive review materials.\n\nStarting sequence...\n```\n\n**Individual commands** are simple:\n- `/format-code` - Just formats\n- `/lint-code` - Just lints\n- `/test-all` - Just tests\n\n**Composition command** orchestrates them.\n\n### Pipeline Pattern\n\nCommands that process output from previous commands:\n\n```markdown\n---\ndescription: Analyze test failures\n---\n\n# Analyze Test Failures\n\n## Step 1: Get test results\n(Run /test-all first if not done)\n\nReading test output...\n\n## Step 2: Categorize failures\n- Flaky tests (random failures)\n- Consistent failures\n- New failures vs existing\n\n## Step 3: Prioritize\nRank by:\n- Impact (critical path vs edge case)\n- Frequency (always fails vs sometimes)\n- Effort (quick fix vs major work)\n\n## Step 4: Generate fix plan\nFor each failure:\n- Root cause hypothesis\n- Suggested fix approach\n- Estimated effort\n\nWould you like me to:\n1. Fix highest priority failure\n2. Generate detailed fix plans for all\n3. Create GitHub issues for each\n```\n\n### Parallel Execution Pattern\n\nCommands that coordinate multiple simultaneous operations:\n\n```markdown\n---\ndescription: Run comprehensive validation\nallowed-tools: Bash(*), Read\n---\n\n# Comprehensive Validation\n\nRunning validations in parallel...\n\nStarting:\n- Code quality checks\n- Security scanning\n- Dependency audit\n- Performance profiling\n\nThis will take 2-3 minutes. I'll monitor all processes\nand report when complete.\n\n[Poll each process and report progress]\n\nAll validations complete. Summary:\n- Quality: PASS (0 issues)\n- Security: WARN (2 minor issues)\n- Dependencies: PASS\n- Performance: PASS (baseline met)\n\nDetails:\n[Collated results from all checks]\n```\n\n## Workflow State Management\n\n### Using .local.md Files\n\nStore workflow state in plugin-specific files:\n\n```markdown\n.claude/plugin-name-workflow.local.md:\n\n---\nworkflow: deployment\nstage: testing\nstarted: 2025-01-15T10:30:00Z\nenvironment: staging\nbranch: feature/new-api\ncommit: abc123def\ntests_passed: false\nbuild_complete: false\n---\n\n# Deployment Workflow State\n\nCurrent stage: Testing\nStarted: 2025-01-15 10:30 UTC\n\nCompleted steps:\n- âœ… Validation\n- âœ… Branch check\n- â³ Testing (in progress)\n\nPending steps:\n- Build\n- Deploy\n- Smoke tests\n```\n\n**Reading state in commands:**\n\n```markdown\n---\ndescription: Continue deployment workflow\nallowed-tools: Read, Write\n---\n\nReading workflow state from .claude/plugin-name-workflow.local.md...\n\nCurrent stage: @.claude/plugin-name-workflow.local.md\n\n[Parse YAML frontmatter to determine next step]\n\nNext action based on state: [determined action]\n```\n\n### Workflow Recovery\n\nHandle interrupted workflows:\n\n```markdown\n---\ndescription: Resume deployment workflow\nallowed-tools: Read\n---\n\n# Resume Deployment\n\nChecking for interrupted workflow...\n\nState file: @.claude/plugin-name-workflow.local.md\n\n**Workflow found:**\n- Started: [timestamp]\n- Environment: [env]\n- Last completed: [step]\n\n**Recovery options:**\n1. Resume from last step\n2. Restart from beginning\n3. Abort and clean up\n\nWhich would you like? (1/2/3)\n```\n\n## Workflow Coordination Patterns\n\n### Cross-Command Communication\n\nCommands that signal each other:\n\n```markdown\n---\ndescription: Mark feature complete\nallowed-tools: Write\n---\n\n# Mark Feature Complete\n\nWriting completion marker...\n\nCreating: .claude/feature-complete.flag\n\nThis signals other commands that feature is ready for:\n- Integration testing (/integration-test will auto-detect)\n- Documentation generation (/docs-generate will include)\n- Release notes (/release-notes will add)\n\nFeature marked complete.\n```\n\n**Other commands check for flag:**\n\n```markdown\n---\ndescription: Generate release notes\nallowed-tools: Read, Bash(git:*)\n---\n\nChecking for completed features...\n\nif [ -f .claude/feature-complete.flag ]; then\n  Feature ready for release notes\nfi\n\n[Include in release notes]\n```\n\n### Workflow Locking\n\nPrevent concurrent workflow execution:\n\n```markdown\n---\ndescription: Start deployment\nallowed-tools: Read, Write, Bash\n---\n\n# Start Deployment\n\nChecking for active deployments...\n\nif [ -f .claude/deployment.lock ]; then\n  ERROR: Deployment already in progress\n  Started: [timestamp from lock file]\n\n  Cannot start concurrent deployment.\n  Wait for completion or run /deployment-abort\n\n  Exit.\nfi\n\nCreating deployment lock...\n\nDeployment started. Lock created.\n[Proceed with deployment]\n```\n\n**Lock cleanup:**\n\n```markdown\n---\ndescription: Complete deployment\nallowed-tools: Write, Bash\n---\n\nDeployment complete.\n\nRemoving deployment lock...\nrm .claude/deployment.lock\n\nReady for next deployment.\n```\n\n## Advanced Argument Handling\n\n### Optional Arguments with Defaults\n\n```markdown\n---\ndescription: Deploy with optional version\nargument-hint: [environment] [version]\n---\n\nEnvironment: ${1:-staging}\nVersion: ${2:-latest}\n\nDeploying ${2:-latest} to ${1:-staging}...\n\nNote: Using defaults for missing arguments:\n- Environment defaults to 'staging'\n- Version defaults to 'latest'\n```\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy to validated environment\nargument-hint: [environment]\n---\n\nEnvironment: $1\n\nValidating environment...\n\nvalid_envs=\"dev staging production\"\nif ! echo \"$valid_envs\" | grep -w \"$1\" > /dev/null; then\n  ERROR: Invalid environment '$1'\n  Valid options: dev, staging, production\n  Exit.\nfi\n\nEnvironment validated. Proceeding...\n```\n\n### Argument Transformation\n\n```markdown\n---\ndescription: Deploy with shorthand\nargument-hint: [env-shorthand]\n---\n\nInput: $1\n\nExpanding shorthand:\n- d/dev â†’ development\n- s/stg â†’ staging\n- p/prod â†’ production\n\ncase \"$1\" in\n  d|dev) ENV=\"development\";;\n  s|stg) ENV=\"staging\";;\n  p|prod) ENV=\"production\";;\n  *) ENV=\"$1\";;\nesac\n\nDeploying to: $ENV\n```\n\n## Error Handling in Workflows\n\n### Graceful Failure\n\n```markdown\n---\ndescription: Resilient deployment workflow\n---\n\n# Deployment Workflow\n\nRunning steps with error handling...\n\n## Step 1: Tests\n!`npm test`\n\nif [ $? -ne 0 ]; then\n  ERROR: Tests failed\n\n  Options:\n  1. Fix tests and retry\n  2. Skip tests (NOT recommended)\n  3. Abort deployment\n\n  What would you like to do?\n\n  [Wait for user input before continuing]\nfi\n\n## Step 2: Build\n[Continue only if Step 1 succeeded]\n```\n\n### Rollback on Failure\n\n```markdown\n---\ndescription: Deployment with rollback\n---\n\n# Deploy with Rollback\n\nSaving current state for rollback...\nPrevious version: !`current-version.sh`\n\nDeploying new version...\n\n!`deploy.sh`\n\nif [ $? -ne 0 ]; then\n  DEPLOYMENT FAILED\n\n  Initiating automatic rollback...\n  !`rollback.sh`\n\n  Rolled back to previous version.\n  Check logs for failure details.\nfi\n\nDeployment complete.\n```\n\n### Checkpoint Recovery\n\n```markdown\n---\ndescription: Workflow with checkpoints\n---\n\n# Multi-Stage Deployment\n\n## Checkpoint 1: Validation\n!`validate.sh`\necho \"checkpoint:validation\" >> .claude/deployment-checkpoints.log\n\n## Checkpoint 2: Build\n!`build.sh`\necho \"checkpoint:build\" >> .claude/deployment-checkpoints.log\n\n## Checkpoint 3: Deploy\n!`deploy.sh`\necho \"checkpoint:deploy\" >> .claude/deployment-checkpoints.log\n\nIf any step fails, resume with:\n/deployment-resume [last-successful-checkpoint]\n```\n\n## Best Practices\n\n### Workflow Design\n\n1. **Clear progression**: Number steps, show current position\n2. **Explicit state**: Don't rely on implicit state\n3. **User control**: Provide decision points\n4. **Error recovery**: Handle failures gracefully\n5. **Progress indication**: Show what's done, what's pending\n\n### Command Composition\n\n1. **Single responsibility**: Each command does one thing well\n2. **Composable design**: Commands work together easily\n3. **Standard interfaces**: Consistent input/output formats\n4. **Loose coupling**: Commands don't depend on each other's internals\n\n### State Management\n\n1. **Persistent state**: Use .local.md files\n2. **Atomic updates**: Write complete state files atomically\n3. **State validation**: Check state file format/completeness\n4. **Cleanup**: Remove stale state files\n5. **Documentation**: Document state file formats\n\n### Error Handling\n\n1. **Fail fast**: Detect errors early\n2. **Clear messages**: Explain what went wrong\n3. **Recovery options**: Provide clear next steps\n4. **State preservation**: Keep state for recovery\n5. **Rollback capability**: Support undoing changes\n\n## Example: Complete Deployment Workflow\n\n### Initialize Command\n\n```markdown\n---\ndescription: Initialize deployment\nargument-hint: [environment]\nallowed-tools: Write, Bash(git:*)\n---\n\n# Initialize Deployment to $1\n\nCreating workflow state...\n\n\\`\\`\\`yaml\n---\nworkflow: deployment\nenvironment: $1\nbranch: !`git branch --show-current`\ncommit: !`git rev-parse HEAD`\nstage: initialized\ntimestamp: !`date -u +%Y-%m-%dT%H:%M:%SZ`\n---\n\\`\\`\\`\n\nWritten to .claude/deployment-state.local.md\n\nNext: Run /deployment-validate\n```\n\n### Validation Command\n\n```markdown\n---\ndescription: Validate deployment\nallowed-tools: Read, Bash\n---\n\nReading state: @.claude/deployment-state.local.md\n\nRunning validation...\n- Branch check: PASS\n- Tests: PASS\n- Build: PASS\n\nUpdating state to 'validated'...\n\nNext: Run /deployment-execute\n```\n\n### Execution Command\n\n```markdown\n---\ndescription: Execute deployment\nallowed-tools: Read, Bash, Write\n---\n\nReading state: @.claude/deployment-state.local.md\n\nExecuting deployment to [environment]...\n\n!`deploy.sh [environment]`\n\nDeployment complete.\nUpdating state to 'completed'...\n\nCleanup: /deployment-cleanup\n```\n\n### Cleanup Command\n\n```markdown\n---\ndescription: Clean up deployment\nallowed-tools: Bash\n---\n\nRemoving deployment state...\nrm .claude/deployment-state.local.md\n\nDeployment workflow complete.\n```\n\nThis complete workflow demonstrates state management, sequential execution, error handling, and clean separation of concerns across multiple commands.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/command-development/references/testing-strategies.md","content":"# Command Testing Strategies\n\nComprehensive strategies for testing slash commands before deployment and distribution.\n\n## Overview\n\nTesting commands ensures they work correctly, handle edge cases, and provide good user experience. A systematic testing approach catches issues early and builds confidence in command reliability.\n\n## Testing Levels\n\n### Level 1: Syntax and Structure Validation\n\n**What to test:**\n- YAML frontmatter syntax\n- Markdown format\n- File location and naming\n\n**How to test:**\n\n```bash\n# Validate YAML frontmatter\nhead -n 20 .claude/commands/my-command.md | grep -A 10 \"^---\"\n\n# Check for closing frontmatter marker\nhead -n 20 .claude/commands/my-command.md | grep -c \"^---\" # Should be 2\n\n# Verify file has .md extension\nls .claude/commands/*.md\n\n# Check file is in correct location\ntest -f .claude/commands/my-command.md && echo \"Found\" || echo \"Missing\"\n```\n\n**Automated validation script:**\n\n```bash\n#!/bin/bash\n# validate-command.sh\n\nCOMMAND_FILE=\"$1\"\n\nif [ ! -f \"$COMMAND_FILE\" ]; then\n  echo \"ERROR: File not found: $COMMAND_FILE\"\n  exit 1\nfi\n\n# Check .md extension\nif [[ ! \"$COMMAND_FILE\" =~ \\.md$ ]]; then\n  echo \"ERROR: File must have .md extension\"\n  exit 1\nfi\n\n# Validate YAML frontmatter if present\nif head -n 1 \"$COMMAND_FILE\" | grep -q \"^---\"; then\n  # Count frontmatter markers\n  MARKERS=$(head -n 50 \"$COMMAND_FILE\" | grep -c \"^---\")\n  if [ \"$MARKERS\" -ne 2 ]; then\n    echo \"ERROR: Invalid YAML frontmatter (need exactly 2 '---' markers)\"\n    exit 1\n  fi\n  echo \"âœ“ YAML frontmatter syntax valid\"\nfi\n\n# Check for empty file\nif [ ! -s \"$COMMAND_FILE\" ]; then\n  echo \"ERROR: File is empty\"\n  exit 1\nfi\n\necho \"âœ“ Command file structure valid\"\n```\n\n### Level 2: Frontmatter Field Validation\n\n**What to test:**\n- Field types correct\n- Values in valid ranges\n- Required fields present (if any)\n\n**Validation script:**\n\n```bash\n#!/bin/bash\n# validate-frontmatter.sh\n\nCOMMAND_FILE=\"$1\"\n\n# Extract YAML frontmatter\nFRONTMATTER=$(sed -n '/^---$/,/^---$/p' \"$COMMAND_FILE\" | sed '1d;$d')\n\nif [ -z \"$FRONTMATTER\" ]; then\n  echo \"No frontmatter to validate\"\n  exit 0\nfi\n\n# Check 'model' field if present\nif echo \"$FRONTMATTER\" | grep -q \"^model:\"; then\n  MODEL=$(echo \"$FRONTMATTER\" | grep \"^model:\" | cut -d: -f2 | tr -d ' ')\n  if ! echo \"sonnet opus haiku\" | grep -qw \"$MODEL\"; then\n    echo \"ERROR: Invalid model '$MODEL' (must be sonnet, opus, or haiku)\"\n    exit 1\n  fi\n  echo \"âœ“ Model field valid: $MODEL\"\nfi\n\n# Check 'allowed-tools' field format\nif echo \"$FRONTMATTER\" | grep -q \"^allowed-tools:\"; then\n  echo \"âœ“ allowed-tools field present\"\n  # Could add more sophisticated validation here\nfi\n\n# Check 'description' length\nif echo \"$FRONTMATTER\" | grep -q \"^description:\"; then\n  DESC=$(echo \"$FRONTMATTER\" | grep \"^description:\" | cut -d: -f2-)\n  LENGTH=${#DESC}\n  if [ \"$LENGTH\" -gt 80 ]; then\n    echo \"WARNING: Description length $LENGTH (recommend < 60 chars)\"\n  else\n    echo \"âœ“ Description length acceptable: $LENGTH chars\"\n  fi\nfi\n\necho \"âœ“ Frontmatter fields valid\"\n```\n\n### Level 3: Manual Command Invocation\n\n**What to test:**\n- Command appears in `/help`\n- Command executes without errors\n- Output is as expected\n\n**Test procedure:**\n\n```bash\n# 1. Start Claude Code\nclaude --debug\n\n# 2. Check command appears in help\n> /help\n# Look for your command in the list\n\n# 3. Invoke command without arguments\n> /my-command\n# Check for reasonable error or behavior\n\n# 4. Invoke with valid arguments\n> /my-command arg1 arg2\n# Verify expected behavior\n\n# 5. Check debug logs\ntail -f ~/.claude/debug-logs/latest\n# Look for errors or warnings\n```\n\n### Level 4: Argument Testing\n\n**What to test:**\n- Positional arguments work ($1, $2, etc.)\n- $ARGUMENTS captures all arguments\n- Missing arguments handled gracefully\n- Invalid arguments detected\n\n**Test matrix:**\n\n| Test Case | Command | Expected Result |\n|-----------|---------|-----------------|\n| No args | `/cmd` | Graceful handling or useful message |\n| One arg | `/cmd arg1` | $1 substituted correctly |\n| Two args | `/cmd arg1 arg2` | $1 and $2 substituted |\n| Extra args | `/cmd a b c d` | All captured or extras ignored appropriately |\n| Special chars | `/cmd \"arg with spaces\"` | Quotes handled correctly |\n| Empty arg | `/cmd \"\"` | Empty string handled |\n\n**Test script:**\n\n```bash\n#!/bin/bash\n# test-command-arguments.sh\n\nCOMMAND=\"$1\"\n\necho \"Testing argument handling for /$COMMAND\"\necho\n\necho \"Test 1: No arguments\"\necho \"  Command: /$COMMAND\"\necho \"  Expected: [describe expected behavior]\"\necho \"  Manual test required\"\necho\n\necho \"Test 2: Single argument\"\necho \"  Command: /$COMMAND test-value\"\necho \"  Expected: 'test-value' appears in output\"\necho \"  Manual test required\"\necho\n\necho \"Test 3: Multiple arguments\"\necho \"  Command: /$COMMAND arg1 arg2 arg3\"\necho \"  Expected: All arguments used appropriately\"\necho \"  Manual test required\"\necho\n\necho \"Test 4: Special characters\"\necho \"  Command: /$COMMAND \\\"value with spaces\\\"\"\necho \"  Expected: Entire phrase captured\"\necho \"  Manual test required\"\n```\n\n### Level 5: File Reference Testing\n\n**What to test:**\n- @ syntax loads file contents\n- Non-existent files handled\n- Large files handled appropriately\n- Multiple file references work\n\n**Test procedure:**\n\n```bash\n# Create test files\necho \"Test content\" > /tmp/test-file.txt\necho \"Second file\" > /tmp/test-file-2.txt\n\n# Test single file reference\n> /my-command /tmp/test-file.txt\n# Verify file content is read\n\n# Test non-existent file\n> /my-command /tmp/nonexistent.txt\n# Verify graceful error handling\n\n# Test multiple files\n> /my-command /tmp/test-file.txt /tmp/test-file-2.txt\n# Verify both files processed\n\n# Test large file\ndd if=/dev/zero of=/tmp/large-file.bin bs=1M count=100\n> /my-command /tmp/large-file.bin\n# Verify reasonable behavior (may truncate or warn)\n\n# Cleanup\nrm /tmp/test-file*.txt /tmp/large-file.bin\n```\n\n### Level 6: Bash Execution Testing\n\n**What to test:**\n- !` commands execute correctly\n- Command output included in prompt\n- Command failures handled\n- Security: only allowed commands run\n\n**Test procedure:**\n\n```bash\n# Create test command with bash execution\ncat > .claude/commands/test-bash.md << 'EOF'\n---\ndescription: Test bash execution\nallowed-tools: Bash(echo:*), Bash(date:*)\n---\n\nCurrent date: !`date`\nTest output: !`echo \"Hello from bash\"`\n\nAnalysis of output above...\nEOF\n\n# Test in Claude Code\n> /test-bash\n# Verify:\n# 1. Date appears correctly\n# 2. Echo output appears\n# 3. No errors in debug logs\n\n# Test with disallowed command (should fail or be blocked)\ncat > .claude/commands/test-forbidden.md << 'EOF'\n---\ndescription: Test forbidden command\nallowed-tools: Bash(echo:*)\n---\n\nTrying forbidden: !`ls -la /`\nEOF\n\n> /test-forbidden\n# Verify: Permission denied or appropriate error\n```\n\n### Level 7: Integration Testing\n\n**What to test:**\n- Commands work with other plugin components\n- Commands interact correctly with each other\n- State management works across invocations\n- Workflow commands execute in sequence\n\n**Test scenarios:**\n\n**Scenario 1: Command + Hook Integration**\n\n```bash\n# Setup: Command that triggers a hook\n# Test: Invoke command, verify hook executes\n\n# Command: .claude/commands/risky-operation.md\n# Hook: PreToolUse that validates the operation\n\n> /risky-operation\n# Verify: Hook executes and validates before command completes\n```\n\n**Scenario 2: Command Sequence**\n\n```bash\n# Setup: Multi-command workflow\n> /workflow-init\n# Verify: State file created\n\n> /workflow-step2\n# Verify: State file read, step 2 executes\n\n> /workflow-complete\n# Verify: State file cleaned up\n```\n\n**Scenario 3: Command + MCP Integration**\n\n```bash\n# Setup: Command uses MCP tools\n# Test: Verify MCP server accessible\n\n> /mcp-command\n# Verify:\n# 1. MCP server starts (if stdio)\n# 2. Tool calls succeed\n# 3. Results included in output\n```\n\n## Automated Testing Approaches\n\n### Command Test Suite\n\nCreate a test suite script:\n\n```bash\n#!/bin/bash\n# test-commands.sh - Command test suite\n\nTEST_DIR=\".claude/commands\"\nFAILED_TESTS=0\n\necho \"Command Test Suite\"\necho \"==================\"\necho\n\nfor cmd_file in \"$TEST_DIR\"/*.md; do\n  cmd_name=$(basename \"$cmd_file\" .md)\n  echo \"Testing: $cmd_name\"\n\n  # Validate structure\n  if ./validate-command.sh \"$cmd_file\"; then\n    echo \"  âœ“ Structure valid\"\n  else\n    echo \"  âœ— Structure invalid\"\n    ((FAILED_TESTS++))\n  fi\n\n  # Validate frontmatter\n  if ./validate-frontmatter.sh \"$cmd_file\"; then\n    echo \"  âœ“ Frontmatter valid\"\n  else\n    echo \"  âœ— Frontmatter invalid\"\n    ((FAILED_TESTS++))\n  fi\n\n  echo\ndone\n\necho \"==================\"\necho \"Tests complete\"\necho \"Failed: $FAILED_TESTS\"\n\nexit $FAILED_TESTS\n```\n\n### Pre-Commit Hook\n\nValidate commands before committing:\n\n```bash\n#!/bin/bash\n# .git/hooks/pre-commit\n\necho \"Validating commands...\"\n\nCOMMANDS_CHANGED=$(git diff --cached --name-only | grep \"\\.claude/commands/.*\\.md\")\n\nif [ -z \"$COMMANDS_CHANGED\" ]; then\n  echo \"No commands changed\"\n  exit 0\nfi\n\nfor cmd in $COMMANDS_CHANGED; do\n  echo \"Checking: $cmd\"\n\n  if ! ./scripts/validate-command.sh \"$cmd\"; then\n    echo \"ERROR: Command validation failed: $cmd\"\n    exit 1\n  fi\ndone\n\necho \"âœ“ All commands valid\"\n```\n\n### Continuous Testing\n\nTest commands in CI/CD:\n\n```yaml\n# .github/workflows/test-commands.yml\nname: Test Commands\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Validate command structure\n        run: |\n          for cmd in .claude/commands/*.md; do\n            echo \"Testing: $cmd\"\n            ./scripts/validate-command.sh \"$cmd\"\n          done\n\n      - name: Validate frontmatter\n        run: |\n          for cmd in .claude/commands/*.md; do\n            ./scripts/validate-frontmatter.sh \"$cmd\"\n          done\n\n      - name: Check for TODOs\n        run: |\n          if grep -r \"TODO\" .claude/commands/; then\n            echo \"ERROR: TODOs found in commands\"\n            exit 1\n          fi\n```\n\n## Edge Case Testing\n\n### Test Edge Cases\n\n**Empty arguments:**\n```bash\n> /cmd \"\"\n> /cmd '' ''\n```\n\n**Special characters:**\n```bash\n> /cmd \"arg with spaces\"\n> /cmd arg-with-dashes\n> /cmd arg_with_underscores\n> /cmd arg/with/slashes\n> /cmd 'arg with \"quotes\"'\n```\n\n**Long arguments:**\n```bash\n> /cmd $(python -c \"print('a' * 10000)\")\n```\n\n**Unusual file paths:**\n```bash\n> /cmd ./file\n> /cmd ../file\n> /cmd ~/file\n> /cmd \"/path with spaces/file\"\n```\n\n**Bash command edge cases:**\n```markdown\n# Commands that might fail\n!`exit 1`\n!`false`\n!`command-that-does-not-exist`\n\n# Commands with special output\n!`echo \"\"`\n!`cat /dev/null`\n!`yes | head -n 1000000`\n```\n\n## Performance Testing\n\n### Response Time Testing\n\n```bash\n#!/bin/bash\n# test-command-performance.sh\n\nCOMMAND=\"$1\"\n\necho \"Testing performance of /$COMMAND\"\necho\n\nfor i in {1..5}; do\n  echo \"Run $i:\"\n  START=$(date +%s%N)\n\n  # Invoke command (manual step - record time)\n  echo \"  Invoke: /$COMMAND\"\n  echo \"  Start time: $START\"\n  echo \"  (Record end time manually)\"\n  echo\ndone\n\necho \"Analyze results:\"\necho \"  - Average response time\"\necho \"  - Variance\"\necho \"  - Acceptable threshold: < 3 seconds for fast commands\"\n```\n\n### Resource Usage Testing\n\n```bash\n# Monitor Claude Code during command execution\n# In terminal 1:\nclaude --debug\n\n# In terminal 2:\nwatch -n 1 'ps aux | grep claude'\n\n# Execute command and observe:\n# - Memory usage\n# - CPU usage\n# - Process count\n```\n\n## User Experience Testing\n\n### Usability Checklist\n\n- [ ] Command name is intuitive\n- [ ] Description is clear in `/help`\n- [ ] Arguments are well-documented\n- [ ] Error messages are helpful\n- [ ] Output is formatted readably\n- [ ] Long-running commands show progress\n- [ ] Results are actionable\n- [ ] Edge cases have good UX\n\n### User Acceptance Testing\n\nRecruit testers:\n\n```markdown\n# Testing Guide for Beta Testers\n\n## Command: /my-new-command\n\n### Test Scenarios\n\n1. **Basic usage:**\n   - Run: `/my-new-command`\n   - Expected: [describe]\n   - Rate clarity: 1-5\n\n2. **With arguments:**\n   - Run: `/my-new-command arg1 arg2`\n   - Expected: [describe]\n   - Rate usefulness: 1-5\n\n3. **Error case:**\n   - Run: `/my-new-command invalid-input`\n   - Expected: Helpful error message\n   - Rate error message: 1-5\n\n### Feedback Questions\n\n1. Was the command easy to understand?\n2. Did the output meet your expectations?\n3. What would you change?\n4. Would you use this command regularly?\n```\n\n## Testing Checklist\n\nBefore releasing a command:\n\n### Structure\n- [ ] File in correct location\n- [ ] Correct .md extension\n- [ ] Valid YAML frontmatter (if present)\n- [ ] Markdown syntax correct\n\n### Functionality\n- [ ] Command appears in `/help`\n- [ ] Description is clear\n- [ ] Command executes without errors\n- [ ] Arguments work as expected\n- [ ] File references work\n- [ ] Bash execution works (if used)\n\n### Edge Cases\n- [ ] Missing arguments handled\n- [ ] Invalid arguments detected\n- [ ] Non-existent files handled\n- [ ] Special characters work\n- [ ] Long inputs handled\n\n### Integration\n- [ ] Works with other commands\n- [ ] Works with hooks (if applicable)\n- [ ] Works with MCP (if applicable)\n- [ ] State management works\n\n### Quality\n- [ ] Performance acceptable\n- [ ] No security issues\n- [ ] Error messages helpful\n- [ ] Output formatted well\n- [ ] Documentation complete\n\n### Distribution\n- [ ] Tested by others\n- [ ] Feedback incorporated\n- [ ] README updated\n- [ ] Examples provided\n\n## Debugging Failed Tests\n\n### Common Issues and Solutions\n\n**Issue: Command not appearing in /help**\n\n```bash\n# Check file location\nls -la .claude/commands/my-command.md\n\n# Check permissions\nchmod 644 .claude/commands/my-command.md\n\n# Check syntax\nhead -n 20 .claude/commands/my-command.md\n\n# Restart Claude Code\nclaude --debug\n```\n\n**Issue: Arguments not substituting**\n\n```bash\n# Verify syntax\ngrep '\\$1' .claude/commands/my-command.md\ngrep '\\$ARGUMENTS' .claude/commands/my-command.md\n\n# Test with simple command first\necho \"Test: \\$1 and \\$2\" > .claude/commands/test-args.md\n```\n\n**Issue: Bash commands not executing**\n\n```bash\n# Check allowed-tools\ngrep \"allowed-tools\" .claude/commands/my-command.md\n\n# Verify command syntax\ngrep '!\\`' .claude/commands/my-command.md\n\n# Test command manually\ndate\necho \"test\"\n```\n\n**Issue: File references not working**\n\n```bash\n# Check @ syntax\ngrep '@' .claude/commands/my-command.md\n\n# Verify file exists\nls -la /path/to/referenced/file\n\n# Check permissions\nchmod 644 /path/to/referenced/file\n```\n\n## Best Practices\n\n1. **Test early, test often**: Validate as you develop\n2. **Automate validation**: Use scripts for repeatable checks\n3. **Test edge cases**: Don't just test the happy path\n4. **Get feedback**: Have others test before wide release\n5. **Document tests**: Keep test scenarios for regression testing\n6. **Monitor in production**: Watch for issues after release\n7. **Iterate**: Improve based on real usage data\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/command-development/references/frontmatter-reference.md","content":"# Command Frontmatter Reference\n\nComplete reference for YAML frontmatter fields in slash commands.\n\n## Frontmatter Overview\n\nYAML frontmatter is optional metadata at the start of command files:\n\n```markdown\n---\ndescription: Brief description\nallowed-tools: Read, Write\nmodel: sonnet\nargument-hint: [arg1] [arg2]\n---\n\nCommand prompt content here...\n```\n\nAll fields are optional. Commands work without any frontmatter.\n\n## Field Specifications\n\n### description\n\n**Type:** String\n**Required:** No\n**Default:** First line of command prompt\n**Max Length:** ~60 characters recommended for `/help` display\n\n**Purpose:** Describes what the command does, shown in `/help` output\n\n**Examples:**\n```yaml\ndescription: Review code for security issues\n```\n```yaml\ndescription: Deploy to staging environment\n```\n```yaml\ndescription: Generate API documentation\n```\n\n**Best practices:**\n- Keep under 60 characters for clean display\n- Start with verb (Review, Deploy, Generate)\n- Be specific about what command does\n- Avoid redundant \"command\" or \"slash command\"\n\n**Good:**\n- âœ… \"Review PR for code quality and security\"\n- âœ… \"Deploy application to specified environment\"\n- âœ… \"Generate comprehensive API documentation\"\n\n**Bad:**\n- âŒ \"This command reviews PRs\" (unnecessary \"This command\")\n- âŒ \"Review\" (too vague)\n- âŒ \"A command that reviews pull requests for code quality, security issues, and best practices\" (too long)\n\n### allowed-tools\n\n**Type:** String or Array of strings\n**Required:** No\n**Default:** Inherits from conversation permissions\n\n**Purpose:** Restrict or specify which tools command can use\n\n**Formats:**\n\n**Single tool:**\n```yaml\nallowed-tools: Read\n```\n\n**Multiple tools (comma-separated):**\n```yaml\nallowed-tools: Read, Write, Edit\n```\n\n**Multiple tools (array):**\n```yaml\nallowed-tools:\n  - Read\n  - Write\n  - Bash(git:*)\n```\n\n**Tool Patterns:**\n\n**Specific tools:**\n```yaml\nallowed-tools: Read, Grep, Edit\n```\n\n**Bash with command filter:**\n```yaml\nallowed-tools: Bash(git:*)           # Only git commands\nallowed-tools: Bash(npm:*)           # Only npm commands\nallowed-tools: Bash(docker:*)        # Only docker commands\n```\n\n**All tools (not recommended):**\n```yaml\nallowed-tools: \"*\"\n```\n\n**When to use:**\n\n1. **Security:** Restrict command to safe operations\n   ```yaml\n   allowed-tools: Read, Grep  # Read-only command\n   ```\n\n2. **Clarity:** Document required tools\n   ```yaml\n   allowed-tools: Bash(git:*), Read\n   ```\n\n3. **Bash execution:** Enable bash command output\n   ```yaml\n   allowed-tools: Bash(git status:*), Bash(git diff:*)\n   ```\n\n**Best practices:**\n- Be as restrictive as possible\n- Use command filters for Bash (e.g., `git:*` not `*`)\n- Only specify when different from conversation permissions\n- Document why specific tools are needed\n\n### model\n\n**Type:** String\n**Required:** No\n**Default:** Inherits from conversation\n**Values:** `sonnet`, `opus`, `haiku`\n\n**Purpose:** Specify which Claude model executes the command\n\n**Examples:**\n```yaml\nmodel: haiku    # Fast, efficient for simple tasks\n```\n```yaml\nmodel: sonnet   # Balanced performance (default)\n```\n```yaml\nmodel: opus     # Maximum capability for complex tasks\n```\n\n**When to use:**\n\n**Use `haiku` for:**\n- Simple, formulaic commands\n- Fast execution needed\n- Low complexity tasks\n- Frequent invocations\n\n```yaml\n---\ndescription: Format code file\nmodel: haiku\n---\n```\n\n**Use `sonnet` for:**\n- Standard commands (default)\n- Balanced speed/quality\n- Most common use cases\n\n```yaml\n---\ndescription: Review code changes\nmodel: sonnet\n---\n```\n\n**Use `opus` for:**\n- Complex analysis\n- Architectural decisions\n- Deep code understanding\n- Critical tasks\n\n```yaml\n---\ndescription: Analyze system architecture\nmodel: opus\n---\n```\n\n**Best practices:**\n- Omit unless specific need\n- Use `haiku` for speed when possible\n- Reserve `opus` for genuinely complex tasks\n- Test with different models to find right balance\n\n### argument-hint\n\n**Type:** String\n**Required:** No\n**Default:** None\n\n**Purpose:** Document expected arguments for users and autocomplete\n\n**Format:**\n```yaml\nargument-hint: [arg1] [arg2] [optional-arg]\n```\n\n**Examples:**\n\n**Single argument:**\n```yaml\nargument-hint: [pr-number]\n```\n\n**Multiple required arguments:**\n```yaml\nargument-hint: [environment] [version]\n```\n\n**Optional arguments:**\n```yaml\nargument-hint: [file-path] [options]\n```\n\n**Descriptive names:**\n```yaml\nargument-hint: [source-branch] [target-branch] [commit-message]\n```\n\n**Best practices:**\n- Use square brackets `[]` for each argument\n- Use descriptive names (not `arg1`, `arg2`)\n- Indicate optional vs required in description\n- Match order to positional arguments in command\n- Keep concise but clear\n\n**Examples by pattern:**\n\n**Simple command:**\n```yaml\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$1...\n```\n\n**Multi-argument:**\n```yaml\n---\ndescription: Deploy to environment\nargument-hint: [app-name] [environment] [version]\n---\n\nDeploy $1 to $2 using version $3...\n```\n\n**With options:**\n```yaml\n---\ndescription: Run tests with options\nargument-hint: [test-pattern] [options]\n---\n\nRun tests matching $1 with options: $2\n```\n\n### disable-model-invocation\n\n**Type:** Boolean\n**Required:** No\n**Default:** false\n\n**Purpose:** Prevent SlashCommand tool from programmatically invoking command\n\n**Examples:**\n```yaml\ndisable-model-invocation: true\n```\n\n**When to use:**\n\n1. **Manual-only commands:** Commands requiring user judgment\n   ```yaml\n   ---\n   description: Approve deployment to production\n   disable-model-invocation: true\n   ---\n   ```\n\n2. **Destructive operations:** Commands with irreversible effects\n   ```yaml\n   ---\n   description: Delete all test data\n   disable-model-invocation: true\n   ---\n   ```\n\n3. **Interactive workflows:** Commands needing user input\n   ```yaml\n   ---\n   description: Walk through setup wizard\n   disable-model-invocation: true\n   ---\n   ```\n\n**Default behavior (false):**\n- Command available to SlashCommand tool\n- Claude can invoke programmatically\n- Still available for manual invocation\n\n**When true:**\n- Command only invokable by user typing `/command`\n- Not available to SlashCommand tool\n- Safer for sensitive operations\n\n**Best practices:**\n- Use sparingly (limits Claude's autonomy)\n- Document why in command comments\n- Consider if command should exist if always manual\n\n## Complete Examples\n\n### Minimal Command\n\nNo frontmatter needed:\n\n```markdown\nReview this code for common issues and suggest improvements.\n```\n\n### Simple Command\n\nJust description:\n\n```markdown\n---\ndescription: Review code for issues\n---\n\nReview this code for common issues and suggest improvements.\n```\n\n### Standard Command\n\nDescription and tools:\n\n```markdown\n---\ndescription: Review Git changes\nallowed-tools: Bash(git:*), Read\n---\n\nCurrent changes: !`git diff --name-only`\n\nReview each changed file for:\n- Code quality\n- Potential bugs\n- Best practices\n```\n\n### Complex Command\n\nAll common fields:\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [app-name] [environment] [version]\nallowed-tools: Bash(kubectl:*), Bash(helm:*), Read\nmodel: sonnet\n---\n\nDeploy $1 to $2 environment using version $3\n\nPre-deployment checks:\n- Verify $2 configuration\n- Check cluster status: !`kubectl cluster-info`\n- Validate version $3 exists\n\nProceed with deployment following deployment runbook.\n```\n\n### Manual-Only Command\n\nRestricted invocation:\n\n```markdown\n---\ndescription: Approve production deployment\nargument-hint: [deployment-id]\ndisable-model-invocation: true\nallowed-tools: Bash(gh:*)\n---\n\n<!--\nMANUAL APPROVAL REQUIRED\nThis command requires human judgment and cannot be automated.\n-->\n\nReview deployment $1 for production approval:\n\nDeployment details: !`gh api /deployments/$1`\n\nVerify:\n- All tests passed\n- Security scan clean\n- Stakeholder approval\n- Rollback plan ready\n\nType \"APPROVED\" to confirm deployment.\n```\n\n## Validation\n\n### Common Errors\n\n**Invalid YAML syntax:**\n```yaml\n---\ndescription: Missing quote\nallowed-tools: Read, Write\nmodel: sonnet\n---  # âŒ Missing closing quote above\n```\n\n**Fix:** Validate YAML syntax\n\n**Incorrect tool specification:**\n```yaml\nallowed-tools: Bash  # âŒ Missing command filter\n```\n\n**Fix:** Use `Bash(git:*)` format\n\n**Invalid model name:**\n```yaml\nmodel: gpt4  # âŒ Not a valid Claude model\n```\n\n**Fix:** Use `sonnet`, `opus`, or `haiku`\n\n### Validation Checklist\n\nBefore committing command:\n- [ ] YAML syntax valid (no errors)\n- [ ] Description under 60 characters\n- [ ] allowed-tools uses proper format\n- [ ] model is valid value if specified\n- [ ] argument-hint matches positional arguments\n- [ ] disable-model-invocation used appropriately\n\n## Best Practices Summary\n\n1. **Start minimal:** Add frontmatter only when needed\n2. **Document arguments:** Always use argument-hint with arguments\n3. **Restrict tools:** Use most restrictive allowed-tools that works\n4. **Choose right model:** Use haiku for speed, opus for complexity\n5. **Manual-only sparingly:** Only use disable-model-invocation when necessary\n6. **Clear descriptions:** Make commands discoverable in `/help`\n7. **Test thoroughly:** Verify frontmatter works as expected\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/command-development/references/interactive-commands.md","content":"# Interactive Command Patterns\n\nComprehensive guide to creating commands that gather user feedback and make decisions through the AskUserQuestion tool.\n\n## Overview\n\nSome commands need user input that doesn't work well with simple arguments. For example:\n- Choosing between multiple complex options with trade-offs\n- Selecting multiple items from a list\n- Making decisions that require explanation\n- Gathering preferences or configuration interactively\n\nFor these cases, use the **AskUserQuestion tool** within command execution rather than relying on command arguments.\n\n## When to Use AskUserQuestion\n\n### Use AskUserQuestion When:\n\n1. **Multiple choice decisions** with explanations needed\n2. **Complex options** that require context to choose\n3. **Multi-select scenarios** (choosing multiple items)\n4. **Preference gathering** for configuration\n5. **Interactive workflows** that adapt based on answers\n\n### Use Command Arguments When:\n\n1. **Simple values** (file paths, numbers, names)\n2. **Known inputs** user already has\n3. **Scriptable workflows** that should be automatable\n4. **Fast invocations** where prompting would slow down\n\n## AskUserQuestion Basics\n\n### Tool Parameters\n\n```typescript\n{\n  questions: [\n    {\n      question: \"Which authentication method should we use?\",\n      header: \"Auth method\",  // Short label (max 12 chars)\n      multiSelect: false,     // true for multiple selection\n      options: [\n        {\n          label: \"OAuth 2.0\",\n          description: \"Industry standard, supports multiple providers\"\n        },\n        {\n          label: \"JWT\",\n          description: \"Stateless, good for APIs\"\n        },\n        {\n          label: \"Session\",\n          description: \"Traditional, server-side state\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Key points:**\n- Users can always choose \"Other\" to provide custom input (automatic)\n- `multiSelect: true` allows selecting multiple options\n- Options should be 2-4 choices (not more)\n- Can ask 1-4 questions per tool call\n\n## Command Pattern for User Interaction\n\n### Basic Interactive Command\n\n```markdown\n---\ndescription: Interactive setup command\nallowed-tools: AskUserQuestion, Write\n---\n\n# Interactive Plugin Setup\n\nThis command will guide you through configuring the plugin with a series of questions.\n\n## Step 1: Gather Configuration\n\nUse the AskUserQuestion tool to ask:\n\n**Question 1 - Deployment target:**\n- header: \"Deploy to\"\n- question: \"Which deployment platform will you use?\"\n- options:\n  - AWS (Amazon Web Services with ECS/EKS)\n  - GCP (Google Cloud with GKE)\n  - Azure (Microsoft Azure with AKS)\n  - Local (Docker on local machine)\n\n**Question 2 - Environment strategy:**\n- header: \"Environments\"\n- question: \"How many environments do you need?\"\n- options:\n  - Single (Just production)\n  - Standard (Dev, Staging, Production)\n  - Complete (Dev, QA, Staging, Production)\n\n**Question 3 - Features to enable:**\n- header: \"Features\"\n- question: \"Which features do you want to enable?\"\n- multiSelect: true\n- options:\n  - Auto-scaling (Automatic resource scaling)\n  - Monitoring (Health checks and metrics)\n  - CI/CD (Automated deployment pipeline)\n  - Backups (Automated database backups)\n\n## Step 2: Process Answers\n\nBased on the answers received from AskUserQuestion:\n\n1. Parse the deployment target choice\n2. Set up environment-specific configuration\n3. Enable selected features\n4. Generate configuration files\n\n## Step 3: Generate Configuration\n\nCreate `.claude/plugin-name.local.md` with:\n\n\\`\\`\\`yaml\n---\ndeployment_target: [answer from Q1]\nenvironments: [answer from Q2]\nfeatures:\n  auto_scaling: [true if selected in Q3]\n  monitoring: [true if selected in Q3]\n  ci_cd: [true if selected in Q3]\n  backups: [true if selected in Q3]\n---\n\n# Plugin Configuration\n\nGenerated: [timestamp]\nTarget: [deployment_target]\nEnvironments: [environments]\n\\`\\`\\`\n\n## Step 4: Confirm and Next Steps\n\nConfirm configuration created and guide user on next steps.\n```\n\n### Multi-Stage Interactive Workflow\n\n```markdown\n---\ndescription: Multi-stage interactive workflow\nallowed-tools: AskUserQuestion, Read, Write, Bash\n---\n\n# Multi-Stage Deployment Setup\n\nThis command walks through deployment setup in stages, adapting based on your answers.\n\n## Stage 1: Basic Configuration\n\nUse AskUserQuestion to ask about deployment basics.\n\nBased on answers, determine which additional questions to ask.\n\n## Stage 2: Advanced Options (Conditional)\n\nIf user selected \"Advanced\" deployment in Stage 1:\n\nUse AskUserQuestion to ask about:\n- Load balancing strategy\n- Caching configuration\n- Security hardening options\n\nIf user selected \"Simple\" deployment:\n- Skip advanced questions\n- Use sensible defaults\n\n## Stage 3: Confirmation\n\nShow summary of all selections.\n\nUse AskUserQuestion for final confirmation:\n- header: \"Confirm\"\n- question: \"Does this configuration look correct?\"\n- options:\n  - Yes (Proceed with setup)\n  - No (Start over)\n  - Modify (Let me adjust specific settings)\n\nIf \"Modify\", ask which specific setting to change.\n\n## Stage 4: Execute Setup\n\nBased on confirmed configuration, execute setup steps.\n```\n\n## Interactive Question Design\n\n### Question Structure\n\n**Good questions:**\n```markdown\nQuestion: \"Which database should we use for this project?\"\nHeader: \"Database\"\nOptions:\n  - PostgreSQL (Relational, ACID compliant, best for complex queries)\n  - MongoDB (Document store, flexible schema, best for rapid iteration)\n  - Redis (In-memory, fast, best for caching and sessions)\n```\n\n**Poor questions:**\n```markdown\nQuestion: \"Database?\"  // Too vague\nHeader: \"DB\"  // Unclear abbreviation\nOptions:\n  - Option 1  // Not descriptive\n  - Option 2\n```\n\n### Option Design Best Practices\n\n**Clear labels:**\n- Use 1-5 words\n- Specific and descriptive\n- No jargon without context\n\n**Helpful descriptions:**\n- Explain what the option means\n- Mention key benefits or trade-offs\n- Help user make informed decision\n- Keep to 1-2 sentences\n\n**Appropriate number:**\n- 2-4 options per question\n- Don't overwhelm with too many choices\n- Group related options\n- \"Other\" automatically provided\n\n### Multi-Select Questions\n\n**When to use multiSelect:**\n\n```markdown\nUse AskUserQuestion for enabling features:\n\nQuestion: \"Which features do you want to enable?\"\nHeader: \"Features\"\nmultiSelect: true  // Allow selecting multiple\nOptions:\n  - Logging (Detailed operation logs)\n  - Metrics (Performance monitoring)\n  - Alerts (Error notifications)\n  - Backups (Automatic backups)\n```\n\nUser can select any combination: none, some, or all.\n\n**When NOT to use multiSelect:**\n\n```markdown\nQuestion: \"Which authentication method?\"\nmultiSelect: false  // Only one auth method makes sense\n```\n\nMutually exclusive choices should not use multiSelect.\n\n## Command Patterns with AskUserQuestion\n\n### Pattern 1: Simple Yes/No Decision\n\n```markdown\n---\ndescription: Command with confirmation\nallowed-tools: AskUserQuestion, Bash\n---\n\n# Destructive Operation\n\nThis operation will delete all cached data.\n\nUse AskUserQuestion to confirm:\n\nQuestion: \"This will delete all cached data. Are you sure?\"\nHeader: \"Confirm\"\nOptions:\n  - Yes (Proceed with deletion)\n  - No (Cancel operation)\n\nIf user selects \"Yes\":\n  Execute deletion\n  Report completion\n\nIf user selects \"No\":\n  Cancel operation\n  Exit without changes\n```\n\n### Pattern 2: Multiple Configuration Questions\n\n```markdown\n---\ndescription: Multi-question configuration\nallowed-tools: AskUserQuestion, Write\n---\n\n# Project Configuration Setup\n\nGather configuration through multiple questions.\n\nUse AskUserQuestion with multiple questions in one call:\n\n**Question 1:**\n- question: \"Which programming language?\"\n- header: \"Language\"\n- options: Python, TypeScript, Go, Rust\n\n**Question 2:**\n- question: \"Which test framework?\"\n- header: \"Testing\"\n- options: Jest, PyTest, Go Test, Cargo Test\n  (Adapt based on language from Q1)\n\n**Question 3:**\n- question: \"Which CI/CD platform?\"\n- header: \"CI/CD\"\n- options: GitHub Actions, GitLab CI, CircleCI\n\n**Question 4:**\n- question: \"Which features do you need?\"\n- header: \"Features\"\n- multiSelect: true\n- options: Linting, Type checking, Code coverage, Security scanning\n\nProcess all answers together to generate cohesive configuration.\n```\n\n### Pattern 3: Conditional Question Flow\n\n```markdown\n---\ndescription: Conditional interactive workflow\nallowed-tools: AskUserQuestion, Read, Write\n---\n\n# Adaptive Configuration\n\n## Question 1: Deployment Complexity\n\nUse AskUserQuestion:\n\nQuestion: \"How complex is your deployment?\"\nHeader: \"Complexity\"\nOptions:\n  - Simple (Single server, straightforward)\n  - Standard (Multiple servers, load balancing)\n  - Complex (Microservices, orchestration)\n\n## Conditional Questions Based on Answer\n\nIf answer is \"Simple\":\n  - No additional questions\n  - Use minimal configuration\n\nIf answer is \"Standard\":\n  - Ask about load balancing strategy\n  - Ask about scaling policy\n\nIf answer is \"Complex\":\n  - Ask about orchestration platform (Kubernetes, Docker Swarm)\n  - Ask about service mesh (Istio, Linkerd, None)\n  - Ask about monitoring (Prometheus, Datadog, CloudWatch)\n  - Ask about logging aggregation\n\n## Process Conditional Answers\n\nGenerate configuration appropriate for selected complexity level.\n```\n\n### Pattern 4: Iterative Collection\n\n```markdown\n---\ndescription: Collect multiple items iteratively\nallowed-tools: AskUserQuestion, Write\n---\n\n# Collect Team Members\n\nWe'll collect team member information for the project.\n\n## Question: How many team members?\n\nUse AskUserQuestion:\n\nQuestion: \"How many team members should we set up?\"\nHeader: \"Team size\"\nOptions:\n  - 2 people\n  - 3 people\n  - 4 people\n  - 6 people\n\n## Iterate Through Team Members\n\nFor each team member (1 to N based on answer):\n\nUse AskUserQuestion for member details:\n\nQuestion: \"What role for team member [number]?\"\nHeader: \"Role\"\nOptions:\n  - Frontend Developer\n  - Backend Developer\n  - DevOps Engineer\n  - QA Engineer\n  - Designer\n\nStore each member's information.\n\n## Generate Team Configuration\n\nAfter collecting all N members, create team configuration file with all members and their roles.\n```\n\n### Pattern 5: Dependency Selection\n\n```markdown\n---\ndescription: Select dependencies with multi-select\nallowed-tools: AskUserQuestion\n---\n\n# Configure Project Dependencies\n\n## Question: Required Libraries\n\nUse AskUserQuestion with multiSelect:\n\nQuestion: \"Which libraries does your project need?\"\nHeader: \"Dependencies\"\nmultiSelect: true\nOptions:\n  - React (UI framework)\n  - Express (Web server)\n  - TypeORM (Database ORM)\n  - Jest (Testing framework)\n  - Axios (HTTP client)\n\nUser can select any combination.\n\n## Process Selections\n\nFor each selected library:\n- Add to package.json dependencies\n- Generate sample configuration\n- Create usage examples\n- Update documentation\n```\n\n## Best Practices for Interactive Commands\n\n### Question Design\n\n1. **Clear and specific**: Question should be unambiguous\n2. **Concise header**: Max 12 characters for clean display\n3. **Helpful options**: Labels are clear, descriptions explain trade-offs\n4. **Appropriate count**: 2-4 options per question, 1-4 questions per call\n5. **Logical order**: Questions flow naturally\n\n### Error Handling\n\n```markdown\n# Handle AskUserQuestion Responses\n\nAfter calling AskUserQuestion, verify answers received:\n\nIf answers are empty or invalid:\n  Something went wrong gathering responses.\n\n  Please try again or provide configuration manually:\n  [Show alternative approach]\n\n  Exit.\n\nIf answers look correct:\n  Process as expected\n```\n\n### Progressive Disclosure\n\n```markdown\n# Start Simple, Get Detailed as Needed\n\n## Question 1: Setup Type\n\nUse AskUserQuestion:\n\nQuestion: \"How would you like to set up?\"\nHeader: \"Setup type\"\nOptions:\n  - Quick (Use recommended defaults)\n  - Custom (Configure all options)\n  - Guided (Step-by-step with explanations)\n\nIf \"Quick\":\n  Apply defaults, minimal questions\n\nIf \"Custom\":\n  Ask all available configuration questions\n\nIf \"Guided\":\n  Ask questions with extra explanation\n  Provide recommendations along the way\n```\n\n### Multi-Select Guidelines\n\n**Good multi-select use:**\n```markdown\nQuestion: \"Which features do you want to enable?\"\nmultiSelect: true\nOptions:\n  - Logging\n  - Metrics\n  - Alerts\n  - Backups\n\nReason: User might want any combination\n```\n\n**Bad multi-select use:**\n```markdown\nQuestion: \"Which database engine?\"\nmultiSelect: true  // âŒ Should be single-select\n\nReason: Can only use one database engine\n```\n\n## Advanced Patterns\n\n### Validation Loop\n\n```markdown\n---\ndescription: Interactive with validation\nallowed-tools: AskUserQuestion, Bash\n---\n\n# Setup with Validation\n\n## Gather Configuration\n\nUse AskUserQuestion to collect settings.\n\n## Validate Configuration\n\nCheck if configuration is valid:\n- Required dependencies available?\n- Settings compatible with each other?\n- No conflicts detected?\n\nIf validation fails:\n  Show validation errors\n\n  Use AskUserQuestion to ask:\n\n  Question: \"Configuration has issues. What would you like to do?\"\n  Header: \"Next step\"\n  Options:\n    - Fix (Adjust settings to resolve issues)\n    - Override (Proceed despite warnings)\n    - Cancel (Abort setup)\n\n  Based on answer, retry or proceed or exit.\n```\n\n### Build Configuration Incrementally\n\n```markdown\n---\ndescription: Incremental configuration builder\nallowed-tools: AskUserQuestion, Write, Read\n---\n\n# Incremental Setup\n\n## Phase 1: Core Settings\n\nUse AskUserQuestion for core settings.\n\nSave to `.claude/config-partial.yml`\n\n## Phase 2: Review Core Settings\n\nShow user the core settings:\n\nBased on these core settings, you need to configure:\n- [Setting A] (because you chose [X])\n- [Setting B] (because you chose [Y])\n\nReady to continue?\n\n## Phase 3: Detailed Settings\n\nUse AskUserQuestion for settings based on Phase 1 answers.\n\nMerge with core settings.\n\n## Phase 4: Final Review\n\nPresent complete configuration.\n\nUse AskUserQuestion for confirmation:\n\nQuestion: \"Is this configuration correct?\"\nOptions:\n  - Yes (Save and apply)\n  - No (Start over)\n  - Modify (Edit specific settings)\n```\n\n### Dynamic Options Based on Context\n\n```markdown\n---\ndescription: Context-aware questions\nallowed-tools: AskUserQuestion, Bash, Read\n---\n\n# Context-Aware Setup\n\n## Detect Current State\n\nCheck existing configuration:\n- Current language: !`detect-language.sh`\n- Existing frameworks: !`detect-frameworks.sh`\n- Available tools: !`check-tools.sh`\n\n## Ask Context-Appropriate Questions\n\nBased on detected language, ask relevant questions.\n\nIf language is TypeScript:\n\n  Use AskUserQuestion:\n\n  Question: \"Which TypeScript features should we enable?\"\n  Options:\n    - Strict Mode (Maximum type safety)\n    - Decorators (Experimental decorator support)\n    - Path Mapping (Module path aliases)\n\nIf language is Python:\n\n  Use AskUserQuestion:\n\n  Question: \"Which Python tools should we configure?\"\n  Options:\n    - Type Hints (mypy for type checking)\n    - Black (Code formatting)\n    - Pylint (Linting and style)\n\nQuestions adapt to project context.\n```\n\n## Real-World Example: Multi-Agent Swarm Launch\n\n**From multi-agent-swarm plugin:**\n\n```markdown\n---\ndescription: Launch multi-agent swarm\nallowed-tools: AskUserQuestion, Read, Write, Bash\n---\n\n# Launch Multi-Agent Swarm\n\n## Interactive Mode (No Task List Provided)\n\nIf user didn't provide task list file, help create one interactively.\n\n### Question 1: Agent Count\n\nUse AskUserQuestion:\n\nQuestion: \"How many agents should we launch?\"\nHeader: \"Agent count\"\nOptions:\n  - 2 agents (Best for simple projects)\n  - 3 agents (Good for medium projects)\n  - 4 agents (Standard team size)\n  - 6 agents (Large projects)\n  - 8 agents (Complex multi-component projects)\n\n### Question 2: Task Definition Approach\n\nUse AskUserQuestion:\n\nQuestion: \"How would you like to define tasks?\"\nHeader: \"Task setup\"\nOptions:\n  - File (I have a task list file ready)\n  - Guided (Help me create tasks interactively)\n  - Custom (Other approach)\n\nIf \"File\":\n  Ask for file path\n  Validate file exists and has correct format\n\nIf \"Guided\":\n  Enter iterative task creation mode (see below)\n\n### Question 3: Coordination Mode\n\nUse AskUserQuestion:\n\nQuestion: \"How should agents coordinate?\"\nHeader: \"Coordination\"\nOptions:\n  - Team Leader (One agent coordinates others)\n  - Collaborative (Agents coordinate as peers)\n  - Autonomous (Independent work, minimal coordination)\n\n### Iterative Task Creation (If \"Guided\" Selected)\n\nFor each agent (1 to N from Question 1):\n\n**Question A: Agent Name**\nQuestion: \"What should we call agent [number]?\"\nHeader: \"Agent name\"\nOptions:\n  - auth-agent\n  - api-agent\n  - ui-agent\n  - db-agent\n  (Provide relevant suggestions based on common patterns)\n\n**Question B: Task Type**\nQuestion: \"What task for [agent-name]?\"\nHeader: \"Task type\"\nOptions:\n  - Authentication (User auth, JWT, OAuth)\n  - API Endpoints (REST/GraphQL APIs)\n  - UI Components (Frontend components)\n  - Database (Schema, migrations, queries)\n  - Testing (Test suites and coverage)\n  - Documentation (Docs, README, guides)\n\n**Question C: Dependencies**\nQuestion: \"What does [agent-name] depend on?\"\nHeader: \"Dependencies\"\nmultiSelect: true\nOptions:\n  - [List of previously defined agents]\n  - No dependencies\n\n**Question D: Base Branch**\nQuestion: \"Which base branch for PR?\"\nHeader: \"PR base\"\nOptions:\n  - main\n  - staging\n  - develop\n\nStore all task information for each agent.\n\n### Generate Task List File\n\nAfter collecting all agent task details:\n\n1. Ask for project name\n2. Generate task list in proper format\n3. Save to `.daisy/swarm/tasks.md`\n4. Show user the file path\n5. Proceed with launch using generated task list\n```\n\n## Best Practices\n\n### Question Writing\n\n1. **Be specific**: \"Which database?\" not \"Choose option?\"\n2. **Explain trade-offs**: Describe pros/cons in option descriptions\n3. **Provide context**: Question text should stand alone\n4. **Guide decisions**: Help user make informed choice\n5. **Keep concise**: Header max 12 chars, descriptions 1-2 sentences\n\n### Option Design\n\n1. **Meaningful labels**: Specific, clear names\n2. **Informative descriptions**: Explain what each option does\n3. **Show trade-offs**: Help user understand implications\n4. **Consistent detail**: All options equally explained\n5. **2-4 options**: Not too few, not too many\n\n### Flow Design\n\n1. **Logical order**: Questions flow naturally\n2. **Build on previous**: Later questions use earlier answers\n3. **Minimize questions**: Ask only what's needed\n4. **Group related**: Ask related questions together\n5. **Show progress**: Indicate where in flow\n\n### User Experience\n\n1. **Set expectations**: Tell user what to expect\n2. **Explain why**: Help user understand purpose\n3. **Provide defaults**: Suggest recommended options\n4. **Allow escape**: Let user cancel or restart\n5. **Confirm actions**: Summarize before executing\n\n## Common Patterns\n\n### Pattern: Feature Selection\n\n```markdown\nUse AskUserQuestion:\n\nQuestion: \"Which features do you need?\"\nHeader: \"Features\"\nmultiSelect: true\nOptions:\n  - Authentication\n  - Authorization\n  - Rate Limiting\n  - Caching\n```\n\n### Pattern: Environment Configuration\n\n```markdown\nUse AskUserQuestion:\n\nQuestion: \"Which environment is this?\"\nHeader: \"Environment\"\nOptions:\n  - Development (Local development)\n  - Staging (Pre-production testing)\n  - Production (Live environment)\n```\n\n### Pattern: Priority Selection\n\n```markdown\nUse AskUserQuestion:\n\nQuestion: \"What's the priority for this task?\"\nHeader: \"Priority\"\nOptions:\n  - Critical (Must be done immediately)\n  - High (Important, do soon)\n  - Medium (Standard priority)\n  - Low (Nice to have)\n```\n\n### Pattern: Scope Selection\n\n```markdown\nUse AskUserQuestion:\n\nQuestion: \"What scope should we analyze?\"\nHeader: \"Scope\"\nOptions:\n  - Current file (Just this file)\n  - Current directory (All files in directory)\n  - Entire project (Full codebase scan)\n```\n\n## Combining Arguments and Questions\n\n### Use Both Appropriately\n\n**Arguments for known values:**\n```markdown\n---\nargument-hint: [project-name]\nallowed-tools: AskUserQuestion, Write\n---\n\nSetup for project: $1\n\nNow gather additional configuration...\n\nUse AskUserQuestion for options that require explanation.\n```\n\n**Questions for complex choices:**\n```markdown\nProject name from argument: $1\n\nNow use AskUserQuestion to choose:\n- Architecture pattern\n- Technology stack\n- Deployment strategy\n\nThese require explanation, so questions work better than arguments.\n```\n\n## Troubleshooting\n\n**Questions not appearing:**\n- Verify AskUserQuestion in allowed-tools\n- Check question format is correct\n- Ensure options array has 2-4 items\n\n**User can't make selection:**\n- Check option labels are clear\n- Verify descriptions are helpful\n- Consider if too many options\n- Ensure multiSelect setting is correct\n\n**Flow feels confusing:**\n- Reduce number of questions\n- Group related questions\n- Add explanation between stages\n- Show progress through workflow\n\nWith AskUserQuestion, commands become interactive wizards that guide users through complex decisions while maintaining the clarity that simple arguments provide for straightforward inputs.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/command-development/references/marketplace-considerations.md","content":"# Marketplace Considerations for Commands\n\nGuidelines for creating commands designed for distribution and marketplace success.\n\n## Overview\n\nCommands distributed through marketplaces need additional consideration beyond personal use commands. They must work across environments, handle diverse use cases, and provide excellent user experience for unknown users.\n\n## Design for Distribution\n\n### Universal Compatibility\n\n**Cross-platform considerations:**\n\n```markdown\n---\ndescription: Cross-platform command\nallowed-tools: Bash(*)\n---\n\n# Platform-Aware Command\n\nDetecting platform...\n\ncase \"$(uname)\" in\n  Darwin*)  PLATFORM=\"macOS\" ;;\n  Linux*)   PLATFORM=\"Linux\" ;;\n  MINGW*|MSYS*|CYGWIN*) PLATFORM=\"Windows\" ;;\n  *)        PLATFORM=\"Unknown\" ;;\nesac\n\nPlatform: $PLATFORM\n\n<!-- Adjust behavior based on platform -->\nif [ \"$PLATFORM\" = \"Windows\" ]; then\n  # Windows-specific handling\n  PATH_SEP=\"\\\\\"\n  NULL_DEVICE=\"NUL\"\nelse\n  # Unix-like handling\n  PATH_SEP=\"/\"\n  NULL_DEVICE=\"/dev/null\"\nfi\n\n[Platform-appropriate implementation...]\n```\n\n**Avoid platform-specific commands:**\n\n```markdown\n<!-- BAD: macOS-specific -->\n!`pbcopy < file.txt`\n\n<!-- GOOD: Platform detection -->\nif command -v pbcopy > /dev/null; then\n  pbcopy < file.txt\nelif command -v xclip > /dev/null; then\n  xclip -selection clipboard < file.txt\nelif command -v clip.exe > /dev/null; then\n  cat file.txt | clip.exe\nelse\n  echo \"Clipboard not available on this platform\"\nfi\n```\n\n### Minimal Dependencies\n\n**Check for required tools:**\n\n```markdown\n---\ndescription: Dependency-aware command\nallowed-tools: Bash(*)\n---\n\n# Check Dependencies\n\nRequired tools:\n- git\n- jq\n- node\n\nChecking availability...\n\nMISSING_DEPS=\"\"\n\nfor tool in git jq node; do\n  if ! command -v $tool > /dev/null; then\n    MISSING_DEPS=\"$MISSING_DEPS $tool\"\n  fi\ndone\n\nif [ -n \"$MISSING_DEPS\" ]; then\n  âŒ ERROR: Missing required dependencies:$MISSING_DEPS\n\n  INSTALLATION:\n  - git: https://git-scm.com/downloads\n  - jq: https://stedolan.github.io/jq/download/\n  - node: https://nodejs.org/\n\n  Install missing tools and try again.\n\n  Exit.\nfi\n\nâœ“ All dependencies available\n\n[Continue with command...]\n```\n\n**Document optional dependencies:**\n\n```markdown\n<!--\nDEPENDENCIES:\n  Required:\n  - git 2.0+: Version control\n  - jq 1.6+: JSON processing\n\n  Optional:\n  - gh: GitHub CLI (for PR operations)\n  - docker: Container operations (for containerized tests)\n\n  Feature availability depends on installed tools.\n-->\n```\n\n### Graceful Degradation\n\n**Handle missing features:**\n\n```markdown\n---\ndescription: Feature-aware command\n---\n\n# Feature Detection\n\nDetecting available features...\n\nFEATURES=\"\"\n\nif command -v gh > /dev/null; then\n  FEATURES=\"$FEATURES github\"\nfi\n\nif command -v docker > /dev/null; then\n  FEATURES=\"$FEATURES docker\"\nfi\n\nAvailable features: $FEATURES\n\nif echo \"$FEATURES\" | grep -q \"github\"; then\n  # Full functionality with GitHub integration\n  echo \"âœ“ GitHub integration available\"\nelse\n  # Reduced functionality without GitHub\n  echo \"âš  Limited functionality: GitHub CLI not installed\"\n  echo \"  Install 'gh' for full features\"\nfi\n\n[Adapt behavior based on available features...]\n```\n\n## User Experience for Unknown Users\n\n### Clear Onboarding\n\n**First-run experience:**\n\n```markdown\n---\ndescription: Command with onboarding\nallowed-tools: Read, Write\n---\n\n# First Run Check\n\nif [ ! -f \".claude/command-initialized\" ]; then\n  **Welcome to Command Name!**\n\n  This appears to be your first time using this command.\n\n  WHAT THIS COMMAND DOES:\n  [Brief explanation of purpose and benefits]\n\n  QUICK START:\n  1. Basic usage: /command [arg]\n  2. For help: /command help\n  3. Examples: /command examples\n\n  SETUP:\n  No additional setup required. You're ready to go!\n\n  âœ“ Initialization complete\n\n  [Create initialization marker]\n\n  Ready to proceed with your request...\nfi\n\n[Normal command execution...]\n```\n\n**Progressive feature discovery:**\n\n```markdown\n---\ndescription: Command with tips\n---\n\n# Command Execution\n\n[Main functionality...]\n\n---\n\nðŸ’¡ TIP: Did you know?\n\nYou can speed up this command with the --fast flag:\n  /command --fast [args]\n\nFor more tips: /command tips\n```\n\n### Comprehensive Error Handling\n\n**Anticipate user mistakes:**\n\n```markdown\n---\ndescription: Forgiving command\n---\n\n# User Input Handling\n\nArgument: \"$1\"\n\n<!-- Check for common typos -->\nif [ \"$1\" = \"hlep\" ] || [ \"$1\" = \"hepl\" ]; then\n  Did you mean: help?\n\n  Showing help instead...\n  [Display help]\n\n  Exit.\nfi\n\n<!-- Suggest similar commands if not found -->\nif [ \"$1\" != \"valid-option1\" ] && [ \"$1\" != \"valid-option2\" ]; then\n  âŒ Unknown option: $1\n\n  Did you mean:\n  - valid-option1 (most similar)\n  - valid-option2\n\n  For all options: /command help\n\n  Exit.\nfi\n\n[Command continues...]\n```\n\n**Helpful diagnostics:**\n\n```markdown\n---\ndescription: Diagnostic command\n---\n\n# Operation Failed\n\nThe operation could not complete.\n\n**Diagnostic Information:**\n\nEnvironment:\n- Platform: $(uname)\n- Shell: $SHELL\n- Working directory: $(pwd)\n- Command: /command $@\n\nChecking common issues:\n- Git repository: $(git rev-parse --git-dir 2>&1)\n- Write permissions: $(test -w . && echo \"OK\" || echo \"DENIED\")\n- Required files: $(test -f config.yml && echo \"Found\" || echo \"Missing\")\n\nThis information helps debug the issue.\n\nFor support, include the above diagnostics.\n```\n\n## Distribution Best Practices\n\n### Namespace Awareness\n\n**Avoid name collisions:**\n\n```markdown\n---\ndescription: Namespaced command\n---\n\n<!--\nCOMMAND NAME: plugin-name-command\n\nThis command is namespaced with the plugin name to avoid\nconflicts with commands from other plugins.\n\nAlternative naming approaches:\n- Use plugin prefix: /plugin-command\n- Use category: /category-command\n- Use verb-noun: /verb-noun\n\nChosen approach: plugin-name prefix\nReasoning: Clearest ownership, least likely to conflict\n-->\n\n# Plugin Name Command\n\n[Implementation...]\n```\n\n**Document naming rationale:**\n\n```markdown\n<!--\nNAMING DECISION:\n\nCommand name: /deploy-app\n\nAlternatives considered:\n- /deploy: Too generic, likely conflicts\n- /app-deploy: Less intuitive ordering\n- /my-plugin-deploy: Too verbose\n\nFinal choice balances:\n- Discoverability (clear purpose)\n- Brevity (easy to type)\n- Uniqueness (unlikely conflicts)\n-->\n```\n\n### Configurability\n\n**User preferences:**\n\n```markdown\n---\ndescription: Configurable command\nallowed-tools: Read\n---\n\n# Load User Configuration\n\nDefault configuration:\n- verbose: false\n- color: true\n- max_results: 10\n\nChecking for user config: .claude/plugin-name.local.md\n\nif [ -f \".claude/plugin-name.local.md\" ]; then\n  # Parse YAML frontmatter for settings\n  VERBOSE=$(grep \"^verbose:\" .claude/plugin-name.local.md | cut -d: -f2 | tr -d ' ')\n  COLOR=$(grep \"^color:\" .claude/plugin-name.local.md | cut -d: -f2 | tr -d ' ')\n  MAX_RESULTS=$(grep \"^max_results:\" .claude/plugin-name.local.md | cut -d: -f2 | tr -d ' ')\n\n  echo \"âœ“ Using user configuration\"\nelse\n  echo \"Using default configuration\"\n  echo \"Create .claude/plugin-name.local.md to customize\"\nfi\n\n[Use configuration in command...]\n```\n\n**Sensible defaults:**\n\n```markdown\n---\ndescription: Command with smart defaults\n---\n\n# Smart Defaults\n\nConfiguration:\n- Format: ${FORMAT:-json}  # Defaults to json\n- Output: ${OUTPUT:-stdout}  # Defaults to stdout\n- Verbose: ${VERBOSE:-false}  # Defaults to false\n\nThese defaults work for 80% of use cases.\n\nOverride with arguments:\n  /command --format yaml --output file.txt --verbose\n\nOr set in .claude/plugin-name.local.md:\n\\`\\`\\`yaml\n---\nformat: yaml\noutput: custom.txt\nverbose: true\n---\n\\`\\`\\`\n```\n\n### Version Compatibility\n\n**Version checking:**\n\n```markdown\n---\ndescription: Version-aware command\n---\n\n<!--\nCOMMAND VERSION: 2.1.0\n\nCOMPATIBILITY:\n- Requires plugin version: >= 2.0.0\n- Breaking changes from v1.x documented in MIGRATION.md\n\nVERSION HISTORY:\n- v2.1.0: Added --new-feature flag\n- v2.0.0: BREAKING: Changed argument order\n- v1.0.0: Initial release\n-->\n\n# Version Check\n\nCommand version: 2.1.0\nPlugin version: [detect from plugin.json]\n\nif [  \"$PLUGIN_VERSION\" < \"2.0.0\" ]; then\n  âŒ ERROR: Incompatible plugin version\n\n  This command requires plugin version >= 2.0.0\n  Current version: $PLUGIN_VERSION\n\n  Update plugin:\n    /plugin update plugin-name\n\n  Exit.\nfi\n\nâœ“ Version compatible\n\n[Command continues...]\n```\n\n**Deprecation warnings:**\n\n```markdown\n---\ndescription: Command with deprecation warnings\n---\n\n# Deprecation Check\n\nif [ \"$1\" = \"--old-flag\" ]; then\n  âš ï¸  DEPRECATION WARNING\n\n  The --old-flag option is deprecated as of v2.0.0\n  It will be removed in v3.0.0 (est. June 2025)\n\n  Use instead: --new-flag\n\n  Example:\n    Old: /command --old-flag value\n    New: /command --new-flag value\n\n  See migration guide: /command migrate\n\n  Continuing with deprecated behavior for now...\nfi\n\n[Handle both old and new flags during deprecation period...]\n```\n\n## Marketplace Presentation\n\n### Command Discovery\n\n**Descriptive naming:**\n\n```markdown\n---\ndescription: Review pull request with security and quality checks\n---\n\n<!-- GOOD: Descriptive name and description -->\n```\n\n```markdown\n---\ndescription: Do the thing\n---\n\n<!-- BAD: Vague description -->\n```\n\n**Searchable keywords:**\n\n```markdown\n<!--\nKEYWORDS: security, code-review, quality, validation, audit\n\nThese keywords help users discover this command when searching\nfor related functionality in the marketplace.\n-->\n```\n\n### Showcase Examples\n\n**Compelling demonstrations:**\n\n```markdown\n---\ndescription: Advanced code analysis command\n---\n\n# Code Analysis Command\n\nThis command performs deep code analysis with actionable insights.\n\n## Demo: Quick Security Audit\n\nTry it now:\n\\`\\`\\`\n/analyze-code src/ --security\n\\`\\`\\`\n\n**What you'll get:**\n- Security vulnerability detection\n- Code quality metrics\n- Performance bottleneck identification\n- Actionable recommendations\n\n**Sample output:**\n\\`\\`\\`\nSecurity Analysis Results\n=========================\n\nðŸ”´ Critical (2):\n  - SQL injection risk in users.js:45\n  - XSS vulnerability in display.js:23\n\nðŸŸ¡ Warnings (5):\n  - Unvalidated input in api.js:67\n  ...\n\nRecommendations:\n1. Fix critical issues immediately\n2. Review warnings before next release\n3. Run /analyze-code --fix for auto-fixes\n\\`\\`\\`\n\n---\n\nReady to analyze your code...\n\n[Command implementation...]\n```\n\n### User Reviews and Feedback\n\n**Feedback mechanism:**\n\n```markdown\n---\ndescription: Command with feedback\n---\n\n# Command Complete\n\n[Command results...]\n\n---\n\n**How was your experience?**\n\nThis helps improve the command for everyone.\n\nRate this command:\n- ðŸ‘ Helpful\n- ðŸ‘Ž Not helpful\n- ðŸ› Found a bug\n- ðŸ’¡ Have a suggestion\n\nReply with an emoji or:\n- /command feedback\n\nYour feedback matters!\n```\n\n**Usage analytics preparation:**\n\n```markdown\n<!--\nANALYTICS NOTES:\n\nTrack for improvement:\n- Most common arguments\n- Failure rates\n- Average execution time\n- User satisfaction scores\n\nPrivacy-preserving:\n- No personally identifiable information\n- Aggregate statistics only\n- User opt-out respected\n-->\n```\n\n## Quality Standards\n\n### Professional Polish\n\n**Consistent branding:**\n\n```markdown\n---\ndescription: Branded command\n---\n\n# âœ¨ Command Name\n\nPart of the [Plugin Name] suite\n\n[Command functionality...]\n\n---\n\n**Need Help?**\n- Documentation: https://docs.example.com\n- Support: support@example.com\n- Community: https://community.example.com\n\nPowered by Plugin Name v2.1.0\n```\n\n**Attention to detail:**\n\n```markdown\n<!-- Details that matter -->\n\nâœ“ Use proper emoji/symbols consistently\nâœ“ Align output columns neatly\nâœ“ Format numbers with thousands separators\nâœ“ Use color/formatting appropriately\nâœ“ Provide progress indicators\nâœ“ Show estimated time remaining\nâœ“ Confirm successful operations\n```\n\n### Reliability\n\n**Idempotency:**\n\n```markdown\n---\ndescription: Idempotent command\n---\n\n# Safe Repeated Execution\n\nChecking if operation already completed...\n\nif [ -f \".claude/operation-completed.flag\" ]; then\n  â„¹ï¸  Operation already completed\n\n  Completed at: $(cat .claude/operation-completed.flag)\n\n  To re-run:\n  1. Remove flag: rm .claude/operation-completed.flag\n  2. Run command again\n\n  Otherwise, no action needed.\n\n  Exit.\nfi\n\nPerforming operation...\n\n[Safe, repeatable operation...]\n\nMarking complete...\necho \"$(date)\" > .claude/operation-completed.flag\n```\n\n**Atomic operations:**\n\n```markdown\n---\ndescription: Atomic command\n---\n\n# Atomic Operation\n\nThis operation is atomic - either fully succeeds or fully fails.\n\nCreating temporary workspace...\nTEMP_DIR=$(mktemp -d)\n\nPerforming changes in isolated environment...\n[Make changes in $TEMP_DIR]\n\nif [ $? -eq 0 ]; then\n  âœ“ Changes validated\n\n  Applying changes atomically...\n  mv $TEMP_DIR/* ./target/\n\n  âœ“ Operation complete\nelse\n  âŒ Changes failed validation\n\n  Rolling back...\n  rm -rf $TEMP_DIR\n\n  No changes applied. Safe to retry.\nfi\n```\n\n## Testing for Distribution\n\n### Pre-Release Checklist\n\n```markdown\n<!--\nPRE-RELEASE CHECKLIST:\n\nFunctionality:\n- [ ] Works on macOS\n- [ ] Works on Linux\n- [ ] Works on Windows (WSL)\n- [ ] All arguments tested\n- [ ] Error cases handled\n- [ ] Edge cases covered\n\nUser Experience:\n- [ ] Clear description\n- [ ] Helpful error messages\n- [ ] Examples provided\n- [ ] First-run experience good\n- [ ] Documentation complete\n\nDistribution:\n- [ ] No hardcoded paths\n- [ ] Dependencies documented\n- [ ] Configuration options clear\n- [ ] Version number set\n- [ ] Changelog updated\n\nQuality:\n- [ ] No TODO comments\n- [ ] No debug code\n- [ ] Performance acceptable\n- [ ] Security reviewed\n- [ ] Privacy considered\n\nSupport:\n- [ ] README complete\n- [ ] Troubleshooting guide\n- [ ] Support contact provided\n- [ ] Feedback mechanism\n- [ ] License specified\n-->\n```\n\n### Beta Testing\n\n**Beta release approach:**\n\n```markdown\n---\ndescription: Beta command (v0.9.0)\n---\n\n# ðŸ§ª Beta Command\n\n**This is a beta release**\n\nFeatures may change based on feedback.\n\nBETA STATUS:\n- Version: 0.9.0\n- Stability: Experimental\n- Support: Limited\n- Feedback: Encouraged\n\nKnown limitations:\n- Performance not optimized\n- Some edge cases not handled\n- Documentation incomplete\n\nHelp improve this command:\n- Report issues: /command report-issue\n- Suggest features: /command suggest\n- Join beta testers: /command join-beta\n\n---\n\n[Command implementation...]\n\n---\n\n**Thank you for beta testing!**\n\nYour feedback helps make this command better.\n```\n\n## Maintenance and Updates\n\n### Update Strategy\n\n**Versioned commands:**\n\n```markdown\n<!--\nVERSION STRATEGY:\n\nMajor (X.0.0): Breaking changes\n- Document all breaking changes\n- Provide migration guide\n- Support old version briefly\n\nMinor (x.Y.0): New features\n- Backward compatible\n- Announce new features\n- Update examples\n\nPatch (x.y.Z): Bug fixes\n- No user-facing changes\n- Update changelog\n- Security fixes prioritized\n\nRelease schedule:\n- Patches: As needed\n- Minors: Monthly\n- Majors: Annually or as needed\n-->\n```\n\n**Update notifications:**\n\n```markdown\n---\ndescription: Update-aware command\n---\n\n# Check for Updates\n\nCurrent version: 2.1.0\nLatest version: [check if available]\n\nif [ \"$CURRENT_VERSION\" != \"$LATEST_VERSION\" ]; then\n  ðŸ“¢ UPDATE AVAILABLE\n\n  New version: $LATEST_VERSION\n  Current: $CURRENT_VERSION\n\n  What's new:\n  - Feature improvements\n  - Bug fixes\n  - Performance enhancements\n\n  Update with:\n    /plugin update plugin-name\n\n  Release notes: https://releases.example.com/v$LATEST_VERSION\nfi\n\n[Command continues...]\n```\n\n## Best Practices Summary\n\n### Distribution Design\n\n1. **Universal**: Works across platforms and environments\n2. **Self-contained**: Minimal dependencies, clear requirements\n3. **Graceful**: Degrades gracefully when features unavailable\n4. **Forgiving**: Anticipates and handles user mistakes\n5. **Helpful**: Clear errors, good defaults, excellent docs\n\n### Marketplace Success\n\n1. **Discoverable**: Clear name, good description, searchable keywords\n2. **Professional**: Polished presentation, consistent branding\n3. **Reliable**: Tested thoroughly, handles edge cases\n4. **Maintainable**: Versioned, updated regularly, supported\n5. **User-focused**: Great UX, responsive to feedback\n\n### Quality Standards\n\n1. **Complete**: Fully documented, all features working\n2. **Tested**: Works in real environments, edge cases handled\n3. **Secure**: No vulnerabilities, safe operations\n4. **Performant**: Reasonable speed, resource-efficient\n5. **Ethical**: Privacy-respecting, user consent\n\nWith these considerations, commands become marketplace-ready and delight users across diverse environments and use cases.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/command-development/references/plugin-features-reference.md","content":"# Plugin-Specific Command Features Reference\n\nThis reference covers features and patterns specific to commands bundled in Claude Code plugins.\n\n## Table of Contents\n\n- [Plugin Command Discovery](#plugin-command-discovery)\n- [CLAUDE_PLUGIN_ROOT Environment Variable](#claude_plugin_root-environment-variable)\n- [Plugin Command Patterns](#plugin-command-patterns)\n- [Integration with Plugin Components](#integration-with-plugin-components)\n- [Validation Patterns](#validation-patterns)\n\n## Plugin Command Discovery\n\n### Auto-Discovery\n\nClaude Code automatically discovers commands in plugins using the following locations:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/              # Auto-discovered commands\nâ”‚   â”œâ”€â”€ foo.md            # /foo (plugin:plugin-name)\nâ”‚   â””â”€â”€ bar.md            # /bar (plugin:plugin-name)\nâ””â”€â”€ plugin.json           # Plugin manifest\n```\n\n**Key points:**\n- Commands are discovered at plugin load time\n- No manual registration required\n- Commands appear in `/help` with \"(plugin:plugin-name)\" label\n- Subdirectories create namespaces\n\n### Namespaced Plugin Commands\n\nOrganize commands in subdirectories for logical grouping:\n\n```\nplugin-name/\nâ””â”€â”€ commands/\n    â”œâ”€â”€ review/\n    â”‚   â”œâ”€â”€ security.md    # /security (plugin:plugin-name:review)\n    â”‚   â””â”€â”€ style.md       # /style (plugin:plugin-name:review)\n    â””â”€â”€ deploy/\n        â”œâ”€â”€ staging.md     # /staging (plugin:plugin-name:deploy)\n        â””â”€â”€ prod.md        # /prod (plugin:plugin-name:deploy)\n```\n\n**Namespace behavior:**\n- Subdirectory name becomes namespace\n- Shown as \"(plugin:plugin-name:namespace)\" in `/help`\n- Helps organize related commands\n- Use when plugin has 5+ commands\n\n### Command Naming Conventions\n\n**Plugin command names should:**\n1. Be descriptive and action-oriented\n2. Avoid conflicts with common command names\n3. Use hyphens for multi-word names\n4. Consider prefixing with plugin name for uniqueness\n\n**Examples:**\n```\nGood:\n- /mylyn-sync          (plugin-specific prefix)\n- /analyze-performance (descriptive action)\n- /docker-compose-up   (clear purpose)\n\nAvoid:\n- /test               (conflicts with common name)\n- /run                (too generic)\n- /do-stuff           (not descriptive)\n```\n\n## CLAUDE_PLUGIN_ROOT Environment Variable\n\n### Purpose\n\n`${CLAUDE_PLUGIN_ROOT}` is a special environment variable available in plugin commands that resolves to the absolute path of the plugin directory.\n\n**Why it matters:**\n- Enables portable paths within plugin\n- Allows referencing plugin files and scripts\n- Works across different installations\n- Essential for multi-file plugin operations\n\n### Basic Usage\n\nReference files within your plugin:\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*), Read\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js`\n\nRead template: @${CLAUDE_PLUGIN_ROOT}/templates/report.md\n```\n\n**Expands to:**\n```\nRun analysis: !`node /path/to/plugins/plugin-name/scripts/analyze.js`\n\nRead template: @/path/to/plugins/plugin-name/templates/report.md\n```\n\n### Common Patterns\n\n#### 1. Executing Plugin Scripts\n\n```markdown\n---\ndescription: Run custom linter from plugin\nallowed-tools: Bash(node:*)\n---\n\nLint results: !`node ${CLAUDE_PLUGIN_ROOT}/bin/lint.js $1`\n\nReview the linting output and suggest fixes.\n```\n\n#### 2. Loading Configuration Files\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nallowed-tools: Read, Bash(*)\n---\n\nConfiguration: @${CLAUDE_PLUGIN_ROOT}/config/deploy-config.json\n\nDeploy application using the configuration above for $1 environment.\n```\n\n#### 3. Accessing Plugin Resources\n\n```markdown\n---\ndescription: Generate report from template\n---\n\nUse this template: @${CLAUDE_PLUGIN_ROOT}/templates/api-report.md\n\nGenerate a report for @$1 following the template format.\n```\n\n#### 4. Multi-Step Plugin Workflows\n\n```markdown\n---\ndescription: Complete plugin workflow\nallowed-tools: Bash(*), Read\n---\n\nStep 1 - Prepare: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/prepare.sh $1`\nStep 2 - Config: @${CLAUDE_PLUGIN_ROOT}/config/$1.json\nStep 3 - Execute: !`${CLAUDE_PLUGIN_ROOT}/bin/execute $1`\n\nReview results and report status.\n```\n\n### Best Practices\n\n1. **Always use for plugin-internal paths:**\n   ```markdown\n   # Good\n   @${CLAUDE_PLUGIN_ROOT}/templates/foo.md\n\n   # Bad\n   @./templates/foo.md  # Relative to current directory, not plugin\n   ```\n\n2. **Validate file existence:**\n   ```markdown\n   ---\n   description: Use plugin config if exists\n   allowed-tools: Bash(test:*), Read\n   ---\n\n   !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"exists\" || echo \"missing\"`\n\n   If config exists, load it: @${CLAUDE_PLUGIN_ROOT}/config.json\n   Otherwise, use defaults...\n   ```\n\n3. **Document plugin file structure:**\n   ```markdown\n   <!--\n   Plugin structure:\n   ${CLAUDE_PLUGIN_ROOT}/\n   â”œâ”€â”€ scripts/analyze.js  (analysis script)\n   â”œâ”€â”€ templates/          (report templates)\n   â””â”€â”€ config/             (configuration files)\n   -->\n   ```\n\n4. **Combine with arguments:**\n   ```markdown\n   Run: !`${CLAUDE_PLUGIN_ROOT}/bin/process.sh $1 $2`\n   ```\n\n### Troubleshooting\n\n**Variable not expanding:**\n- Ensure command is loaded from plugin\n- Check bash execution is allowed\n- Verify syntax is exact: `${CLAUDE_PLUGIN_ROOT}`\n\n**File not found errors:**\n- Verify file exists in plugin directory\n- Check file path is correct relative to plugin root\n- Ensure file permissions allow reading/execution\n\n**Path with spaces:**\n- Bash commands automatically handle spaces\n- File references work with spaces in paths\n- No special quoting needed\n\n## Plugin Command Patterns\n\n### Pattern 1: Configuration-Based Commands\n\nCommands that load plugin-specific configuration:\n\n```markdown\n---\ndescription: Deploy using plugin settings\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/deploy-config.json\n\nDeploy to $1 environment using:\n1. Configuration settings above\n2. Current git branch: !`git branch --show-current`\n3. Application version: !`cat package.json | grep version`\n\nExecute deployment and monitor progress.\n```\n\n**When to use:** Commands that need consistent settings across invocations\n\n### Pattern 2: Template-Based Generation\n\nCommands that use plugin templates:\n\n```markdown\n---\ndescription: Generate documentation from template\nargument-hint: [component-name]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/component-docs.md\n\nGenerate documentation for $1 component following the template structure.\nInclude:\n- Component purpose and usage\n- API reference\n- Examples\n- Testing guidelines\n```\n\n**When to use:** Standardized output generation\n\n### Pattern 3: Multi-Script Workflow\n\nCommands that orchestrate multiple plugin scripts:\n\n```markdown\n---\ndescription: Complete build and test workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nValidate: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\n\nReview all outputs and report:\n1. Build status\n2. Validation results\n3. Test results\n4. Recommended next steps\n```\n\n**When to use:** Complex plugin workflows with multiple steps\n\n### Pattern 4: Environment-Aware Commands\n\nCommands that adapt to environment:\n\n```markdown\n---\ndescription: Deploy based on environment\nargument-hint: [dev|staging|prod]\n---\n\nEnvironment config: @${CLAUDE_PLUGIN_ROOT}/config/$1.json\n\nEnvironment check: !`echo \"Deploying to: $1\"`\n\nDeploy application using $1 environment configuration.\nVerify deployment and run smoke tests.\n```\n\n**When to use:** Commands that behave differently per environment\n\n### Pattern 5: Plugin Data Management\n\nCommands that manage plugin-specific data:\n\n```markdown\n---\ndescription: Save analysis results to plugin cache\nallowed-tools: Bash(*), Read, Write\n---\n\nCache directory: ${CLAUDE_PLUGIN_ROOT}/cache/\n\nAnalyze @$1 and save results to cache:\n!`mkdir -p ${CLAUDE_PLUGIN_ROOT}/cache && date > ${CLAUDE_PLUGIN_ROOT}/cache/last-run.txt`\n\nStore analysis for future reference and comparison.\n```\n\n**When to use:** Commands that need persistent data storage\n\n## Integration with Plugin Components\n\n### Invoking Plugin Agents\n\nCommands can trigger plugin agents using the Task tool:\n\n```markdown\n---\ndescription: Deep analysis using plugin agent\nargument-hint: [file-path]\n---\n\nInitiate deep code analysis of @$1 using the code-analyzer agent.\n\nThe agent will:\n1. Analyze code structure\n2. Identify patterns\n3. Suggest improvements\n4. Generate detailed report\n\nNote: This uses the Task tool to launch the plugin's code-analyzer agent.\n```\n\n**Key points:**\n- Agent must be defined in plugin's `agents/` directory\n- Claude will automatically use Task tool to launch agent\n- Agent has access to same plugin resources\n\n### Invoking Plugin Skills\n\nCommands can reference plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: API documentation with best practices\nargument-hint: [api-file]\n---\n\nDocument the API in @$1 following our API documentation standards.\n\nUse the api-docs-standards skill to ensure documentation includes:\n- Endpoint descriptions\n- Parameter specifications\n- Response formats\n- Error codes\n- Usage examples\n\nNote: This leverages the plugin's api-docs-standards skill for consistency.\n```\n\n**Key points:**\n- Skill must be defined in plugin's `skills/` directory\n- Mention skill by name to hint Claude should invoke it\n- Skills provide specialized domain knowledge\n\n### Coordinating with Plugin Hooks\n\nCommands can be designed to work with plugin hooks:\n\n```markdown\n---\ndescription: Commit with pre-commit validation\nallowed-tools: Bash(git:*)\n---\n\nStage changes: !\\`git add $1\\`\n\nCommit changes: !\\`git commit -m \"$2\"\\`\n\nNote: This commit will trigger the plugin's pre-commit hook for validation.\nReview hook output for any issues.\n```\n\n**Key points:**\n- Hooks execute automatically on events\n- Commands can prepare state for hooks\n- Document hook interaction in command\n\n### Multi-Component Plugin Commands\n\nCommands that coordinate multiple plugin components:\n\n```markdown\n---\ndescription: Comprehensive code review workflow\nargument-hint: [file-path]\n---\n\nFile to review: @$1\n\nExecute comprehensive review:\n\n1. **Static Analysis** (via plugin scripts)\n   !`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\n2. **Deep Review** (via plugin agent)\n   Launch the code-reviewer agent for detailed analysis.\n\n3. **Best Practices** (via plugin skill)\n   Use the code-standards skill to ensure compliance.\n\n4. **Documentation** (via plugin template)\n   Template: @${CLAUDE_PLUGIN_ROOT}/templates/review-report.md\n\nGenerate final report combining all outputs.\n```\n\n**When to use:** Complex workflows leveraging multiple plugin capabilities\n\n## Validation Patterns\n\n### Input Validation\n\nCommands should validate inputs before processing:\n\n```markdown\n---\ndescription: Deploy to environment with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\n$IF($1 in [dev, staging, prod],\n  Deploy to $1 environment using validated configuration,\n  ERROR: Invalid environment '$1'. Must be one of: dev, staging, prod\n)\n```\n\n**Validation approaches:**\n1. Bash validation using grep/test\n2. Inline validation in prompt\n3. Script-based validation\n\n### File Existence Checks\n\nVerify required files exist:\n\n```markdown\n---\ndescription: Process configuration file\nargument-hint: [config-file]\n---\n\nCheck file: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nProcess configuration if file exists: @$1\n\nIf file doesn't exist, explain:\n- Expected location\n- Required format\n- How to create it\n```\n\n### Required Arguments\n\nValidate required arguments provided:\n\n```markdown\n---\ndescription: Create deployment with version\nargument-hint: [environment] [version]\n---\n\nValidate inputs: !`test -n \"$1\" -a -n \"$2\" && echo \"OK\" || echo \"MISSING\"`\n\n$IF($1 AND $2,\n  Deploy version $2 to $1 environment,\n  ERROR: Both environment and version required. Usage: /deploy [env] [version]\n)\n```\n\n### Plugin Resource Validation\n\nVerify plugin resources available:\n\n```markdown\n---\ndescription: Run analysis with plugin tools\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Config exists: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n- Scripts exist: !`test -d ${CLAUDE_PLUGIN_ROOT}/scripts && echo \"âœ“\" || echo \"âœ—\"`\n- Tools available: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, proceed with analysis.\nOtherwise, report missing components and installation steps.\n```\n\n### Output Validation\n\nValidate command execution results:\n\n```markdown\n---\ndescription: Build and validate output\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\n\nValidate output:\n- Exit code: !`echo $?`\n- Output exists: !`test -d dist && echo \"âœ“\" || echo \"âœ—\"`\n- File count: !`find dist -type f | wc -l`\n\nReport build status and any validation failures.\n```\n\n### Graceful Error Handling\n\nHandle errors gracefully with helpful messages:\n\n```markdown\n---\ndescription: Process file with error handling\nargument-hint: [file-path]\n---\n\nTry processing: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/process.js $1 2>&1 || echo \"ERROR: $?\"`\n\nIf processing succeeded:\n- Report results\n- Suggest next steps\n\nIf processing failed:\n- Explain likely causes\n- Provide troubleshooting steps\n- Suggest alternative approaches\n```\n\n## Best Practices Summary\n\n### Plugin Commands Should:\n\n1. **Use ${CLAUDE_PLUGIN_ROOT} for all plugin-internal paths**\n   - Scripts, templates, configuration, resources\n\n2. **Validate inputs early**\n   - Check required arguments\n   - Verify file existence\n   - Validate argument formats\n\n3. **Document plugin structure**\n   - Explain required files\n   - Document script purposes\n   - Clarify dependencies\n\n4. **Integrate with plugin components**\n   - Reference agents for complex tasks\n   - Use skills for specialized knowledge\n   - Coordinate with hooks when relevant\n\n5. **Provide helpful error messages**\n   - Explain what went wrong\n   - Suggest how to fix\n   - Offer alternatives\n\n6. **Handle edge cases**\n   - Missing files\n   - Invalid arguments\n   - Failed script execution\n   - Missing dependencies\n\n7. **Keep commands focused**\n   - One clear purpose per command\n   - Delegate complex logic to scripts\n   - Use agents for multi-step workflows\n\n8. **Test across installations**\n   - Verify paths work everywhere\n   - Test with different arguments\n   - Validate error cases\n\n---\n\nFor general command development, see main SKILL.md.\nFor command examples, see examples/ directory.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/command-development/references/documentation-patterns.md","content":"# Command Documentation Patterns\n\nStrategies for creating self-documenting, maintainable commands with excellent user experience.\n\n## Overview\n\nWell-documented commands are easier to use, maintain, and distribute. Documentation should be embedded in the command itself, making it immediately accessible to users and maintainers.\n\n## Self-Documenting Command Structure\n\n### Complete Command Template\n\n```markdown\n---\ndescription: Clear, actionable description under 60 chars\nargument-hint: [arg1] [arg2] [optional-arg]\nallowed-tools: Read, Bash(git:*)\nmodel: sonnet\n---\n\n<!--\nCOMMAND: command-name\nVERSION: 1.0.0\nAUTHOR: Team Name\nLAST UPDATED: 2025-01-15\n\nPURPOSE:\nDetailed explanation of what this command does and why it exists.\n\nUSAGE:\n  /command-name arg1 arg2\n\nARGUMENTS:\n  arg1: Description of first argument (required)\n  arg2: Description of second argument (optional, defaults to X)\n\nEXAMPLES:\n  /command-name feature-branch main\n    â†’ Compares feature-branch with main\n\n  /command-name my-branch\n    â†’ Compares my-branch with current branch\n\nREQUIREMENTS:\n  - Git repository\n  - Branch must exist\n  - Permissions to read repository\n\nRELATED COMMANDS:\n  /other-command - Related functionality\n  /another-command - Alternative approach\n\nTROUBLESHOOTING:\n  - If branch not found: Check branch name spelling\n  - If permission denied: Check repository access\n\nCHANGELOG:\n  v1.0.0 (2025-01-15): Initial release\n  v0.9.0 (2025-01-10): Beta version\n-->\n\n# Command Implementation\n\n[Command prompt content here...]\n\n[Explain what will happen...]\n\n[Guide user through steps...]\n\n[Provide clear output...]\n```\n\n### Documentation Comment Sections\n\n**PURPOSE**: Why the command exists\n- Problem it solves\n- Use cases\n- When to use vs when not to use\n\n**USAGE**: Basic syntax\n- Command invocation pattern\n- Required vs optional arguments\n- Default values\n\n**ARGUMENTS**: Detailed argument documentation\n- Each argument described\n- Type information\n- Valid values/ranges\n- Defaults\n\n**EXAMPLES**: Concrete usage examples\n- Common use cases\n- Edge cases\n- Expected outputs\n\n**REQUIREMENTS**: Prerequisites\n- Dependencies\n- Permissions\n- Environmental setup\n\n**RELATED COMMANDS**: Connections\n- Similar commands\n- Complementary commands\n- Alternative approaches\n\n**TROUBLESHOOTING**: Common issues\n- Known problems\n- Solutions\n- Workarounds\n\n**CHANGELOG**: Version history\n- What changed when\n- Breaking changes highlighted\n- Migration guidance\n\n## In-Line Documentation Patterns\n\n### Commented Sections\n\n```markdown\n---\ndescription: Complex multi-step command\n---\n\n<!-- SECTION 1: VALIDATION -->\n<!-- This section checks prerequisites before proceeding -->\n\nChecking prerequisites...\n- Git repository: !`git rev-parse --git-dir 2>/dev/null`\n- Branch exists: [validation logic]\n\n<!-- SECTION 2: ANALYSIS -->\n<!-- Analyzes the differences between branches -->\n\nAnalyzing differences between $1 and $2...\n[Analysis logic...]\n\n<!-- SECTION 3: RECOMMENDATIONS -->\n<!-- Provides actionable recommendations -->\n\nBased on analysis, recommend:\n[Recommendations...]\n\n<!-- END: Next steps for user -->\n```\n\n### Inline Explanations\n\n```markdown\n---\ndescription: Deployment command with inline docs\n---\n\n# Deploy to $1\n\n## Pre-flight Checks\n\n<!-- We check branch status to prevent deploying from wrong branch -->\nCurrent branch: !`git branch --show-current`\n\n<!-- Production deploys must come from main/master -->\nif [ \"$1\" = \"production\" ] && [ \"$(git branch --show-current)\" != \"main\" ]; then\n  âš ï¸  WARNING: Not on main branch for production deploy\n  This is unusual. Confirm this is intentional.\nfi\n\n<!-- Test status ensures we don't deploy broken code -->\nRunning tests: !`npm test`\n\nâœ“ All checks passed\n\n## Deployment\n\n<!-- Actual deployment happens here -->\n<!-- Uses blue-green strategy for zero-downtime -->\nDeploying to $1 environment...\n[Deployment steps...]\n\n<!-- Post-deployment verification -->\nVerifying deployment health...\n[Health checks...]\n\nDeployment complete!\n\n## Next Steps\n\n<!-- Guide user on what to do after deployment -->\n1. Monitor logs: /logs $1\n2. Run smoke tests: /smoke-test $1\n3. Notify team: /notify-deployment $1\n```\n\n### Decision Point Documentation\n\n```markdown\n---\ndescription: Interactive deployment command\n---\n\n# Interactive Deployment\n\n## Configuration Review\n\nTarget: $1\nCurrent version: !`cat version.txt`\nNew version: $2\n\n<!-- DECISION POINT: User confirms configuration -->\n<!-- This pause allows user to verify everything is correct -->\n<!-- We can't automatically proceed because deployment is risky -->\n\nReview the above configuration.\n\n**Continue with deployment?**\n- Reply \"yes\" to proceed\n- Reply \"no\" to cancel\n- Reply \"edit\" to modify configuration\n\n[Await user input before continuing...]\n\n<!-- After user confirms, we proceed with deployment -->\n<!-- All subsequent steps are automated -->\n\nProceeding with deployment...\n```\n\n## Help Text Patterns\n\n### Built-in Help Command\n\nCreate a help subcommand for complex commands:\n\n```markdown\n---\ndescription: Main command with help\nargument-hint: [subcommand] [args]\n---\n\n# Command Processor\n\nif [ \"$1\" = \"help\" ] || [ \"$1\" = \"--help\" ] || [ \"$1\" = \"-h\" ]; then\n  **Command Help**\n\n  USAGE:\n    /command [subcommand] [args]\n\n  SUBCOMMANDS:\n    init [name]       Initialize new configuration\n    deploy [env]      Deploy to environment\n    status            Show current status\n    rollback          Rollback last deployment\n    help              Show this help\n\n  EXAMPLES:\n    /command init my-project\n    /command deploy staging\n    /command status\n    /command rollback\n\n  For detailed help on a subcommand:\n    /command [subcommand] --help\n\n  Exit.\nfi\n\n[Regular command processing...]\n```\n\n### Contextual Help\n\nProvide help based on context:\n\n```markdown\n---\ndescription: Context-aware command\nargument-hint: [operation] [target]\n---\n\n# Context-Aware Operation\n\nif [ -z \"$1\" ]; then\n  **No operation specified**\n\n  Available operations:\n  - analyze: Analyze target for issues\n  - fix: Apply automatic fixes\n  - report: Generate detailed report\n\n  Usage: /command [operation] [target]\n\n  Examples:\n    /command analyze src/\n    /command fix src/app.js\n    /command report\n\n  Run /command help for more details.\n\n  Exit.\nfi\n\n[Command continues if operation provided...]\n```\n\n## Error Message Documentation\n\n### Helpful Error Messages\n\n```markdown\n---\ndescription: Command with good error messages\n---\n\n# Validation Command\n\nif [ -z \"$1\" ]; then\n  âŒ ERROR: Missing required argument\n\n  The 'file-path' argument is required.\n\n  USAGE:\n    /validate [file-path]\n\n  EXAMPLE:\n    /validate src/app.js\n\n  Try again with a file path.\n\n  Exit.\nfi\n\nif [ ! -f \"$1\" ]; then\n  âŒ ERROR: File not found: $1\n\n  The specified file does not exist or is not accessible.\n\n  COMMON CAUSES:\n  1. Typo in file path\n  2. File was deleted or moved\n  3. Insufficient permissions\n\n  SUGGESTIONS:\n  - Check spelling: $1\n  - Verify file exists: ls -la $(dirname \"$1\")\n  - Check permissions: ls -l \"$1\"\n\n  Exit.\nfi\n\n[Command continues if validation passes...]\n```\n\n### Error Recovery Guidance\n\n```markdown\n---\ndescription: Command with recovery guidance\n---\n\n# Operation Command\n\nRunning operation...\n\n!`risky-operation.sh`\n\nif [ $? -ne 0 ]; then\n  âŒ OPERATION FAILED\n\n  The operation encountered an error and could not complete.\n\n  WHAT HAPPENED:\n  The risky-operation.sh script returned a non-zero exit code.\n\n  WHAT THIS MEANS:\n  - Changes may be partially applied\n  - System may be in inconsistent state\n  - Manual intervention may be needed\n\n  RECOVERY STEPS:\n  1. Check operation logs: cat /tmp/operation.log\n  2. Verify system state: /check-state\n  3. If needed, rollback: /rollback-operation\n  4. Fix underlying issue\n  5. Retry operation: /retry-operation\n\n  NEED HELP?\n  - Check troubleshooting guide: /help troubleshooting\n  - Contact support with error code: ERR_OP_FAILED_001\n\n  Exit.\nfi\n```\n\n## Usage Example Documentation\n\n### Embedded Examples\n\n```markdown\n---\ndescription: Command with embedded examples\n---\n\n# Feature Command\n\nThis command performs feature analysis with multiple options.\n\n## Basic Usage\n\n\\`\\`\\`\n/feature analyze src/\n\\`\\`\\`\n\nAnalyzes all files in src/ directory for feature usage.\n\n## Advanced Usage\n\n\\`\\`\\`\n/feature analyze src/ --detailed\n\\`\\`\\`\n\nProvides detailed analysis including:\n- Feature breakdown by file\n- Usage patterns\n- Optimization suggestions\n\n## Use Cases\n\n**Use Case 1: Quick overview**\n\\`\\`\\`\n/feature analyze .\n\\`\\`\\`\nGet high-level feature summary of entire project.\n\n**Use Case 2: Specific directory**\n\\`\\`\\`\n/feature analyze src/components\n\\`\\`\\`\nFocus analysis on components directory only.\n\n**Use Case 3: Comparison**\n\\`\\`\\`\n/feature analyze src/ --compare baseline.json\n\\`\\`\\`\nCompare current features against baseline.\n\n---\n\nNow processing your request...\n\n[Command implementation...]\n```\n\n### Example-Driven Documentation\n\n```markdown\n---\ndescription: Example-heavy command\n---\n\n# Transformation Command\n\n## What This Does\n\nTransforms data from one format to another.\n\n## Examples First\n\n### Example 1: JSON to YAML\n**Input:** `data.json`\n\\`\\`\\`json\n{\"name\": \"test\", \"value\": 42}\n\\`\\`\\`\n\n**Command:** `/transform data.json yaml`\n\n**Output:** `data.yaml`\n\\`\\`\\`yaml\nname: test\nvalue: 42\n\\`\\`\\`\n\n### Example 2: CSV to JSON\n**Input:** `data.csv`\n\\`\\`\\`csv\nname,value\ntest,42\n\\`\\`\\`\n\n**Command:** `/transform data.csv json`\n\n**Output:** `data.json`\n\\`\\`\\`json\n[{\"name\": \"test\", \"value\": \"42\"}]\n\\`\\`\\`\n\n### Example 3: With Options\n**Command:** `/transform data.json yaml --pretty --sort-keys`\n\n**Result:** Formatted YAML with sorted keys\n\n---\n\n## Your Transformation\n\nFile: $1\nFormat: $2\n\n[Perform transformation...]\n```\n\n## Maintenance Documentation\n\n### Version and Changelog\n\n```markdown\n<!--\nVERSION: 2.1.0\nLAST UPDATED: 2025-01-15\nAUTHOR: DevOps Team\n\nCHANGELOG:\n  v2.1.0 (2025-01-15):\n    - Added support for YAML configuration\n    - Improved error messages\n    - Fixed bug with special characters in arguments\n\n  v2.0.0 (2025-01-01):\n    - BREAKING: Changed argument order\n    - BREAKING: Removed deprecated --old-flag\n    - Added new validation checks\n    - Migration guide: /migration-v2\n\n  v1.5.0 (2024-12-15):\n    - Added --verbose flag\n    - Improved performance by 50%\n\n  v1.0.0 (2024-12-01):\n    - Initial stable release\n\nMIGRATION NOTES:\n  From v1.x to v2.0:\n    Old: /command arg1 arg2 --old-flag\n    New: /command arg2 arg1\n\n  The --old-flag is removed. Use --new-flag instead.\n\nDEPRECATION WARNINGS:\n  - The --legacy-mode flag is deprecated as of v2.1.0\n  - Will be removed in v3.0.0 (estimated 2025-06-01)\n  - Use --modern-mode instead\n\nKNOWN ISSUES:\n  - #123: Slow performance with large files (workaround: use --stream flag)\n  - #456: Special characters in Windows (fix planned for v2.2.0)\n-->\n```\n\n### Maintenance Notes\n\n```markdown\n<!--\nMAINTENANCE NOTES:\n\nCODE STRUCTURE:\n  - Lines 1-50: Argument parsing and validation\n  - Lines 51-100: Main processing logic\n  - Lines 101-150: Output formatting\n  - Lines 151-200: Error handling\n\nDEPENDENCIES:\n  - Requires git 2.x or later\n  - Uses jq for JSON processing\n  - Needs bash 4.0+ for associative arrays\n\nPERFORMANCE:\n  - Fast path for small inputs (< 1MB)\n  - Streams large files to avoid memory issues\n  - Caches results in /tmp for 1 hour\n\nSECURITY CONSIDERATIONS:\n  - Validates all inputs to prevent injection\n  - Uses allowed-tools to limit Bash access\n  - No credentials in command file\n\nTESTING:\n  - Unit tests: tests/command-test.sh\n  - Integration tests: tests/integration/\n  - Manual test checklist: tests/manual-checklist.md\n\nFUTURE IMPROVEMENTS:\n  - TODO: Add support for TOML format\n  - TODO: Implement parallel processing\n  - TODO: Add progress bar for large files\n\nRELATED FILES:\n  - lib/parser.sh: Shared parsing logic\n  - lib/formatter.sh: Output formatting\n  - config/defaults.yml: Default configuration\n-->\n```\n\n## README Documentation\n\nCommands should have companion README files:\n\n```markdown\n# Command Name\n\nBrief description of what the command does.\n\n## Installation\n\nThis command is part of the [plugin-name] plugin.\n\nInstall with:\n\\`\\`\\`\n/plugin install plugin-name\n\\`\\`\\`\n\n## Usage\n\nBasic usage:\n\\`\\`\\`\n/command-name [arg1] [arg2]\n\\`\\`\\`\n\n## Arguments\n\n- `arg1`: Description (required)\n- `arg2`: Description (optional, defaults to X)\n\n## Examples\n\n### Example 1: Basic Usage\n\\`\\`\\`\n/command-name value1 value2\n\\`\\`\\`\n\nDescription of what happens.\n\n### Example 2: Advanced Usage\n\\`\\`\\`\n/command-name value1 --option\n\\`\\`\\`\n\nDescription of advanced feature.\n\n## Configuration\n\nOptional configuration file: `.claude/command-name.local.md`\n\n\\`\\`\\`markdown\n---\ndefault_arg: value\nenable_feature: true\n---\n\\`\\`\\`\n\n## Requirements\n\n- Git 2.x or later\n- jq (for JSON processing)\n- Node.js 14+ (optional, for advanced features)\n\n## Troubleshooting\n\n### Issue: Command not found\n\n**Solution:** Ensure plugin is installed and enabled.\n\n### Issue: Permission denied\n\n**Solution:** Check file permissions and allowed-tools setting.\n\n## Contributing\n\nContributions welcome! See [CONTRIBUTING.md](CONTRIBUTING.md).\n\n## License\n\nMIT License - See [LICENSE](LICENSE).\n\n## Support\n\n- Issues: https://github.com/user/plugin/issues\n- Docs: https://docs.example.com\n- Email: support@example.com\n```\n\n## Best Practices\n\n### Documentation Principles\n\n1. **Write for your future self**: Assume you'll forget details\n2. **Examples before explanations**: Show, then tell\n3. **Progressive disclosure**: Basic info first, details available\n4. **Keep it current**: Update docs when code changes\n5. **Test your docs**: Verify examples actually work\n\n### Documentation Locations\n\n1. **In command file**: Core usage, examples, inline explanations\n2. **README**: Installation, configuration, troubleshooting\n3. **Separate docs**: Detailed guides, tutorials, API reference\n4. **Comments**: Implementation details for maintainers\n\n### Documentation Style\n\n1. **Clear and concise**: No unnecessary words\n2. **Active voice**: \"Run the command\" not \"The command can be run\"\n3. **Consistent terminology**: Use same terms throughout\n4. **Formatted well**: Use headings, lists, code blocks\n5. **Accessible**: Assume reader is beginner\n\n### Documentation Maintenance\n\n1. **Version everything**: Track what changed when\n2. **Deprecate gracefully**: Warn before removing features\n3. **Migration guides**: Help users upgrade\n4. **Archive old docs**: Keep old versions accessible\n5. **Review regularly**: Ensure docs match reality\n\n## Documentation Checklist\n\nBefore releasing a command:\n\n- [ ] Description in frontmatter is clear\n- [ ] argument-hint documents all arguments\n- [ ] Usage examples in comments\n- [ ] Common use cases shown\n- [ ] Error messages are helpful\n- [ ] Requirements documented\n- [ ] Related commands listed\n- [ ] Changelog maintained\n- [ ] Version number updated\n- [ ] README created/updated\n- [ ] Examples actually work\n- [ ] Troubleshooting section complete\n\nWith good documentation, commands become self-service, reducing support burden and improving user experience.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/command-development/SKILL.md","content":"---\nname: Command Development\ndescription: This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.\nversion: 0.2.0\n---\n\n# Command Development for Claude Code\n\n## Overview\n\nSlash commands are frequently-used prompts defined as Markdown files that Claude executes during interactive sessions. Understanding command structure, frontmatter options, and dynamic features enables creating powerful, reusable workflows.\n\n**Key concepts:**\n- Markdown file format for commands\n- YAML frontmatter for configuration\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n\n## Command Basics\n\n### What is a Slash Command?\n\nA slash command is a Markdown file containing a prompt that Claude executes when invoked. Commands provide:\n- **Reusability**: Define once, use repeatedly\n- **Consistency**: Standardize common workflows\n- **Sharing**: Distribute across team or projects\n- **Efficiency**: Quick access to complex prompts\n\n### Critical: Commands are Instructions FOR Claude\n\n**Commands are written for agent consumption, not human consumption.**\n\nWhen a user invokes `/command-name`, the command content becomes Claude's instructions. Write commands as directives TO Claude about what to do, not as messages TO the user.\n\n**Correct approach (instructions for Claude):**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication issues\n\nProvide specific line numbers and severity ratings.\n```\n\n**Incorrect approach (messages to user):**\n```markdown\nThis command will review your code for security issues.\nYou'll receive a report with vulnerability details.\n```\n\nThe first example tells Claude what to do. The second tells the user what will happen but doesn't instruct Claude. Always use the first approach.\n\n### Command Locations\n\n**Project commands** (shared with team):\n- Location: `.claude/commands/`\n- Scope: Available in specific project\n- Label: Shown as \"(project)\" in `/help`\n- Use for: Team workflows, project-specific tasks\n\n**Personal commands** (available everywhere):\n- Location: `~/.claude/commands/`\n- Scope: Available in all projects\n- Label: Shown as \"(user)\" in `/help`\n- Use for: Personal workflows, cross-project utilities\n\n**Plugin commands** (bundled with plugins):\n- Location: `plugin-name/commands/`\n- Scope: Available when plugin installed\n- Label: Shown as \"(plugin-name)\" in `/help`\n- Use for: Plugin-specific functionality\n\n## File Format\n\n### Basic Structure\n\nCommands are Markdown files with `.md` extension:\n\n```\n.claude/commands/\nâ”œâ”€â”€ review.md           # /review command\nâ”œâ”€â”€ test.md             # /test command\nâ””â”€â”€ deploy.md           # /deploy command\n```\n\n**Simple command:**\n```markdown\nReview this code for security vulnerabilities including:\n- SQL injection\n- XSS attacks\n- Authentication bypass\n- Insecure data handling\n```\n\nNo frontmatter needed for basic commands.\n\n### With YAML Frontmatter\n\nAdd configuration using YAML frontmatter:\n\n```markdown\n---\ndescription: Review code for security issues\nallowed-tools: Read, Grep, Bash(git:*)\nmodel: sonnet\n---\n\nReview this code for security vulnerabilities...\n```\n\n## YAML Frontmatter Fields\n\n### description\n\n**Purpose:** Brief description shown in `/help`\n**Type:** String\n**Default:** First line of command prompt\n\n```yaml\n---\ndescription: Review pull request for code quality\n---\n```\n\n**Best practice:** Clear, actionable description (under 60 characters)\n\n### allowed-tools\n\n**Purpose:** Specify which tools command can use\n**Type:** String or Array\n**Default:** Inherits from conversation\n\n```yaml\n---\nallowed-tools: Read, Write, Edit, Bash(git:*)\n---\n```\n\n**Patterns:**\n- `Read, Write, Edit` - Specific tools\n- `Bash(git:*)` - Bash with git commands only\n- `*` - All tools (rarely needed)\n\n**Use when:** Command requires specific tool access\n\n### model\n\n**Purpose:** Specify model for command execution\n**Type:** String (sonnet, opus, haiku)\n**Default:** Inherits from conversation\n\n```yaml\n---\nmodel: haiku\n---\n```\n\n**Use cases:**\n- `haiku` - Fast, simple commands\n- `sonnet` - Standard workflows\n- `opus` - Complex analysis\n\n### argument-hint\n\n**Purpose:** Document expected arguments for autocomplete\n**Type:** String\n**Default:** None\n\n```yaml\n---\nargument-hint: [pr-number] [priority] [assignee]\n---\n```\n\n**Benefits:**\n- Helps users understand command arguments\n- Improves command discovery\n- Documents command interface\n\n### disable-model-invocation\n\n**Purpose:** Prevent SlashCommand tool from programmatically calling command\n**Type:** Boolean\n**Default:** false\n\n```yaml\n---\ndisable-model-invocation: true\n---\n```\n\n**Use when:** Command should only be manually invoked\n\n## Dynamic Arguments\n\n### Using $ARGUMENTS\n\nCapture all arguments as single string:\n\n```markdown\n---\ndescription: Fix issue by number\nargument-hint: [issue-number]\n---\n\nFix issue #$ARGUMENTS following our coding standards and best practices.\n```\n\n**Usage:**\n```\n> /fix-issue 123\n> /fix-issue 456\n```\n\n**Expands to:**\n```\nFix issue #123 following our coding standards...\nFix issue #456 following our coding standards...\n```\n\n### Using Positional Arguments\n\nCapture individual arguments with `$1`, `$2`, `$3`, etc.:\n\n```markdown\n---\ndescription: Review PR with priority and assignee\nargument-hint: [pr-number] [priority] [assignee]\n---\n\nReview pull request #$1 with priority level $2.\nAfter review, assign to $3 for follow-up.\n```\n\n**Usage:**\n```\n> /review-pr 123 high alice\n```\n\n**Expands to:**\n```\nReview pull request #123 with priority level high.\nAfter review, assign to alice for follow-up.\n```\n\n### Combining Arguments\n\nMix positional and remaining arguments:\n\n```markdown\nDeploy $1 to $2 environment with options: $3\n```\n\n**Usage:**\n```\n> /deploy api staging --force --skip-tests\n```\n\n**Expands to:**\n```\nDeploy api to staging environment with options: --force --skip-tests\n```\n\n## File References\n\n### Using @ Syntax\n\nInclude file contents in command:\n\n```markdown\n---\ndescription: Review specific file\nargument-hint: [file-path]\n---\n\nReview @$1 for:\n- Code quality\n- Best practices\n- Potential bugs\n```\n\n**Usage:**\n```\n> /review-file src/api/users.ts\n```\n\n**Effect:** Claude reads `src/api/users.ts` before processing command\n\n### Multiple File References\n\nReference multiple files:\n\n```markdown\nCompare @src/old-version.js with @src/new-version.js\n\nIdentify:\n- Breaking changes\n- New features\n- Bug fixes\n```\n\n### Static File References\n\nReference known files without arguments:\n\n```markdown\nReview @package.json and @tsconfig.json for consistency\n\nEnsure:\n- TypeScript version matches\n- Dependencies are aligned\n- Build configuration is correct\n```\n\n## Bash Execution in Commands\n\nCommands can execute bash commands inline to dynamically gather context before Claude processes the command. This is useful for including repository state, environment information, or project-specific context.\n\n**When to use:**\n- Include dynamic context (git status, environment vars, etc.)\n- Gather project/repository state\n- Build context-aware workflows\n\n**Implementation details:**\nFor complete syntax, examples, and best practices, see `references/plugin-features-reference.md` section on bash execution. The reference includes the exact syntax and multiple working examples to avoid execution issues\n\n## Command Organization\n\n### Flat Structure\n\nSimple organization for small command sets:\n\n```\n.claude/commands/\nâ”œâ”€â”€ build.md\nâ”œâ”€â”€ test.md\nâ”œâ”€â”€ deploy.md\nâ”œâ”€â”€ review.md\nâ””â”€â”€ docs.md\n```\n\n**Use when:** 5-15 commands, no clear categories\n\n### Namespaced Structure\n\nOrganize commands in subdirectories:\n\n```\n.claude/commands/\nâ”œâ”€â”€ ci/\nâ”‚   â”œâ”€â”€ build.md        # /build (project:ci)\nâ”‚   â”œâ”€â”€ test.md         # /test (project:ci)\nâ”‚   â””â”€â”€ lint.md         # /lint (project:ci)\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commit.md       # /commit (project:git)\nâ”‚   â””â”€â”€ pr.md           # /pr (project:git)\nâ””â”€â”€ docs/\n    â”œâ”€â”€ generate.md     # /generate (project:docs)\n    â””â”€â”€ publish.md      # /publish (project:docs)\n```\n\n**Benefits:**\n- Logical grouping by category\n- Namespace shown in `/help`\n- Easier to find related commands\n\n**Use when:** 15+ commands, clear categories\n\n## Best Practices\n\n### Command Design\n\n1. **Single responsibility:** One command, one task\n2. **Clear descriptions:** Self-explanatory in `/help`\n3. **Explicit dependencies:** Use `allowed-tools` when needed\n4. **Document arguments:** Always provide `argument-hint`\n5. **Consistent naming:** Use verb-noun pattern (review-pr, fix-issue)\n\n### Argument Handling\n\n1. **Validate arguments:** Check for required arguments in prompt\n2. **Provide defaults:** Suggest defaults when arguments missing\n3. **Document format:** Explain expected argument format\n4. **Handle edge cases:** Consider missing or invalid arguments\n\n```markdown\n---\nargument-hint: [pr-number]\n---\n\n$IF($1,\n  Review PR #$1,\n  Please provide a PR number. Usage: /review-pr [number]\n)\n```\n\n### File References\n\n1. **Explicit paths:** Use clear file paths\n2. **Check existence:** Handle missing files gracefully\n3. **Relative paths:** Use project-relative paths\n4. **Glob support:** Consider using Glob tool for patterns\n\n### Bash Commands\n\n1. **Limit scope:** Use `Bash(git:*)` not `Bash(*)`\n2. **Safe commands:** Avoid destructive operations\n3. **Handle errors:** Consider command failures\n4. **Keep fast:** Long-running commands slow invocation\n\n### Documentation\n\n1. **Add comments:** Explain complex logic\n2. **Provide examples:** Show usage in comments\n3. **List requirements:** Document dependencies\n4. **Version commands:** Note breaking changes\n\n```markdown\n---\ndescription: Deploy application to environment\nargument-hint: [environment] [version]\n---\n\n<!--\nUsage: /deploy [staging|production] [version]\nRequires: AWS credentials configured\nExample: /deploy staging v1.2.3\n-->\n\nDeploy application to $1 environment using version $2...\n```\n\n## Common Patterns\n\n### Review Pattern\n\n```markdown\n---\ndescription: Review code changes\nallowed-tools: Read, Bash(git:*)\n---\n\nFiles changed: !`git diff --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Potential bugs or issues\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback for each file.\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific file\nargument-hint: [test-file]\nallowed-tools: Bash(npm:*)\n---\n\nRun tests: !`npm test $1`\n\nAnalyze results and suggest fixes for failures.\n```\n\n### Documentation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nGenerate comprehensive documentation for @$1 including:\n- Function/class descriptions\n- Parameter documentation\n- Return value descriptions\n- Usage examples\n- Edge cases and errors\n```\n\n### Workflow Pattern\n\n```markdown\n---\ndescription: Complete PR workflow\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR #$1 Workflow:\n\n1. Fetch PR: !`gh pr view $1`\n2. Review changes\n3. Run checks\n4. Approve or request changes\n```\n\n## Troubleshooting\n\n**Command not appearing:**\n- Check file is in correct directory\n- Verify `.md` extension present\n- Ensure valid Markdown format\n- Restart Claude Code\n\n**Arguments not working:**\n- Verify `$1`, `$2` syntax correct\n- Check `argument-hint` matches usage\n- Ensure no extra spaces\n\n**Bash execution failing:**\n- Check `allowed-tools` includes Bash\n- Verify command syntax in backticks\n- Test command in terminal first\n- Check for required permissions\n\n**File references not working:**\n- Verify `@` syntax correct\n- Check file path is valid\n- Ensure Read tool allowed\n- Use absolute or project-relative paths\n\n## Plugin-Specific Features\n\n### CLAUDE_PLUGIN_ROOT Variable\n\nPlugin commands have access to `${CLAUDE_PLUGIN_ROOT}`, an environment variable that resolves to the plugin's absolute path.\n\n**Purpose:**\n- Reference plugin files portably\n- Execute plugin scripts\n- Load plugin configuration\n- Access plugin templates\n\n**Basic usage:**\n\n```markdown\n---\ndescription: Analyze using plugin script\nallowed-tools: Bash(node:*)\n---\n\nRun analysis: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js $1`\n\nReview results and report findings.\n```\n\n**Common patterns:**\n\n```markdown\n# Execute plugin script\n!`bash ${CLAUDE_PLUGIN_ROOT}/scripts/script.sh`\n\n# Load plugin configuration\n@${CLAUDE_PLUGIN_ROOT}/config/settings.json\n\n# Use plugin template\n@${CLAUDE_PLUGIN_ROOT}/templates/report.md\n\n# Access plugin resources\n@${CLAUDE_PLUGIN_ROOT}/docs/reference.md\n```\n\n**Why use it:**\n- Works across all installations\n- Portable between systems\n- No hardcoded paths needed\n- Essential for multi-file plugins\n\n### Plugin Command Organization\n\nPlugin commands discovered automatically from `commands/` directory:\n\n```\nplugin-name/\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ foo.md              # /foo (plugin:plugin-name)\nâ”‚   â”œâ”€â”€ bar.md              # /bar (plugin:plugin-name)\nâ”‚   â””â”€â”€ utils/\nâ”‚       â””â”€â”€ helper.md       # /helper (plugin:plugin-name:utils)\nâ””â”€â”€ plugin.json\n```\n\n**Namespace benefits:**\n- Logical command grouping\n- Shown in `/help` output\n- Avoid name conflicts\n- Organize related commands\n\n**Naming conventions:**\n- Use descriptive action names\n- Avoid generic names (test, run)\n- Consider plugin-specific prefix\n- Use hyphens for multi-word names\n\n### Plugin Command Patterns\n\n**Configuration-based pattern:**\n\n```markdown\n---\ndescription: Deploy using plugin configuration\nargument-hint: [environment]\nallowed-tools: Read, Bash(*)\n---\n\nLoad configuration: @${CLAUDE_PLUGIN_ROOT}/config/$1-deploy.json\n\nDeploy to $1 using configuration settings.\nMonitor deployment and report status.\n```\n\n**Template-based pattern:**\n\n```markdown\n---\ndescription: Generate docs from template\nargument-hint: [component]\n---\n\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/docs.md\n\nGenerate documentation for $1 following template structure.\n```\n\n**Multi-script pattern:**\n\n```markdown\n---\ndescription: Complete build workflow\nallowed-tools: Bash(*)\n---\n\nBuild: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh`\nTest: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/test.sh`\nPackage: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/package.sh`\n\nReview outputs and report workflow status.\n```\n\n**See `references/plugin-features-reference.md` for detailed patterns.**\n\n## Integration with Plugin Components\n\nCommands can integrate with other plugin components for powerful workflows.\n\n### Agent Integration\n\nLaunch plugin agents for complex tasks:\n\n```markdown\n---\ndescription: Deep code review\nargument-hint: [file-path]\n---\n\nInitiate comprehensive review of @$1 using the code-reviewer agent.\n\nThe agent will analyze:\n- Code structure\n- Security issues\n- Performance\n- Best practices\n\nAgent uses plugin resources:\n- ${CLAUDE_PLUGIN_ROOT}/config/rules.json\n- ${CLAUDE_PLUGIN_ROOT}/checklists/review.md\n```\n\n**Key points:**\n- Agent must exist in `plugin/agents/` directory\n- Claude uses Task tool to launch agent\n- Document agent capabilities\n- Reference plugin resources agent uses\n\n### Skill Integration\n\nLeverage plugin skills for specialized knowledge:\n\n```markdown\n---\ndescription: Document API with standards\nargument-hint: [api-file]\n---\n\nDocument API in @$1 following plugin standards.\n\nUse the api-docs-standards skill to ensure:\n- Complete endpoint documentation\n- Consistent formatting\n- Example quality\n- Error documentation\n\nGenerate production-ready API docs.\n```\n\n**Key points:**\n- Skill must exist in `plugin/skills/` directory\n- Mention skill name to trigger invocation\n- Document skill purpose\n- Explain what skill provides\n\n### Hook Coordination\n\nDesign commands that work with plugin hooks:\n- Commands can prepare state for hooks to process\n- Hooks execute automatically on tool events\n- Commands should document expected hook behavior\n- Guide Claude on interpreting hook output\n\nSee `references/plugin-features-reference.md` for examples of commands that coordinate with hooks\n\n### Multi-Component Workflows\n\nCombine agents, skills, and scripts:\n\n```markdown\n---\ndescription: Comprehensive review workflow\nargument-hint: [file]\nallowed-tools: Bash(node:*), Read\n---\n\nTarget: @$1\n\nPhase 1 - Static Analysis:\n!`node ${CLAUDE_PLUGIN_ROOT}/scripts/lint.js $1`\n\nPhase 2 - Deep Review:\nLaunch code-reviewer agent for detailed analysis.\n\nPhase 3 - Standards Check:\nUse coding-standards skill for validation.\n\nPhase 4 - Report:\nTemplate: @${CLAUDE_PLUGIN_ROOT}/templates/review.md\n\nCompile findings into report following template.\n```\n\n**When to use:**\n- Complex multi-step workflows\n- Leverage multiple plugin capabilities\n- Require specialized analysis\n- Need structured outputs\n\n## Validation Patterns\n\nCommands should validate inputs and resources before processing.\n\n### Argument Validation\n\n```markdown\n---\ndescription: Deploy with validation\nargument-hint: [environment]\n---\n\nValidate environment: !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\" || echo \"INVALID\"`\n\nIf $1 is valid environment:\n  Deploy to $1\nOtherwise:\n  Explain valid environments: dev, staging, prod\n  Show usage: /deploy [environment]\n```\n\n### File Existence Checks\n\n```markdown\n---\ndescription: Process configuration\nargument-hint: [config-file]\n---\n\nCheck file exists: !`test -f $1 && echo \"EXISTS\" || echo \"MISSING\"`\n\nIf file exists:\n  Process configuration: @$1\nOtherwise:\n  Explain where to place config file\n  Show expected format\n  Provide example configuration\n```\n\n### Plugin Resource Validation\n\n```markdown\n---\ndescription: Run plugin analyzer\nallowed-tools: Bash(test:*)\n---\n\nValidate plugin setup:\n- Script: !`test -x ${CLAUDE_PLUGIN_ROOT}/bin/analyze && echo \"âœ“\" || echo \"âœ—\"`\n- Config: !`test -f ${CLAUDE_PLUGIN_ROOT}/config.json && echo \"âœ“\" || echo \"âœ—\"`\n\nIf all checks pass, run analysis.\nOtherwise, report missing components.\n```\n\n### Error Handling\n\n```markdown\n---\ndescription: Build with error handling\nallowed-tools: Bash(*)\n---\n\nExecute build: !`bash ${CLAUDE_PLUGIN_ROOT}/scripts/build.sh 2>&1 || echo \"BUILD_FAILED\"`\n\nIf build succeeded:\n  Report success and output location\nIf build failed:\n  Analyze error output\n  Suggest likely causes\n  Provide troubleshooting steps\n```\n\n**Best practices:**\n- Validate early in command\n- Provide helpful error messages\n- Suggest corrective actions\n- Handle edge cases gracefully\n\n---\n\nFor detailed frontmatter field specifications, see `references/frontmatter-reference.md`.\nFor plugin-specific features and patterns, see `references/plugin-features-reference.md`.\nFor command pattern examples, see `examples/` directory.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/mcp-integration/references/authentication.md","content":"# MCP Authentication Patterns\n\nComplete guide to authentication methods for MCP servers in Claude Code plugins.\n\n## Overview\n\nMCP servers support multiple authentication methods depending on the server type and service requirements. Choose the method that best matches your use case and security requirements.\n\n## OAuth (Automatic)\n\n### How It Works\n\nClaude Code automatically handles the complete OAuth 2.0 flow for SSE and HTTP servers:\n\n1. User attempts to use MCP tool\n2. Claude Code detects authentication needed\n3. Opens browser for OAuth consent\n4. User authorizes in browser\n5. Tokens stored securely by Claude Code\n6. Automatic token refresh\n\n### Configuration\n\n```json\n{\n  \"service\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.example.com/sse\"\n  }\n}\n```\n\nNo additional auth configuration needed! Claude Code handles everything.\n\n### Supported Services\n\n**Known OAuth-enabled MCP servers:**\n- Asana: `https://mcp.asana.com/sse`\n- GitHub (when available)\n- Google services (when available)\n- Custom OAuth servers\n\n### OAuth Scopes\n\nOAuth scopes are determined by the MCP server. Users see required scopes during the consent flow.\n\n**Document required scopes in your README:**\n```markdown\n## Authentication\n\nThis plugin requires the following Asana permissions:\n- Read tasks and projects\n- Create and update tasks\n- Access workspace data\n```\n\n### Token Storage\n\nTokens are stored securely by Claude Code:\n- Not accessible to plugins\n- Encrypted at rest\n- Automatic refresh\n- Cleared on sign-out\n\n### Troubleshooting OAuth\n\n**Authentication loop:**\n- Clear cached tokens (sign out and sign in)\n- Check OAuth redirect URLs\n- Verify server OAuth configuration\n\n**Scope issues:**\n- User may need to re-authorize for new scopes\n- Check server documentation for required scopes\n\n**Token expiration:**\n- Claude Code auto-refreshes\n- If refresh fails, prompts re-authentication\n\n## Token-Based Authentication\n\n### Bearer Tokens\n\nMost common for HTTP and WebSocket servers.\n\n**Configuration:**\n```json\n{\n  \"api\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\"\n    }\n  }\n}\n```\n\n**Environment variable:**\n```bash\nexport API_TOKEN=\"your-secret-token-here\"\n```\n\n### API Keys\n\nAlternative to Bearer tokens, often in custom headers.\n\n**Configuration:**\n```json\n{\n  \"api\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"X-API-Key\": \"${API_KEY}\",\n      \"X-API-Secret\": \"${API_SECRET}\"\n    }\n  }\n}\n```\n\n### Custom Headers\n\nServices may use custom authentication headers.\n\n**Configuration:**\n```json\n{\n  \"service\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.example.com/sse\",\n    \"headers\": {\n      \"X-Auth-Token\": \"${AUTH_TOKEN}\",\n      \"X-User-ID\": \"${USER_ID}\",\n      \"X-Tenant-ID\": \"${TENANT_ID}\"\n    }\n  }\n}\n```\n\n### Documenting Token Requirements\n\nAlways document in your README:\n\n```markdown\n## Setup\n\n### Required Environment Variables\n\nSet these environment variables before using the plugin:\n\n\\`\\`\\`bash\nexport API_TOKEN=\"your-token-here\"\nexport API_SECRET=\"your-secret-here\"\n\\`\\`\\`\n\n### Obtaining Tokens\n\n1. Visit https://api.example.com/tokens\n2. Create a new API token\n3. Copy the token and secret\n4. Set environment variables as shown above\n\n### Token Permissions\n\nThe API token needs the following permissions:\n- Read access to resources\n- Write access for creating items\n- Delete access (optional, for cleanup operations)\n\\`\\`\\`\n```\n\n## Environment Variable Authentication (stdio)\n\n### Passing Credentials to Server\n\nFor stdio servers, pass credentials via environment variables:\n\n```json\n{\n  \"database\": {\n    \"command\": \"python\",\n    \"args\": [\"-m\", \"mcp_server_db\"],\n    \"env\": {\n      \"DATABASE_URL\": \"${DATABASE_URL}\",\n      \"DB_USER\": \"${DB_USER}\",\n      \"DB_PASSWORD\": \"${DB_PASSWORD}\"\n    }\n  }\n}\n```\n\n### User Environment Variables\n\n```bash\n# User sets these in their shell\nexport DATABASE_URL=\"postgresql://localhost/mydb\"\nexport DB_USER=\"myuser\"\nexport DB_PASSWORD=\"mypassword\"\n```\n\n### Documentation Template\n\n```markdown\n## Database Configuration\n\nSet these environment variables:\n\n\\`\\`\\`bash\nexport DATABASE_URL=\"postgresql://host:port/database\"\nexport DB_USER=\"username\"\nexport DB_PASSWORD=\"password\"\n\\`\\`\\`\n\nOr create a `.env` file (add to `.gitignore`):\n\n\\`\\`\\`\nDATABASE_URL=postgresql://localhost:5432/mydb\nDB_USER=myuser\nDB_PASSWORD=mypassword\n\\`\\`\\`\n\nLoad with: \\`source .env\\` or \\`export $(cat .env | xargs)\\`\n\\`\\`\\`\n```\n\n## Dynamic Headers\n\n### Headers Helper Script\n\nFor tokens that change or expire, use a helper script:\n\n```json\n{\n  \"api\": {\n    \"type\": \"sse\",\n    \"url\": \"https://api.example.com\",\n    \"headersHelper\": \"${CLAUDE_PLUGIN_ROOT}/scripts/get-headers.sh\"\n  }\n}\n```\n\n**Script (get-headers.sh):**\n```bash\n#!/bin/bash\n# Generate dynamic authentication headers\n\n# Fetch fresh token\nTOKEN=$(get-fresh-token-from-somewhere)\n\n# Output JSON headers\ncat <<EOF\n{\n  \"Authorization\": \"Bearer $TOKEN\",\n  \"X-Timestamp\": \"$(date -Iseconds)\"\n}\nEOF\n```\n\n### Use Cases for Dynamic Headers\n\n- Short-lived tokens that need refresh\n- Tokens with HMAC signatures\n- Time-based authentication\n- Dynamic tenant/workspace selection\n\n## Security Best Practices\n\n### DO\n\nâœ… **Use environment variables:**\n```json\n{\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nâœ… **Document required variables in README**\n\nâœ… **Use HTTPS/WSS always**\n\nâœ… **Implement token rotation**\n\nâœ… **Store tokens securely (env vars, not files)**\n\nâœ… **Let OAuth handle authentication when available**\n\n### DON'T\n\nâŒ **Hardcode tokens:**\n```json\n{\n  \"headers\": {\n    \"Authorization\": \"Bearer sk-abc123...\"  // NEVER!\n  }\n}\n```\n\nâŒ **Commit tokens to git**\n\nâŒ **Share tokens in documentation**\n\nâŒ **Use HTTP instead of HTTPS**\n\nâŒ **Store tokens in plugin files**\n\nâŒ **Log tokens or sensitive headers**\n\n## Multi-Tenancy Patterns\n\n### Workspace/Tenant Selection\n\n**Via environment variable:**\n```json\n{\n  \"api\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Workspace-ID\": \"${WORKSPACE_ID}\"\n    }\n  }\n}\n```\n\n**Via URL:**\n```json\n{\n  \"api\": {\n    \"type\": \"http\",\n    \"url\": \"https://${TENANT_ID}.api.example.com/mcp\"\n  }\n}\n```\n\n### Per-User Configuration\n\nUsers set their own workspace:\n\n```bash\nexport WORKSPACE_ID=\"my-workspace-123\"\nexport TENANT_ID=\"my-company\"\n```\n\n## Authentication Troubleshooting\n\n### Common Issues\n\n**401 Unauthorized:**\n- Check token is set correctly\n- Verify token hasn't expired\n- Check token has required permissions\n- Ensure header format is correct\n\n**403 Forbidden:**\n- Token valid but lacks permissions\n- Check scope/permissions\n- Verify workspace/tenant ID\n- May need admin approval\n\n**Token not found:**\n```bash\n# Check environment variable is set\necho $API_TOKEN\n\n# If empty, set it\nexport API_TOKEN=\"your-token\"\n```\n\n**Token in wrong format:**\n```json\n// Correct\n\"Authorization\": \"Bearer sk-abc123\"\n\n// Wrong\n\"Authorization\": \"sk-abc123\"\n```\n\n### Debugging Authentication\n\n**Enable debug mode:**\n```bash\nclaude --debug\n```\n\nLook for:\n- Authentication header values (sanitized)\n- OAuth flow progress\n- Token refresh attempts\n- Authentication errors\n\n**Test authentication separately:**\n```bash\n# Test HTTP endpoint\ncurl -H \"Authorization: Bearer $API_TOKEN\" \\\n     https://api.example.com/mcp/health\n\n# Should return 200 OK\n```\n\n## Migration Patterns\n\n### From Hardcoded to Environment Variables\n\n**Before:**\n```json\n{\n  \"headers\": {\n    \"Authorization\": \"Bearer sk-hardcoded-token\"\n  }\n}\n```\n\n**After:**\n```json\n{\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\n**Migration steps:**\n1. Add environment variable to plugin README\n2. Update configuration to use ${VAR}\n3. Test with variable set\n4. Remove hardcoded value\n5. Commit changes\n\n### From Basic Auth to OAuth\n\n**Before:**\n```json\n{\n  \"headers\": {\n    \"Authorization\": \"Basic ${BASE64_CREDENTIALS}\"\n  }\n}\n```\n\n**After:**\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\n**Benefits:**\n- Better security\n- No credential management\n- Automatic token refresh\n- Scoped permissions\n\n## Advanced Authentication\n\n### Mutual TLS (mTLS)\n\nSome enterprise services require client certificates.\n\n**Not directly supported in MCP configuration.**\n\n**Workaround:** Wrap in stdio server that handles mTLS:\n\n```json\n{\n  \"secure-api\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/mtls-wrapper\",\n    \"args\": [\"--cert\", \"${CLIENT_CERT}\", \"--key\", \"${CLIENT_KEY}\"],\n    \"env\": {\n      \"API_URL\": \"https://secure.example.com\"\n    }\n  }\n}\n```\n\n### JWT Tokens\n\nGenerate JWT tokens dynamically with headers helper:\n\n```bash\n#!/bin/bash\n# generate-jwt.sh\n\n# Generate JWT (using library or API call)\nJWT=$(generate-jwt-token)\n\necho \"{\\\"Authorization\\\": \\\"Bearer $JWT\\\"}\"\n```\n\n```json\n{\n  \"headersHelper\": \"${CLAUDE_PLUGIN_ROOT}/scripts/generate-jwt.sh\"\n}\n```\n\n### HMAC Signatures\n\nFor APIs requiring request signing:\n\n```bash\n#!/bin/bash\n# generate-hmac.sh\n\nTIMESTAMP=$(date -Iseconds)\nSIGNATURE=$(echo -n \"$TIMESTAMP\" | openssl dgst -sha256 -hmac \"$SECRET_KEY\" | cut -d' ' -f2)\n\ncat <<EOF\n{\n  \"X-Timestamp\": \"$TIMESTAMP\",\n  \"X-Signature\": \"$SIGNATURE\",\n  \"X-API-Key\": \"$API_KEY\"\n}\nEOF\n```\n\n## Best Practices Summary\n\n### For Plugin Developers\n\n1. **Prefer OAuth** when service supports it\n2. **Use environment variables** for tokens\n3. **Document all required variables** in README\n4. **Provide setup instructions** with examples\n5. **Never commit credentials**\n6. **Use HTTPS/WSS only**\n7. **Test authentication thoroughly**\n\n### For Plugin Users\n\n1. **Set environment variables** before using plugin\n2. **Keep tokens secure** and private\n3. **Rotate tokens regularly**\n4. **Use different tokens** for dev/prod\n5. **Don't commit .env files** to git\n6. **Review OAuth scopes** before authorizing\n\n## Conclusion\n\nChoose the authentication method that matches your MCP server's requirements:\n- **OAuth** for cloud services (easiest for users)\n- **Bearer tokens** for API services\n- **Environment variables** for stdio servers\n- **Dynamic headers** for complex auth flows\n\nAlways prioritize security and provide clear setup documentation for users.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/mcp-integration/references/tool-usage.md","content":"# Using MCP Tools in Commands and Agents\n\nComplete guide to using MCP tools effectively in Claude Code plugin commands and agents.\n\n## Overview\n\nOnce an MCP server is configured, its tools become available with the prefix `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`. Use these tools in commands and agents just like built-in Claude Code tools.\n\n## Tool Naming Convention\n\n### Format\n\n```\nmcp__plugin_<plugin-name>_<server-name>__<tool-name>\n```\n\n### Examples\n\n**Asana plugin with asana server:**\n- `mcp__plugin_asana_asana__asana_create_task`\n- `mcp__plugin_asana_asana__asana_search_tasks`\n- `mcp__plugin_asana_asana__asana_get_project`\n\n**Custom plugin with database server:**\n- `mcp__plugin_myplug_database__query`\n- `mcp__plugin_myplug_database__execute`\n- `mcp__plugin_myplug_database__list_tables`\n\n### Discovering Tool Names\n\n**Use `/mcp` command:**\n```bash\n/mcp\n```\n\nThis shows:\n- All available MCP servers\n- Tools provided by each server\n- Tool schemas and descriptions\n- Full tool names for use in configuration\n\n## Using Tools in Commands\n\n### Pre-Allowing Tools\n\nSpecify MCP tools in command frontmatter:\n\n```markdown\n---\ndescription: Create a new Asana task\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\"\n]\n---\n\n# Create Task Command\n\nTo create a task:\n1. Gather task details from user\n2. Use mcp__plugin_asana_asana__asana_create_task with the details\n3. Confirm creation to user\n```\n\n### Multiple Tools\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\",\n  \"mcp__plugin_asana_asana__asana_get_project\"\n]\n---\n```\n\n### Wildcard (Use Sparingly)\n\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Caution:** Only use wildcards if the command truly needs access to all tools from a server.\n\n### Tool Usage in Command Instructions\n\n**Example command:**\n```markdown\n---\ndescription: Search and create Asana tasks\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_search_tasks\",\n  \"mcp__plugin_asana_asana__asana_create_task\"\n]\n---\n\n# Asana Task Management\n\n## Searching Tasks\n\nTo search for tasks:\n1. Use mcp__plugin_asana_asana__asana_search_tasks\n2. Provide search filters (assignee, project, etc.)\n3. Display results to user\n\n## Creating Tasks\n\nTo create a task:\n1. Gather task details:\n   - Title (required)\n   - Description\n   - Project\n   - Assignee\n   - Due date\n2. Use mcp__plugin_asana_asana__asana_create_task\n3. Show confirmation with task link\n```\n\n## Using Tools in Agents\n\n### Agent Configuration\n\nAgents can use MCP tools autonomously without pre-allowing them:\n\n```markdown\n---\nname: asana-status-updater\ndescription: This agent should be used when the user asks to \"update Asana status\", \"generate project report\", or \"sync Asana tasks\"\nmodel: inherit\ncolor: blue\n---\n\n## Role\n\nAutonomous agent for generating Asana project status reports.\n\n## Process\n\n1. **Query tasks**: Use mcp__plugin_asana_asana__asana_search_tasks to get all tasks\n2. **Analyze progress**: Calculate completion rates and identify blockers\n3. **Generate report**: Create formatted status update\n4. **Update Asana**: Use mcp__plugin_asana_asana__asana_create_comment to post report\n\n## Available Tools\n\nThe agent has access to all Asana MCP tools without pre-approval.\n```\n\n### Agent Tool Access\n\nAgents have broader tool access than commands:\n- Can use any tool Claude determines is necessary\n- Don't need pre-allowed lists\n- Should document which tools they typically use\n\n## Tool Call Patterns\n\n### Pattern 1: Simple Tool Call\n\nSingle tool call with validation:\n\n```markdown\nSteps:\n1. Validate user provided required fields\n2. Call mcp__plugin_api_server__create_item with validated data\n3. Check for errors\n4. Display confirmation\n```\n\n### Pattern 2: Sequential Tools\n\nChain multiple tool calls:\n\n```markdown\nSteps:\n1. Search for existing items: mcp__plugin_api_server__search\n2. If not found, create new: mcp__plugin_api_server__create\n3. Add metadata: mcp__plugin_api_server__update_metadata\n4. Return final item ID\n```\n\n### Pattern 3: Batch Operations\n\nMultiple calls with same tool:\n\n```markdown\nSteps:\n1. Get list of items to process\n2. For each item:\n   - Call mcp__plugin_api_server__update_item\n   - Track success/failure\n3. Report results summary\n```\n\n### Pattern 4: Error Handling\n\nGraceful error handling:\n\n```markdown\nSteps:\n1. Try to call mcp__plugin_api_server__get_data\n2. If error (rate limit, network, etc.):\n   - Wait and retry (max 3 attempts)\n   - If still failing, inform user\n   - Suggest checking configuration\n3. On success, process data\n```\n\n## Tool Parameters\n\n### Understanding Tool Schemas\n\nEach MCP tool has a schema defining its parameters. View with `/mcp`.\n\n**Example schema:**\n```json\n{\n  \"name\": \"asana_create_task\",\n  \"description\": \"Create a new Asana task\",\n  \"inputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"name\": {\n        \"type\": \"string\",\n        \"description\": \"Task title\"\n      },\n      \"notes\": {\n        \"type\": \"string\",\n        \"description\": \"Task description\"\n      },\n      \"workspace\": {\n        \"type\": \"string\",\n        \"description\": \"Workspace GID\"\n      }\n    },\n    \"required\": [\"name\", \"workspace\"]\n  }\n}\n```\n\n### Calling Tools with Parameters\n\nClaude automatically structures tool calls based on schema:\n\n```typescript\n// Claude generates this internally\n{\n  toolName: \"mcp__plugin_asana_asana__asana_create_task\",\n  input: {\n    name: \"Review PR #123\",\n    notes: \"Code review for new feature\",\n    workspace: \"12345\",\n    assignee: \"67890\",\n    due_on: \"2025-01-15\"\n  }\n}\n```\n\n### Parameter Validation\n\n**In commands, validate before calling:**\n\n```markdown\nSteps:\n1. Check required parameters:\n   - Title is not empty\n   - Workspace ID is provided\n   - Due date is valid format (YYYY-MM-DD)\n2. If validation fails, ask user to provide missing data\n3. If validation passes, call MCP tool\n4. Handle tool errors gracefully\n```\n\n## Response Handling\n\n### Success Responses\n\n```markdown\nSteps:\n1. Call MCP tool\n2. On success:\n   - Extract relevant data from response\n   - Format for user display\n   - Provide confirmation message\n   - Include relevant links or IDs\n```\n\n### Error Responses\n\n```markdown\nSteps:\n1. Call MCP tool\n2. On error:\n   - Check error type (auth, rate limit, validation, etc.)\n   - Provide helpful error message\n   - Suggest remediation steps\n   - Don't expose internal error details to user\n```\n\n### Partial Success\n\n```markdown\nSteps:\n1. Batch operation with multiple MCP calls\n2. Track successes and failures separately\n3. Report summary:\n   - \"Successfully processed 8 of 10 items\"\n   - \"Failed items: [item1, item2] due to [reason]\"\n   - Suggest retry or manual intervention\n```\n\n## Performance Optimization\n\n### Batching Requests\n\n**Good: Single query with filters**\n```markdown\nSteps:\n1. Call mcp__plugin_api_server__search with filters:\n   - project_id: \"123\"\n   - status: \"active\"\n   - limit: 100\n2. Process all results\n```\n\n**Avoid: Many individual queries**\n```markdown\nSteps:\n1. For each item ID:\n   - Call mcp__plugin_api_server__get_item\n   - Process item\n```\n\n### Caching Results\n\n```markdown\nSteps:\n1. Call expensive MCP operation: mcp__plugin_api_server__analyze\n2. Store results in variable for reuse\n3. Use cached results for subsequent operations\n4. Only re-fetch if data changes\n```\n\n### Parallel Tool Calls\n\nWhen tools don't depend on each other, call in parallel:\n\n```markdown\nSteps:\n1. Make parallel calls (Claude handles this automatically):\n   - mcp__plugin_api_server__get_project\n   - mcp__plugin_api_server__get_users\n   - mcp__plugin_api_server__get_tags\n2. Wait for all to complete\n3. Combine results\n```\n\n## Integration Best Practices\n\n### User Experience\n\n**Provide feedback:**\n```markdown\nSteps:\n1. Inform user: \"Searching Asana tasks...\"\n2. Call mcp__plugin_asana_asana__asana_search_tasks\n3. Show progress: \"Found 15 tasks, analyzing...\"\n4. Present results\n```\n\n**Handle long operations:**\n```markdown\nSteps:\n1. Warn user: \"This may take a minute...\"\n2. Break into smaller steps with updates\n3. Show incremental progress\n4. Final summary when complete\n```\n\n### Error Messages\n\n**Good error messages:**\n```\nâŒ \"Could not create task. Please check:\n   1. You're logged into Asana\n   2. You have access to workspace 'Engineering'\n   3. The project 'Q1 Goals' exists\"\n```\n\n**Poor error messages:**\n```\nâŒ \"Error: MCP tool returned 403\"\n```\n\n### Documentation\n\n**Document MCP tool usage in command:**\n```markdown\n## MCP Tools Used\n\nThis command uses the following Asana MCP tools:\n- **asana_search_tasks**: Search for tasks matching criteria\n- **asana_create_task**: Create new task with details\n- **asana_update_task**: Update existing task properties\n\nEnsure you're authenticated to Asana before running this command.\n```\n\n## Testing Tool Usage\n\n### Local Testing\n\n1. **Configure MCP server** in `.mcp.json`\n2. **Install plugin locally** in `.claude-plugin/`\n3. **Verify tools available** with `/mcp`\n4. **Test command** that uses tools\n5. **Check debug output**: `claude --debug`\n\n### Test Scenarios\n\n**Test successful calls:**\n```markdown\nSteps:\n1. Create test data in external service\n2. Run command that queries this data\n3. Verify correct results returned\n```\n\n**Test error cases:**\n```markdown\nSteps:\n1. Test with missing authentication\n2. Test with invalid parameters\n3. Test with non-existent resources\n4. Verify graceful error handling\n```\n\n**Test edge cases:**\n```markdown\nSteps:\n1. Test with empty results\n2. Test with maximum results\n3. Test with special characters\n4. Test with concurrent access\n```\n\n## Common Patterns\n\n### Pattern: CRUD Operations\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_api_server__create_item\",\n  \"mcp__plugin_api_server__read_item\",\n  \"mcp__plugin_api_server__update_item\",\n  \"mcp__plugin_api_server__delete_item\"\n]\n---\n\n# Item Management\n\n## Create\nUse create_item with required fields...\n\n## Read\nUse read_item with item ID...\n\n## Update\nUse update_item with item ID and changes...\n\n## Delete\nUse delete_item with item ID (ask for confirmation first)...\n```\n\n### Pattern: Search and Process\n\n```markdown\nSteps:\n1. **Search**: mcp__plugin_api_server__search with filters\n2. **Filter**: Apply additional local filtering if needed\n3. **Transform**: Process each result\n4. **Present**: Format and display to user\n```\n\n### Pattern: Multi-Step Workflow\n\n```markdown\nSteps:\n1. **Setup**: Gather all required information\n2. **Validate**: Check data completeness\n3. **Execute**: Chain of MCP tool calls:\n   - Create parent resource\n   - Create child resources\n   - Link resources together\n   - Add metadata\n4. **Verify**: Confirm all steps succeeded\n5. **Report**: Provide summary to user\n```\n\n## Troubleshooting\n\n### Tools Not Available\n\n**Check:**\n- MCP server configured correctly\n- Server connected (check `/mcp`)\n- Tool names match exactly (case-sensitive)\n- Restart Claude Code after config changes\n\n### Tool Calls Failing\n\n**Check:**\n- Authentication is valid\n- Parameters match tool schema\n- Required parameters provided\n- Check `claude --debug` logs\n\n### Performance Issues\n\n**Check:**\n- Batching queries instead of individual calls\n- Caching results when appropriate\n- Not making unnecessary tool calls\n- Parallel calls when possible\n\n## Conclusion\n\nEffective MCP tool usage requires:\n1. **Understanding tool schemas** via `/mcp`\n2. **Pre-allowing tools** in commands appropriately\n3. **Handling errors gracefully**\n4. **Optimizing performance** with batching and caching\n5. **Providing good UX** with feedback and clear errors\n6. **Testing thoroughly** before deployment\n\nFollow these patterns for robust MCP tool integration in your plugin commands and agents.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/mcp-integration/references/server-types.md","content":"# MCP Server Types: Deep Dive\n\nComplete reference for all MCP server types supported in Claude Code plugins.\n\n## stdio (Standard Input/Output)\n\n### Overview\n\nExecute local MCP servers as child processes with communication via stdin/stdout. Best choice for local tools, custom servers, and NPM packages.\n\n### Configuration\n\n**Basic:**\n```json\n{\n  \"my-server\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"my-mcp-server\"]\n  }\n}\n```\n\n**With environment:**\n```json\n{\n  \"my-server\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/custom-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"API_KEY\": \"${MY_API_KEY}\",\n      \"LOG_LEVEL\": \"debug\",\n      \"DATABASE_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n### Process Lifecycle\n\n1. **Startup**: Claude Code spawns process with `command` and `args`\n2. **Communication**: JSON-RPC messages via stdin/stdout\n3. **Lifecycle**: Process runs for entire Claude Code session\n4. **Shutdown**: Process terminated when Claude Code exits\n\n### Use Cases\n\n**NPM Packages:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path\"]\n  }\n}\n```\n\n**Custom Scripts:**\n```json\n{\n  \"custom\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server.js\",\n    \"args\": [\"--verbose\"]\n  }\n}\n```\n\n**Python Servers:**\n```json\n{\n  \"python-server\": {\n    \"command\": \"python\",\n    \"args\": [\"-m\", \"my_mcp_server\"],\n    \"env\": {\n      \"PYTHONUNBUFFERED\": \"1\"\n    }\n  }\n}\n```\n\n### Best Practices\n\n1. **Use absolute paths or ${CLAUDE_PLUGIN_ROOT}**\n2. **Set PYTHONUNBUFFERED for Python servers**\n3. **Pass configuration via args or env, not stdin**\n4. **Handle server crashes gracefully**\n5. **Log to stderr, not stdout (stdout is for MCP protocol)**\n\n### Troubleshooting\n\n**Server won't start:**\n- Check command exists and is executable\n- Verify file paths are correct\n- Check permissions\n- Review `claude --debug` logs\n\n**Communication fails:**\n- Ensure server uses stdin/stdout correctly\n- Check for stray print/console.log statements\n- Verify JSON-RPC format\n\n## SSE (Server-Sent Events)\n\n### Overview\n\nConnect to hosted MCP servers via HTTP with server-sent events for streaming. Best for cloud services and OAuth authentication.\n\n### Configuration\n\n**Basic:**\n```json\n{\n  \"hosted-service\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.example.com/sse\"\n  }\n}\n```\n\n**With headers:**\n```json\n{\n  \"service\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.example.com/sse\",\n    \"headers\": {\n      \"X-API-Version\": \"v1\",\n      \"X-Client-ID\": \"${CLIENT_ID}\"\n    }\n  }\n}\n```\n\n### Connection Lifecycle\n\n1. **Initialization**: HTTP connection established to URL\n2. **Handshake**: MCP protocol negotiation\n3. **Streaming**: Server sends events via SSE\n4. **Requests**: Client sends HTTP POST for tool calls\n5. **Reconnection**: Automatic reconnection on disconnect\n\n### Authentication\n\n**OAuth (Automatic):**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\nClaude Code handles OAuth flow:\n1. User prompted to authenticate on first use\n2. Opens browser for OAuth flow\n3. Tokens stored securely\n4. Automatic token refresh\n\n**Custom Headers:**\n```json\n{\n  \"service\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.example.com/sse\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\"\n    }\n  }\n}\n```\n\n### Use Cases\n\n**Official Services:**\n- Asana: `https://mcp.asana.com/sse`\n- GitHub: `https://mcp.github.com/sse`\n- Other hosted MCP servers\n\n**Custom Hosted Servers:**\nDeploy your own MCP server and expose via HTTPS + SSE.\n\n### Best Practices\n\n1. **Always use HTTPS, never HTTP**\n2. **Let OAuth handle authentication when available**\n3. **Use environment variables for tokens**\n4. **Handle connection failures gracefully**\n5. **Document OAuth scopes required**\n\n### Troubleshooting\n\n**Connection refused:**\n- Check URL is correct and accessible\n- Verify HTTPS certificate is valid\n- Check network connectivity\n- Review firewall settings\n\n**OAuth fails:**\n- Clear cached tokens\n- Check OAuth scopes\n- Verify redirect URLs\n- Re-authenticate\n\n## HTTP (REST API)\n\n### Overview\n\nConnect to RESTful MCP servers via standard HTTP requests. Best for token-based auth and stateless interactions.\n\n### Configuration\n\n**Basic:**\n```json\n{\n  \"api\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\"\n  }\n}\n```\n\n**With authentication:**\n```json\n{\n  \"api\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"Content-Type\": \"application/json\",\n      \"X-API-Version\": \"2024-01-01\"\n    }\n  }\n}\n```\n\n### Request/Response Flow\n\n1. **Tool Discovery**: GET to discover available tools\n2. **Tool Invocation**: POST with tool name and parameters\n3. **Response**: JSON response with results or errors\n4. **Stateless**: Each request independent\n\n### Authentication\n\n**Token-Based:**\n```json\n{\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\n**API Key:**\n```json\n{\n  \"headers\": {\n    \"X-API-Key\": \"${API_KEY}\"\n  }\n}\n```\n\n**Custom Auth:**\n```json\n{\n  \"headers\": {\n    \"X-Auth-Token\": \"${AUTH_TOKEN}\",\n    \"X-User-ID\": \"${USER_ID}\"\n  }\n}\n```\n\n### Use Cases\n\n- REST API backends\n- Internal services\n- Microservices\n- Serverless functions\n\n### Best Practices\n\n1. **Use HTTPS for all connections**\n2. **Store tokens in environment variables**\n3. **Implement retry logic for transient failures**\n4. **Handle rate limiting**\n5. **Set appropriate timeouts**\n\n### Troubleshooting\n\n**HTTP errors:**\n- 401: Check authentication headers\n- 403: Verify permissions\n- 429: Implement rate limiting\n- 500: Check server logs\n\n**Timeout issues:**\n- Increase timeout if needed\n- Check server performance\n- Optimize tool implementations\n\n## WebSocket (Real-time)\n\n### Overview\n\nConnect to MCP servers via WebSocket for real-time bidirectional communication. Best for streaming and low-latency applications.\n\n### Configuration\n\n**Basic:**\n```json\n{\n  \"realtime\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\"\n  }\n}\n```\n\n**With authentication:**\n```json\n{\n  \"realtime\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\",\n      \"X-Client-ID\": \"${CLIENT_ID}\"\n    }\n  }\n}\n```\n\n### Connection Lifecycle\n\n1. **Handshake**: WebSocket upgrade request\n2. **Connection**: Persistent bidirectional channel\n3. **Messages**: JSON-RPC over WebSocket\n4. **Heartbeat**: Keep-alive messages\n5. **Reconnection**: Automatic on disconnect\n\n### Use Cases\n\n- Real-time data streaming\n- Live updates and notifications\n- Collaborative editing\n- Low-latency tool calls\n- Push notifications from server\n\n### Best Practices\n\n1. **Use WSS (secure WebSocket), never WS**\n2. **Implement heartbeat/ping-pong**\n3. **Handle reconnection logic**\n4. **Buffer messages during disconnection**\n5. **Set connection timeouts**\n\n### Troubleshooting\n\n**Connection drops:**\n- Implement reconnection logic\n- Check network stability\n- Verify server supports WebSocket\n- Review firewall settings\n\n**Message delivery:**\n- Implement message acknowledgment\n- Handle out-of-order messages\n- Buffer during disconnection\n\n## Comparison Matrix\n\n| Feature | stdio | SSE | HTTP | WebSocket |\n|---------|-------|-----|------|-----------|\n| **Transport** | Process | HTTP/SSE | HTTP | WebSocket |\n| **Direction** | Bidirectional | Serverâ†’Client | Request/Response | Bidirectional |\n| **State** | Stateful | Stateful | Stateless | Stateful |\n| **Auth** | Env vars | OAuth/Headers | Headers | Headers |\n| **Use Case** | Local tools | Cloud services | REST APIs | Real-time |\n| **Latency** | Lowest | Medium | Medium | Low |\n| **Setup** | Easy | Medium | Easy | Medium |\n| **Reconnect** | Process respawn | Automatic | N/A | Automatic |\n\n## Choosing the Right Type\n\n**Use stdio when:**\n- Running local tools or custom servers\n- Need lowest latency\n- Working with file systems or local databases\n- Distributing server with plugin\n\n**Use SSE when:**\n- Connecting to hosted services\n- Need OAuth authentication\n- Using official MCP servers (Asana, GitHub)\n- Want automatic reconnection\n\n**Use HTTP when:**\n- Integrating with REST APIs\n- Need stateless interactions\n- Using token-based auth\n- Simple request/response pattern\n\n**Use WebSocket when:**\n- Need real-time updates\n- Building collaborative features\n- Low-latency critical\n- Bi-directional streaming required\n\n## Migration Between Types\n\n### From stdio to SSE\n\n**Before (stdio):**\n```json\n{\n  \"local-server\": {\n    \"command\": \"node\",\n    \"args\": [\"server.js\"]\n  }\n}\n```\n\n**After (SSE - deploy server):**\n```json\n{\n  \"hosted-server\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.example.com/sse\"\n  }\n}\n```\n\n### From HTTP to WebSocket\n\n**Before (HTTP):**\n```json\n{\n  \"api\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\"\n  }\n}\n```\n\n**After (WebSocket):**\n```json\n{\n  \"realtime\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://api.example.com/ws\"\n  }\n}\n```\n\nBenefits: Real-time updates, lower latency, bi-directional communication.\n\n## Advanced Configuration\n\n### Multiple Servers\n\nCombine different types:\n\n```json\n{\n  \"local-db\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"mcp-server-sqlite\", \"./data.db\"]\n  },\n  \"cloud-api\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.example.com/sse\"\n  },\n  \"internal-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\"\n    }\n  }\n}\n```\n\n### Conditional Configuration\n\nUse environment variables to switch servers:\n\n```json\n{\n  \"api\": {\n    \"type\": \"http\",\n    \"url\": \"${API_URL}\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\"\n    }\n  }\n}\n```\n\nSet different values for dev/prod:\n- Dev: `API_URL=http://localhost:8080/mcp`\n- Prod: `API_URL=https://api.production.com/mcp`\n\n## Security Considerations\n\n### Stdio Security\n\n- Validate command paths\n- Don't execute user-provided commands\n- Limit environment variable access\n- Restrict file system access\n\n### Network Security\n\n- Always use HTTPS/WSS\n- Validate SSL certificates\n- Don't skip certificate verification\n- Use secure token storage\n\n### Token Management\n\n- Never hardcode tokens\n- Use environment variables\n- Rotate tokens regularly\n- Implement token refresh\n- Document scopes required\n\n## Conclusion\n\nChoose the MCP server type based on your use case:\n- **stdio** for local, custom, or NPM-packaged servers\n- **SSE** for hosted services with OAuth\n- **HTTP** for REST APIs with token auth\n- **WebSocket** for real-time bidirectional communication\n\nTest thoroughly and handle errors gracefully for robust MCP integration.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/mcp-integration/SKILL.md","content":"---\nname: MCP Integration\ndescription: This skill should be used when the user asks to \"add MCP server\", \"integrate MCP\", \"configure MCP in plugin\", \"use .mcp.json\", \"set up Model Context Protocol\", \"connect external service\", mentions \"${CLAUDE_PLUGIN_ROOT} with MCP\", or discusses MCP server types (SSE, stdio, HTTP, WebSocket). Provides comprehensive guidance for integrating Model Context Protocol servers into Claude Code plugins for external tool and service integration.\nversion: 0.1.0\n---\n\n# MCP Integration for Claude Code Plugins\n\n## Overview\n\nModel Context Protocol (MCP) enables Claude Code plugins to integrate with external services and APIs by providing structured tool access. Use MCP integration to expose external service capabilities as tools within Claude Code.\n\n**Key capabilities:**\n- Connect to external services (databases, APIs, file systems)\n- Provide 10+ related tools from a single service\n- Handle OAuth and complex authentication flows\n- Bundle MCP servers with plugins for automatic setup\n\n## MCP Server Configuration Methods\n\nPlugins can bundle MCP servers in two ways:\n\n### Method 1: Dedicated .mcp.json (Recommended)\n\nCreate `.mcp.json` at plugin root:\n\n```json\n{\n  \"database-tools\": {\n    \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/db-server\",\n    \"args\": [\"--config\", \"${CLAUDE_PLUGIN_ROOT}/config.json\"],\n    \"env\": {\n      \"DB_URL\": \"${DB_URL}\"\n    }\n  }\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Easier to maintain\n- Better for multiple servers\n\n### Method 2: Inline in plugin.json\n\nAdd `mcpServers` field to plugin.json:\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"mcpServers\": {\n    \"plugin-api\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/api-server\",\n      \"args\": [\"--port\", \"8080\"]\n    }\n  }\n}\n```\n\n**Benefits:**\n- Single configuration file\n- Good for simple single-server plugins\n\n## MCP Server Types\n\n### stdio (Local Process)\n\nExecute local MCP servers as child processes. Best for local tools and custom servers.\n\n**Configuration:**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/allowed/path\"],\n    \"env\": {\n      \"LOG_LEVEL\": \"debug\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- File system access\n- Local database connections\n- Custom MCP servers\n- NPM-packaged MCP servers\n\n**Process management:**\n- Claude Code spawns and manages the process\n- Communicates via stdin/stdout\n- Terminates when Claude Code exits\n\n### SSE (Server-Sent Events)\n\nConnect to hosted MCP servers with OAuth support. Best for cloud services.\n\n**Configuration:**\n```json\n{\n  \"asana\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.asana.com/sse\"\n  }\n}\n```\n\n**Use cases:**\n- Official hosted MCP servers (Asana, GitHub, etc.)\n- Cloud services with MCP endpoints\n- OAuth-based authentication\n- No local installation needed\n\n**Authentication:**\n- OAuth flows handled automatically\n- User prompted on first use\n- Tokens managed by Claude Code\n\n### HTTP (REST API)\n\nConnect to RESTful MCP servers with token authentication.\n\n**Configuration:**\n```json\n{\n  \"api-service\": {\n    \"type\": \"http\",\n    \"url\": \"https://api.example.com/mcp\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_TOKEN}\",\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- REST API-based MCP servers\n- Token-based authentication\n- Custom API backends\n- Stateless interactions\n\n### WebSocket (Real-time)\n\nConnect to WebSocket MCP servers for real-time bidirectional communication.\n\n**Configuration:**\n```json\n{\n  \"realtime-service\": {\n    \"type\": \"ws\",\n    \"url\": \"wss://mcp.example.com/ws\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${TOKEN}\"\n    }\n  }\n}\n```\n\n**Use cases:**\n- Real-time data streaming\n- Persistent connections\n- Push notifications from server\n- Low-latency requirements\n\n## Environment Variable Expansion\n\nAll MCP configurations support environment variable substitution:\n\n**${CLAUDE_PLUGIN_ROOT}** - Plugin directory (always use for portability):\n```json\n{\n  \"command\": \"${CLAUDE_PLUGIN_ROOT}/servers/my-server\"\n}\n```\n\n**User environment variables** - From user's shell:\n```json\n{\n  \"env\": {\n    \"API_KEY\": \"${MY_API_KEY}\",\n    \"DATABASE_URL\": \"${DB_URL}\"\n  }\n}\n```\n\n**Best practice:** Document all required environment variables in plugin README.\n\n## MCP Tool Naming\n\nWhen MCP servers provide tools, they're automatically prefixed:\n\n**Format:** `mcp__plugin_<plugin-name>_<server-name>__<tool-name>`\n\n**Example:**\n- Plugin: `asana`\n- Server: `asana`\n- Tool: `create_task`\n- **Full name:** `mcp__plugin_asana_asana__asana_create_task`\n\n### Using MCP Tools in Commands\n\nPre-allow specific MCP tools in command frontmatter:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_asana_asana__asana_create_task\",\n  \"mcp__plugin_asana_asana__asana_search_tasks\"\n]\n---\n```\n\n**Wildcard (use sparingly):**\n```markdown\n---\nallowed-tools: [\"mcp__plugin_asana_asana__*\"]\n---\n```\n\n**Best practice:** Pre-allow specific tools, not wildcards, for security.\n\n## Lifecycle Management\n\n**Automatic startup:**\n- MCP servers start when plugin enables\n- Connection established before first tool use\n- Restart required for configuration changes\n\n**Lifecycle:**\n1. Plugin loads\n2. MCP configuration parsed\n3. Server process started (stdio) or connection established (SSE/HTTP/WS)\n4. Tools discovered and registered\n5. Tools available as `mcp__plugin_...__...`\n\n**Viewing servers:**\nUse `/mcp` command to see all servers including plugin-provided ones.\n\n## Authentication Patterns\n\n### OAuth (SSE/HTTP)\n\nOAuth handled automatically by Claude Code:\n\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://mcp.example.com/sse\"\n}\n```\n\nUser authenticates in browser on first use. No additional configuration needed.\n\n### Token-Based (Headers)\n\nStatic or environment variable tokens:\n\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\nDocument required environment variables in README.\n\n### Environment Variables (stdio)\n\nPass configuration to MCP server:\n\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"DATABASE_URL\": \"${DB_URL}\",\n    \"API_KEY\": \"${API_KEY}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n\n## Integration Patterns\n\n### Pattern 1: Simple Tool Wrapper\n\nCommands use MCP tools with user interaction:\n\n```markdown\n# Command: create-item.md\n---\nallowed-tools: [\"mcp__plugin_name_server__create_item\"]\n---\n\nSteps:\n1. Gather item details from user\n2. Use mcp__plugin_name_server__create_item\n3. Confirm creation\n```\n\n**Use for:** Adding validation or preprocessing before MCP calls.\n\n### Pattern 2: Autonomous Agent\n\nAgents use MCP tools autonomously:\n\n```markdown\n# Agent: data-analyzer.md\n\nAnalysis Process:\n1. Query data via mcp__plugin_db_server__query\n2. Process and analyze results\n3. Generate insights report\n```\n\n**Use for:** Multi-step MCP workflows without user interaction.\n\n### Pattern 3: Multi-Server Plugin\n\nIntegrate multiple MCP servers:\n\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\"\n  },\n  \"jira\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.jira.com/sse\"\n  }\n}\n```\n\n**Use for:** Workflows spanning multiple services.\n\n## Security Best Practices\n\n### Use HTTPS/WSS\n\nAlways use secure connections:\n\n```json\nâœ… \"url\": \"https://mcp.example.com/sse\"\nâŒ \"url\": \"http://mcp.example.com/sse\"\n```\n\n### Token Management\n\n**DO:**\n- âœ… Use environment variables for tokens\n- âœ… Document required env vars in README\n- âœ… Let OAuth flow handle authentication\n\n**DON'T:**\n- âŒ Hardcode tokens in configuration\n- âŒ Commit tokens to git\n- âŒ Share tokens in documentation\n\n### Permission Scoping\n\nPre-allow only necessary MCP tools:\n\n```markdown\nâœ… allowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\nâŒ allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n## Error Handling\n\n### Connection Failures\n\nHandle MCP server unavailability:\n- Provide fallback behavior in commands\n- Inform user of connection issues\n- Check server URL and configuration\n\n### Tool Call Errors\n\nHandle failed MCP operations:\n- Validate inputs before calling MCP tools\n- Provide clear error messages\n- Check rate limiting and quotas\n\n### Configuration Errors\n\nValidate MCP configuration:\n- Test server connectivity during development\n- Validate JSON syntax\n- Check required environment variables\n\n## Performance Considerations\n\n### Lazy Loading\n\nMCP servers connect on-demand:\n- Not all servers connect at startup\n- First tool use triggers connection\n- Connection pooling managed automatically\n\n### Batching\n\nBatch similar requests when possible:\n\n```\n# Good: Single query with filters\ntasks = search_tasks(project=\"X\", assignee=\"me\", limit=50)\n\n# Avoid: Many individual queries\nfor id in task_ids:\n    task = get_task(id)\n```\n\n## Testing MCP Integration\n\n### Local Testing\n\n1. Configure MCP server in `.mcp.json`\n2. Install plugin locally (`.claude-plugin/`)\n3. Run `/mcp` to verify server appears\n4. Test tool calls in commands\n5. Check `claude --debug` logs for connection issues\n\n### Validation Checklist\n\n- [ ] MCP configuration is valid JSON\n- [ ] Server URL is correct and accessible\n- [ ] Required environment variables documented\n- [ ] Tools appear in `/mcp` output\n- [ ] Authentication works (OAuth or tokens)\n- [ ] Tool calls succeed from commands\n- [ ] Error cases handled gracefully\n\n## Debugging\n\n### Enable Debug Logging\n\n```bash\nclaude --debug\n```\n\nLook for:\n- MCP server connection attempts\n- Tool discovery logs\n- Authentication flows\n- Tool call errors\n\n### Common Issues\n\n**Server not connecting:**\n- Check URL is correct\n- Verify server is running (stdio)\n- Check network connectivity\n- Review authentication configuration\n\n**Tools not available:**\n- Verify server connected successfully\n- Check tool names match exactly\n- Run `/mcp` to see available tools\n- Restart Claude Code after config changes\n\n**Authentication failing:**\n- Clear cached auth tokens\n- Re-authenticate\n- Check token scopes and permissions\n- Verify environment variables set\n\n## Quick Reference\n\n### MCP Server Types\n\n| Type | Transport | Best For | Auth |\n|------|-----------|----------|------|\n| stdio | Process | Local tools, custom servers | Env vars |\n| SSE | HTTP | Hosted services, cloud APIs | OAuth |\n| HTTP | REST | API backends, token auth | Tokens |\n| ws | WebSocket | Real-time, streaming | Tokens |\n\n### Configuration Checklist\n\n- [ ] Server type specified (stdio/SSE/HTTP/ws)\n- [ ] Type-specific fields complete (command or url)\n- [ ] Authentication configured\n- [ ] Environment variables documented\n- [ ] HTTPS/WSS used (not HTTP/WS)\n- [ ] ${CLAUDE_PLUGIN_ROOT} used for paths\n\n### Best Practices\n\n**DO:**\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portable paths\n- âœ… Document required environment variables\n- âœ… Use secure connections (HTTPS/WSS)\n- âœ… Pre-allow specific MCP tools in commands\n- âœ… Test MCP integration before publishing\n- âœ… Handle connection and tool errors gracefully\n\n**DON'T:**\n- âŒ Hardcode absolute paths\n- âŒ Commit credentials to git\n- âŒ Use HTTP instead of HTTPS\n- âŒ Pre-allow all tools with wildcards\n- âŒ Skip error handling\n- âŒ Forget to document setup\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed information, consult:\n\n- **`references/server-types.md`** - Deep dive on each server type\n- **`references/authentication.md`** - Authentication patterns and OAuth\n- **`references/tool-usage.md`** - Using MCP tools in commands and agents\n\n### Example Configurations\n\nWorking examples in `examples/`:\n\n- **`stdio-server.json`** - Local stdio MCP server\n- **`sse-server.json`** - Hosted SSE server with OAuth\n- **`http-server.json`** - REST API with token auth\n\n### External Resources\n\n- **Official MCP Docs**: https://modelcontextprotocol.io/\n- **Claude Code MCP Docs**: https://docs.claude.com/en/docs/claude-code/mcp\n- **MCP SDK**: @modelcontextprotocol/sdk\n- **Testing**: Use `claude --debug` and `/mcp` command\n\n## Implementation Workflow\n\nTo add MCP integration to a plugin:\n\n1. Choose MCP server type (stdio, SSE, HTTP, ws)\n2. Create `.mcp.json` at plugin root with configuration\n3. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n4. Document required environment variables in README\n5. Test locally with `/mcp` command\n6. Pre-allow MCP tools in relevant commands\n7. Handle authentication (OAuth or tokens)\n8. Test error cases (connection failures, auth errors)\n9. Document MCP integration in plugin README\n\nFocus on stdio for custom/local servers, SSE for hosted services with OAuth.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/hook-development/references/advanced.md","content":"# Advanced Hook Use Cases\n\nThis reference covers advanced hook patterns and techniques for sophisticated automation workflows.\n\n## Multi-Stage Validation\n\nCombine command and prompt hooks for layered validation:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Bash\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/quick-check.sh\",\n          \"timeout\": 5\n        },\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Deep analysis of bash command: $TOOL_INPUT\",\n          \"timeout\": 15\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Use case:** Fast deterministic checks followed by intelligent analysis\n\n**Example quick-check.sh:**\n```bash\n#!/bin/bash\ninput=$(cat)\ncommand=$(echo \"$input\" | jq -r '.tool_input.command')\n\n# Immediate approval for safe commands\nif [[ \"$command\" =~ ^(ls|pwd|echo|date|whoami)$ ]]; then\n  exit 0\nfi\n\n# Let prompt hook handle complex cases\nexit 0\n```\n\nThe command hook quickly approves obviously safe commands, while the prompt hook analyzes everything else.\n\n## Conditional Hook Execution\n\nExecute hooks based on environment or context:\n\n```bash\n#!/bin/bash\n# Only run in CI environment\nif [ -z \"$CI\" ]; then\n  echo '{\"continue\": true}' # Skip in non-CI\n  exit 0\nfi\n\n# Run validation logic in CI\ninput=$(cat)\n# ... validation code ...\n```\n\n**Use cases:**\n- Different behavior in CI vs local development\n- Project-specific validation\n- User-specific rules\n\n**Example: Skip certain checks for trusted users:**\n```bash\n#!/bin/bash\n# Skip detailed checks for admin users\nif [ \"$USER\" = \"admin\" ]; then\n  exit 0\nfi\n\n# Full validation for other users\ninput=$(cat)\n# ... validation code ...\n```\n\n## Hook Chaining via State\n\nShare state between hooks using temporary files:\n\n```bash\n# Hook 1: Analyze and save state\n#!/bin/bash\ninput=$(cat)\ncommand=$(echo \"$input\" | jq -r '.tool_input.command')\n\n# Analyze command\nrisk_level=$(calculate_risk \"$command\")\necho \"$risk_level\" > /tmp/hook-state-$$\n\nexit 0\n```\n\n```bash\n# Hook 2: Use saved state\n#!/bin/bash\nrisk_level=$(cat /tmp/hook-state-$$ 2>/dev/null || echo \"unknown\")\n\nif [ \"$risk_level\" = \"high\" ]; then\n  echo \"High risk operation detected\" >&2\n  exit 2\nfi\n```\n\n**Important:** This only works for sequential hook events (e.g., PreToolUse then PostToolUse), not parallel hooks.\n\n## Dynamic Hook Configuration\n\nModify hook behavior based on project configuration:\n\n```bash\n#!/bin/bash\ncd \"$CLAUDE_PROJECT_DIR\" || exit 1\n\n# Read project-specific config\nif [ -f \".claude-hooks-config.json\" ]; then\n  strict_mode=$(jq -r '.strict_mode' .claude-hooks-config.json)\n\n  if [ \"$strict_mode\" = \"true\" ]; then\n    # Apply strict validation\n    # ...\n  else\n    # Apply lenient validation\n    # ...\n  fi\nfi\n```\n\n**Example .claude-hooks-config.json:**\n```json\n{\n  \"strict_mode\": true,\n  \"allowed_commands\": [\"ls\", \"pwd\", \"grep\"],\n  \"forbidden_paths\": [\"/etc\", \"/sys\"]\n}\n```\n\n## Context-Aware Prompt Hooks\n\nUse transcript and session context for intelligent decisions:\n\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Review the full transcript at $TRANSCRIPT_PATH. Check: 1) Were tests run after code changes? 2) Did the build succeed? 3) Were all user questions answered? 4) Is there any unfinished work? Return 'approve' only if everything is complete.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\nThe LLM can read the transcript file and make context-aware decisions.\n\n## Performance Optimization\n\n### Caching Validation Results\n\n```bash\n#!/bin/bash\ninput=$(cat)\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\ncache_key=$(echo -n \"$file_path\" | md5sum | cut -d' ' -f1)\ncache_file=\"/tmp/hook-cache-$cache_key\"\n\n# Check cache\nif [ -f \"$cache_file\" ]; then\n  cache_age=$(($(date +%s) - $(stat -f%m \"$cache_file\" 2>/dev/null || stat -c%Y \"$cache_file\")))\n  if [ \"$cache_age\" -lt 300 ]; then  # 5 minute cache\n    cat \"$cache_file\"\n    exit 0\n  fi\nfi\n\n# Perform validation\nresult='{\"decision\": \"approve\"}'\n\n# Cache result\necho \"$result\" > \"$cache_file\"\necho \"$result\"\n```\n\n### Parallel Execution Optimization\n\nSince hooks run in parallel, design them to be independent:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash check-size.sh\",      // Independent\n          \"timeout\": 2\n        },\n        {\n          \"type\": \"command\",\n          \"command\": \"bash check-path.sh\",      // Independent\n          \"timeout\": 2\n        },\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check content safety\",     // Independent\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nAll three hooks run simultaneously, reducing total latency.\n\n## Cross-Event Workflows\n\nCoordinate hooks across different events:\n\n**SessionStart - Set up tracking:**\n```bash\n#!/bin/bash\n# Initialize session tracking\necho \"0\" > /tmp/test-count-$$\necho \"0\" > /tmp/build-count-$$\n```\n\n**PostToolUse - Track events:**\n```bash\n#!/bin/bash\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\nif [ \"$tool_name\" = \"Bash\" ]; then\n  command=$(echo \"$input\" | jq -r '.tool_result')\n  if [[ \"$command\" == *\"test\"* ]]; then\n    count=$(cat /tmp/test-count-$$ 2>/dev/null || echo \"0\")\n    echo $((count + 1)) > /tmp/test-count-$$\n  fi\nfi\n```\n\n**Stop - Verify based on tracking:**\n```bash\n#!/bin/bash\ntest_count=$(cat /tmp/test-count-$$ 2>/dev/null || echo \"0\")\n\nif [ \"$test_count\" -eq 0 ]; then\n  echo '{\"decision\": \"block\", \"reason\": \"No tests were run\"}' >&2\n  exit 2\nfi\n```\n\n## Integration with External Systems\n\n### Slack Notifications\n\n```bash\n#!/bin/bash\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\ndecision=\"blocked\"\n\n# Send notification to Slack\ncurl -X POST \"$SLACK_WEBHOOK\" \\\n  -H 'Content-Type: application/json' \\\n  -d \"{\\\"text\\\": \\\"Hook ${decision} ${tool_name} operation\\\"}\" \\\n  2>/dev/null\n\necho '{\"decision\": \"deny\"}' >&2\nexit 2\n```\n\n### Database Logging\n\n```bash\n#!/bin/bash\ninput=$(cat)\n\n# Log to database\npsql \"$DATABASE_URL\" -c \"INSERT INTO hook_logs (event, data) VALUES ('PreToolUse', '$input')\" \\\n  2>/dev/null\n\nexit 0\n```\n\n### Metrics Collection\n\n```bash\n#!/bin/bash\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Send metrics to monitoring system\necho \"hook.pretooluse.${tool_name}:1|c\" | nc -u -w1 statsd.local 8125\n\nexit 0\n```\n\n## Security Patterns\n\n### Rate Limiting\n\n```bash\n#!/bin/bash\ninput=$(cat)\ncommand=$(echo \"$input\" | jq -r '.tool_input.command')\n\n# Track command frequency\nrate_file=\"/tmp/hook-rate-$$\"\ncurrent_minute=$(date +%Y%m%d%H%M)\n\nif [ -f \"$rate_file\" ]; then\n  last_minute=$(head -1 \"$rate_file\")\n  count=$(tail -1 \"$rate_file\")\n\n  if [ \"$current_minute\" = \"$last_minute\" ]; then\n    if [ \"$count\" -gt 10 ]; then\n      echo '{\"decision\": \"deny\", \"reason\": \"Rate limit exceeded\"}' >&2\n      exit 2\n    fi\n    count=$((count + 1))\n  else\n    count=1\n  fi\nelse\n  count=1\nfi\n\necho \"$current_minute\" > \"$rate_file\"\necho \"$count\" >> \"$rate_file\"\n\nexit 0\n```\n\n### Audit Logging\n\n```bash\n#!/bin/bash\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\ntimestamp=$(date -Iseconds)\n\n# Append to audit log\necho \"$timestamp | $USER | $tool_name | $input\" >> ~/.claude/audit.log\n\nexit 0\n```\n\n### Secret Detection\n\n```bash\n#!/bin/bash\ninput=$(cat)\ncontent=$(echo \"$input\" | jq -r '.tool_input.content')\n\n# Check for common secret patterns\nif echo \"$content\" | grep -qE \"(api[_-]?key|password|secret|token).{0,20}['\\\"]?[A-Za-z0-9]{20,}\"; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Potential secret detected in content\"}' >&2\n  exit 2\nfi\n\nexit 0\n```\n\n## Testing Advanced Hooks\n\n### Unit Testing Hook Scripts\n\n```bash\n# test-hook.sh\n#!/bin/bash\n\n# Test 1: Approve safe command\nresult=$(echo '{\"tool_input\": {\"command\": \"ls\"}}' | bash validate-bash.sh)\nif [ $? -eq 0 ]; then\n  echo \"âœ“ Test 1 passed\"\nelse\n  echo \"âœ— Test 1 failed\"\nfi\n\n# Test 2: Block dangerous command\nresult=$(echo '{\"tool_input\": {\"command\": \"rm -rf /\"}}' | bash validate-bash.sh)\nif [ $? -eq 2 ]; then\n  echo \"âœ“ Test 2 passed\"\nelse\n  echo \"âœ— Test 2 failed\"\nfi\n```\n\n### Integration Testing\n\nCreate test scenarios that exercise the full hook workflow:\n\n```bash\n# integration-test.sh\n#!/bin/bash\n\n# Set up test environment\nexport CLAUDE_PROJECT_DIR=\"/tmp/test-project\"\nexport CLAUDE_PLUGIN_ROOT=\"$(pwd)\"\nmkdir -p \"$CLAUDE_PROJECT_DIR\"\n\n# Test SessionStart hook\necho '{}' | bash hooks/session-start.sh\nif [ -f \"/tmp/session-initialized\" ]; then\n  echo \"âœ“ SessionStart hook works\"\nelse\n  echo \"âœ— SessionStart hook failed\"\nfi\n\n# Clean up\nrm -rf \"$CLAUDE_PROJECT_DIR\"\n```\n\n## Best Practices for Advanced Hooks\n\n1. **Keep hooks independent**: Don't rely on execution order\n2. **Use timeouts**: Set appropriate limits for each hook type\n3. **Handle errors gracefully**: Provide clear error messages\n4. **Document complexity**: Explain advanced patterns in README\n5. **Test thoroughly**: Cover edge cases and failure modes\n6. **Monitor performance**: Track hook execution time\n7. **Version configuration**: Use version control for hook configs\n8. **Provide escape hatches**: Allow users to bypass hooks when needed\n\n## Common Pitfalls\n\n### âŒ Assuming Hook Order\n\n```bash\n# BAD: Assumes hooks run in specific order\n# Hook 1 saves state, Hook 2 reads it\n# This can fail because hooks run in parallel!\n```\n\n### âŒ Long-Running Hooks\n\n```bash\n# BAD: Hook takes 2 minutes to run\nsleep 120\n# This will timeout and block the workflow\n```\n\n### âŒ Uncaught Exceptions\n\n```bash\n# BAD: Script crashes on unexpected input\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\ncat \"$file_path\"  # Fails if file doesn't exist\n```\n\n### âœ… Proper Error Handling\n\n```bash\n# GOOD: Handles errors gracefully\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\nif [ ! -f \"$file_path\" ]; then\n  echo '{\"continue\": true, \"systemMessage\": \"File not found, skipping check\"}' >&2\n  exit 0\nfi\n```\n\n## Conclusion\n\nAdvanced hook patterns enable sophisticated automation while maintaining reliability and performance. Use these techniques when basic hooks are insufficient, but always prioritize simplicity and maintainability.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/hook-development/references/migration.md","content":"# Migrating from Basic to Advanced Hooks\n\nThis guide shows how to migrate from basic command hooks to advanced prompt-based hooks for better maintainability and flexibility.\n\n## Why Migrate?\n\nPrompt-based hooks offer several advantages:\n\n- **Natural language reasoning**: LLM understands context and intent\n- **Better edge case handling**: Adapts to unexpected scenarios\n- **No bash scripting required**: Simpler to write and maintain\n- **More flexible validation**: Can handle complex logic without coding\n\n## Migration Example: Bash Command Validation\n\n### Before (Basic Command Hook)\n\n**Configuration:**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Bash\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash validate-bash.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Script (validate-bash.sh):**\n```bash\n#!/bin/bash\ninput=$(cat)\ncommand=$(echo \"$input\" | jq -r '.tool_input.command')\n\n# Hard-coded validation logic\nif [[ \"$command\" == *\"rm -rf\"* ]]; then\n  echo \"Dangerous command detected\" >&2\n  exit 2\nfi\n```\n\n**Problems:**\n- Only checks for exact \"rm -rf\" pattern\n- Doesn't catch variations like `rm -fr` or `rm -r -f`\n- Misses other dangerous commands (`dd`, `mkfs`, etc.)\n- No context awareness\n- Requires bash scripting knowledge\n\n### After (Advanced Prompt Hook)\n\n**Configuration:**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Bash\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Command: $TOOL_INPUT.command. Analyze for: 1) Destructive operations (rm -rf, dd, mkfs, etc) 2) Privilege escalation (sudo) 3) Network operations without user consent. Return 'approve' or 'deny' with explanation.\",\n          \"timeout\": 15\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Benefits:**\n- Catches all variations and patterns\n- Understands intent, not just literal strings\n- No script file needed\n- Easy to extend with new criteria\n- Context-aware decisions\n- Natural language explanation in denial\n\n## Migration Example: File Write Validation\n\n### Before (Basic Command Hook)\n\n**Configuration:**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash validate-write.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Script (validate-write.sh):**\n```bash\n#!/bin/bash\ninput=$(cat)\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Check for path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Check for system paths\nif [[ \"$file_path\" == \"/etc/\"* ]] || [[ \"$file_path\" == \"/sys/\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"System file\"}' >&2\n  exit 2\nfi\n```\n\n**Problems:**\n- Hard-coded path patterns\n- Doesn't understand symlinks\n- Missing edge cases (e.g., `/etc` vs `/etc/`)\n- No consideration of file content\n\n### After (Advanced Prompt Hook)\n\n**Configuration:**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"File path: $TOOL_INPUT.file_path. Content preview: $TOOL_INPUT.content (first 200 chars). Verify: 1) Not system directories (/etc, /sys, /usr) 2) Not credentials (.env, tokens, secrets) 3) No path traversal 4) Content doesn't expose secrets. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Benefits:**\n- Context-aware (considers content too)\n- Handles symlinks and edge cases\n- Natural understanding of \"system directories\"\n- Can detect secrets in content\n- Easy to extend criteria\n\n## When to Keep Command Hooks\n\nCommand hooks still have their place:\n\n### 1. Deterministic Performance Checks\n\n```bash\n#!/bin/bash\n# Check file size quickly\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\nsize=$(stat -f%z \"$file_path\" 2>/dev/null || stat -c%s \"$file_path\" 2>/dev/null)\n\nif [ \"$size\" -gt 10000000 ]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"File too large\"}' >&2\n  exit 2\nfi\n```\n\n**Use command hooks when:** Validation is purely mathematical or deterministic.\n\n### 2. External Tool Integration\n\n```bash\n#!/bin/bash\n# Run security scanner\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\nscan_result=$(security-scanner \"$file_path\")\n\nif [ \"$?\" -ne 0 ]; then\n  echo \"Security scan failed: $scan_result\" >&2\n  exit 2\nfi\n```\n\n**Use command hooks when:** Integrating with external tools that provide yes/no answers.\n\n### 3. Very Fast Checks (< 50ms)\n\n```bash\n#!/bin/bash\n# Quick regex check\ncommand=$(echo \"$input\" | jq -r '.tool_input.command')\n\nif [[ \"$command\" =~ ^(ls|pwd|echo)$ ]]; then\n  exit 0  # Safe commands\nfi\n```\n\n**Use command hooks when:** Performance is critical and logic is simple.\n\n## Hybrid Approach\n\nCombine both for multi-stage validation:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Bash\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/quick-check.sh\",\n          \"timeout\": 5\n        },\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Deep analysis of bash command: $TOOL_INPUT\",\n          \"timeout\": 15\n        }\n      ]\n    }\n  ]\n}\n```\n\nThe command hook does fast deterministic checks, while the prompt hook handles complex reasoning.\n\n## Migration Checklist\n\nWhen migrating hooks:\n\n- [ ] Identify the validation logic in the command hook\n- [ ] Convert hard-coded patterns to natural language criteria\n- [ ] Test with edge cases the old hook missed\n- [ ] Verify LLM understands the intent\n- [ ] Set appropriate timeout (usually 15-30s for prompt hooks)\n- [ ] Document the new hook in README\n- [ ] Remove or archive old script files\n\n## Migration Tips\n\n1. **Start with one hook**: Don't migrate everything at once\n2. **Test thoroughly**: Verify prompt hook catches what command hook caught\n3. **Look for improvements**: Use migration as opportunity to enhance validation\n4. **Keep scripts for reference**: Archive old scripts in case you need to reference the logic\n5. **Document reasoning**: Explain why prompt hook is better in README\n\n## Complete Migration Example\n\n### Original Plugin Structure\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/plugin.json\nâ”œâ”€â”€ hooks/hooks.json\nâ””â”€â”€ scripts/\n    â”œâ”€â”€ validate-bash.sh\n    â”œâ”€â”€ validate-write.sh\n    â””â”€â”€ check-tests.sh\n```\n\n### After Migration\n\n```\nmy-plugin/\nâ”œâ”€â”€ .claude-plugin/plugin.json\nâ”œâ”€â”€ hooks/hooks.json      # Now uses prompt hooks\nâ””â”€â”€ scripts/              # Archive or delete\n    â””â”€â”€ archive/\n        â”œâ”€â”€ validate-bash.sh\n        â”œâ”€â”€ validate-write.sh\n        â””â”€â”€ check-tests.sh\n```\n\n### Updated hooks.json\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Bash\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate bash command safety: destructive ops, privilege escalation, network access\"\n        }\n      ]\n    },\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety: system paths, credentials, path traversal, content secrets\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify tests were run if code was modified\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Result:** Simpler, more maintainable, more powerful.\n\n## Common Migration Patterns\n\n### Pattern: String Contains â†’ Natural Language\n\n**Before:**\n```bash\nif [[ \"$command\" == *\"sudo\"* ]]; then\n  echo \"Privilege escalation\" >&2\n  exit 2\nfi\n```\n\n**After:**\n```\n\"Check for privilege escalation (sudo, su, etc)\"\n```\n\n### Pattern: Regex â†’ Intent\n\n**Before:**\n```bash\nif [[ \"$file\" =~ \\.(env|secret|key|token)$ ]]; then\n  echo \"Credential file\" >&2\n  exit 2\nfi\n```\n\n**After:**\n```\n\"Verify not writing to credential files (.env, secrets, keys, tokens)\"\n```\n\n### Pattern: Multiple Conditions â†’ Criteria List\n\n**Before:**\n```bash\nif [ condition1 ] || [ condition2 ] || [ condition3 ]; then\n  echo \"Invalid\" >&2\n  exit 2\nfi\n```\n\n**After:**\n```\n\"Check: 1) condition1 2) condition2 3) condition3. Deny if any fail.\"\n```\n\n## Conclusion\n\nMigrating to prompt-based hooks makes plugins more maintainable, flexible, and powerful. Reserve command hooks for deterministic checks and external tool integration.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/hook-development/references/patterns.md","content":"# Common Hook Patterns\n\nThis reference provides common, proven patterns for implementing Claude Code hooks. Use these patterns as starting points for typical hook use cases.\n\n## Pattern 1: Security Validation\n\nBlock dangerous file writes using prompt-based hooks:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"File path: $TOOL_INPUT.file_path. Verify: 1) Not in /etc or system directories 2) Not .env or credentials 3) Path doesn't contain '..' traversal. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Use for:** Preventing writes to sensitive files or system directories.\n\n## Pattern 2: Test Enforcement\n\nEnsure tests run before stopping:\n\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Review transcript. If code was modified (Write/Edit tools used), verify tests were executed. If no tests were run, block with reason 'Tests must be run after code changes'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Use for:** Enforcing quality standards and preventing incomplete work.\n\n## Pattern 3: Context Loading\n\nLoad project-specific context at session start:\n\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Example script (load-context.sh):**\n```bash\n#!/bin/bash\ncd \"$CLAUDE_PROJECT_DIR\" || exit 1\n\n# Detect project type\nif [ -f \"package.json\" ]; then\n  echo \"ðŸ“¦ Node.js project detected\"\n  echo \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\nelif [ -f \"Cargo.toml\" ]; then\n  echo \"ðŸ¦€ Rust project detected\"\n  echo \"export PROJECT_TYPE=rust\" >> \"$CLAUDE_ENV_FILE\"\nfi\n```\n\n**Use for:** Automatically detecting and configuring project-specific settings.\n\n## Pattern 4: Notification Logging\n\nLog all notifications for audit or analysis:\n\n```json\n{\n  \"Notification\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/log-notification.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Use for:** Tracking user notifications or integration with external logging systems.\n\n## Pattern 5: MCP Tool Monitoring\n\nMonitor and validate MCP tool usage:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"mcp__.*__delete.*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Deletion operation detected. Verify: Is this deletion intentional? Can it be undone? Are there backups? Return 'approve' only if safe.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Use for:** Protecting against destructive MCP operations.\n\n## Pattern 6: Build Verification\n\nEnsure project builds after code changes:\n\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if code was modified. If Write/Edit tools were used, verify the project was built (npm run build, cargo build, etc). If not built, block and request build.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Use for:** Catching build errors before committing or stopping work.\n\n## Pattern 7: Permission Confirmation\n\nAsk user before dangerous operations:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Bash\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Command: $TOOL_INPUT.command. If command contains 'rm', 'delete', 'drop', or other destructive operations, return 'ask' to confirm with user. Otherwise 'approve'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Use for:** User confirmation on potentially destructive commands.\n\n## Pattern 8: Code Quality Checks\n\nRun linters or formatters on file edits:\n\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/check-quality.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Example script (check-quality.sh):**\n```bash\n#!/bin/bash\ninput=$(cat)\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Run linter if applicable\nif [[ \"$file_path\" == *.js ]] || [[ \"$file_path\" == *.ts ]]; then\n  npx eslint \"$file_path\" 2>&1 || true\nfi\n```\n\n**Use for:** Automatic code quality enforcement.\n\n## Pattern Combinations\n\nCombine multiple patterns for comprehensive protection:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    },\n    {\n      \"matcher\": \"Bash\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate bash command safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify tests run and build succeeded\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\nThis provides multi-layered protection and automation.\n\n## Pattern 9: Temporarily Active Hooks\n\nCreate hooks that only run when explicitly enabled via flag files:\n\n```bash\n#!/bin/bash\n# Hook only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-security-scan\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Quick exit when disabled\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Run security scan\nsecurity-scanner \"$file_path\"\n```\n\n**Activation:**\n```bash\n# Enable the hook\ntouch .enable-security-scan\n\n# Disable the hook\nrm .enable-security-scan\n```\n\n**Use for:**\n- Temporary debugging hooks\n- Feature flags for development\n- Project-specific validation that's opt-in\n- Performance-intensive checks only when needed\n\n**Note:** Must restart Claude Code after creating/removing flag files for hooks to recognize changes.\n\n## Pattern 10: Configuration-Driven Hooks\n\nUse JSON configuration to control hook behavior:\n\n```bash\n#!/bin/bash\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/my-plugin.local.json\"\n\n# Read configuration\nif [ -f \"$CONFIG_FILE\" ]; then\n  strict_mode=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  max_file_size=$(jq -r '.maxFileSize // 1000000' \"$CONFIG_FILE\")\nelse\n  # Defaults\n  strict_mode=false\n  max_file_size=1000000\nfi\n\n# Skip if not in strict mode\nif [ \"$strict_mode\" != \"true\" ]; then\n  exit 0\nfi\n\n# Apply configured limits\ninput=$(cat)\nfile_size=$(echo \"$input\" | jq -r '.tool_input.content | length')\n\nif [ \"$file_size\" -gt \"$max_file_size\" ]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"File exceeds configured size limit\"}' >&2\n  exit 2\nfi\n```\n\n**Configuration file (.claude/my-plugin.local.json):**\n```json\n{\n  \"strictMode\": true,\n  \"maxFileSize\": 500000,\n  \"allowedPaths\": [\"/tmp\", \"/home/user/projects\"]\n}\n```\n\n**Use for:**\n- User-configurable hook behavior\n- Per-project settings\n- Team-specific rules\n- Dynamic validation criteria\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/hook-development/SKILL.md","content":"---\nname: Hook Development\ndescription: This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.\nversion: 0.1.0\n---\n\n# Hook Development for Claude Code Plugins\n\n## Overview\n\nHooks are event-driven automation scripts that execute in response to Claude Code events. Use hooks to validate operations, enforce policies, add context, and integrate external tools into workflows.\n\n**Key capabilities:**\n- Validate tool calls before execution (PreToolUse)\n- React to tool results (PostToolUse)\n- Enforce completion standards (Stop, SubagentStop)\n- Load project context (SessionStart)\n- Automate workflows across the development lifecycle\n\n## Hook Types\n\n### Prompt-Based Hooks (Recommended)\n\nUse LLM-driven decision making for context-aware validation:\n\n```json\n{\n  \"type\": \"prompt\",\n  \"prompt\": \"Evaluate if this tool use is appropriate: $TOOL_INPUT\",\n  \"timeout\": 30\n}\n```\n\n**Supported events:** Stop, SubagentStop, UserPromptSubmit, PreToolUse\n\n**Benefits:**\n- Context-aware decisions based on natural language reasoning\n- Flexible evaluation logic without bash scripting\n- Better edge case handling\n- Easier to maintain and extend\n\n### Command Hooks\n\nExecute bash commands for deterministic checks:\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\",\n  \"timeout\": 60\n}\n```\n\n**Use for:**\n- Fast deterministic validations\n- File system operations\n- External tool integrations\n- Performance-critical checks\n\n## Hook Configuration Formats\n\n### Plugin hooks.json Format\n\n**For plugin hooks** in `hooks/hooks.json`, use wrapper format:\n\n```json\n{\n  \"description\": \"Brief explanation of hooks (optional)\",\n  \"hooks\": {\n    \"PreToolUse\": [...],\n    \"Stop\": [...],\n    \"SessionStart\": [...]\n  }\n}\n```\n\n**Key points:**\n- `description` field is optional\n- `hooks` field is required wrapper containing actual hook events\n- This is the **plugin-specific format**\n\n**Example:**\n```json\n{\n  \"description\": \"Validation hooks for code quality\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/validate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Settings Format (Direct)\n\n**For user settings** in `.claude/settings.json`, use direct format:\n\n```json\n{\n  \"PreToolUse\": [...],\n  \"Stop\": [...],\n  \"SessionStart\": [...]\n}\n```\n\n**Key points:**\n- No wrapper - events directly at top level\n- No description field\n- This is the **settings format**\n\n**Important:** The examples below show the hook event structure that goes inside either format. For plugin hooks.json, wrap these in `{\"hooks\": {...}}`.\n\n## Hook Events\n\n### PreToolUse\n\nExecute before any tool runs. Use to approve, deny, or modify tool calls.\n\n**Example (prompt-based):**\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety. Check: system paths, credentials, path traversal, sensitive content. Return 'approve' or 'deny'.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output for PreToolUse:**\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow|deny|ask\",\n    \"updatedInput\": {\"field\": \"modified_value\"}\n  },\n  \"systemMessage\": \"Explanation for Claude\"\n}\n```\n\n### PostToolUse\n\nExecute after tool completes. Use to react to results, provide feedback, or log.\n\n**Example:**\n```json\n{\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Analyze edit result for potential issues: syntax errors, security vulnerabilities, breaking changes. Provide feedback.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Output behavior:**\n- Exit 0: stdout shown in transcript\n- Exit 2: stderr fed back to Claude\n- systemMessage included in context\n\n### Stop\n\nExecute when main agent considers stopping. Use to validate completeness.\n\n**Example:**\n```json\n{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion: tests run, build succeeded, questions answered. Return 'approve' to stop or 'block' with reason to continue.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Decision output:**\n```json\n{\n  \"decision\": \"approve|block\",\n  \"reason\": \"Explanation\",\n  \"systemMessage\": \"Additional context\"\n}\n```\n\n### SubagentStop\n\nExecute when subagent considers stopping. Use to ensure subagent completed its task.\n\nSimilar to Stop hook, but for subagents.\n\n### UserPromptSubmit\n\nExecute when user submits a prompt. Use to add context, validate, or block prompts.\n\n**Example:**\n```json\n{\n  \"UserPromptSubmit\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Check if prompt requires security guidance. If discussing auth, permissions, or API security, return relevant warnings.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### SessionStart\n\nExecute when Claude Code session begins. Use to load context and set environment.\n\n**Example:**\n```json\n{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Special capability:** Persist environment variables using `$CLAUDE_ENV_FILE`:\n```bash\necho \"export PROJECT_TYPE=nodejs\" >> \"$CLAUDE_ENV_FILE\"\n```\n\nSee `examples/load-context.sh` for complete example.\n\n### SessionEnd\n\nExecute when session ends. Use for cleanup, logging, and state preservation.\n\n### PreCompact\n\nExecute before context compaction. Use to add critical information to preserve.\n\n### Notification\n\nExecute when Claude sends notifications. Use to react to user notifications.\n\n## Hook Output Format\n\n### Standard Output (All Hooks)\n\n```json\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Message for Claude\"\n}\n```\n\n- `continue`: If false, halt processing (default true)\n- `suppressOutput`: Hide output from transcript (default false)\n- `systemMessage`: Message shown to Claude\n\n### Exit Codes\n\n- `0` - Success (stdout shown in transcript)\n- `2` - Blocking error (stderr fed back to Claude)\n- Other - Non-blocking error\n\n## Hook Input Format\n\nAll hooks receive JSON via stdin with common fields:\n\n```json\n{\n  \"session_id\": \"abc123\",\n  \"transcript_path\": \"/path/to/transcript.txt\",\n  \"cwd\": \"/current/working/dir\",\n  \"permission_mode\": \"ask|allow\",\n  \"hook_event_name\": \"PreToolUse\"\n}\n```\n\n**Event-specific fields:**\n\n- **PreToolUse/PostToolUse:** `tool_name`, `tool_input`, `tool_result`\n- **UserPromptSubmit:** `user_prompt`\n- **Stop/SubagentStop:** `reason`\n\nAccess fields in prompts using `$TOOL_INPUT`, `$TOOL_RESULT`, `$USER_PROMPT`, etc.\n\n## Environment Variables\n\nAvailable in all command hooks:\n\n- `$CLAUDE_PROJECT_DIR` - Project root path\n- `$CLAUDE_PLUGIN_ROOT` - Plugin directory (use for portable paths)\n- `$CLAUDE_ENV_FILE` - SessionStart only: persist env vars here\n- `$CLAUDE_CODE_REMOTE` - Set if running in remote context\n\n**Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability:**\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\"\n}\n```\n\n## Plugin Hook Configuration\n\nIn plugins, define hooks in `hooks/hooks.json`:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Validate file write safety\"\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Verify task completion\"\n        }\n      ]\n    }\n  ],\n  \"SessionStart\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/scripts/load-context.sh\",\n          \"timeout\": 10\n        }\n      ]\n    }\n  ]\n}\n```\n\nPlugin hooks merge with user's hooks and run in parallel.\n\n## Matchers\n\n### Tool Name Matching\n\n**Exact match:**\n```json\n\"matcher\": \"Write\"\n```\n\n**Multiple tools:**\n```json\n\"matcher\": \"Read|Write|Edit\"\n```\n\n**Wildcard (all tools):**\n```json\n\"matcher\": \"*\"\n```\n\n**Regex patterns:**\n```json\n\"matcher\": \"mcp__.*__delete.*\"  // All MCP delete tools\n```\n\n**Note:** Matchers are case-sensitive.\n\n### Common Patterns\n\n```json\n// All MCP tools\n\"matcher\": \"mcp__.*\"\n\n// Specific plugin's MCP tools\n\"matcher\": \"mcp__plugin_asana_.*\"\n\n// All file operations\n\"matcher\": \"Read|Write|Edit\"\n\n// Bash commands only\n\"matcher\": \"Bash\"\n```\n\n## Security Best Practices\n\n### Input Validation\n\nAlways validate inputs in command hooks:\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\ninput=$(cat)\ntool_name=$(echo \"$input\" | jq -r '.tool_name')\n\n# Validate tool name format\nif [[ ! \"$tool_name\" =~ ^[a-zA-Z0-9_]+$ ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Invalid tool name\"}' >&2\n  exit 2\nfi\n```\n\n### Path Safety\n\nCheck for path traversal and sensitive files:\n\n```bash\nfile_path=$(echo \"$input\" | jq -r '.tool_input.file_path')\n\n# Deny path traversal\nif [[ \"$file_path\" == *\"..\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Path traversal detected\"}' >&2\n  exit 2\nfi\n\n# Deny sensitive files\nif [[ \"$file_path\" == *\".env\"* ]]; then\n  echo '{\"decision\": \"deny\", \"reason\": \"Sensitive file\"}' >&2\n  exit 2\nfi\n```\n\nSee `examples/validate-write.sh` and `examples/validate-bash.sh` for complete examples.\n\n### Quote All Variables\n\n```bash\n# GOOD: Quoted\necho \"$file_path\"\ncd \"$CLAUDE_PROJECT_DIR\"\n\n# BAD: Unquoted (injection risk)\necho $file_path\ncd $CLAUDE_PROJECT_DIR\n```\n\n### Set Appropriate Timeouts\n\n```json\n{\n  \"type\": \"command\",\n  \"command\": \"bash script.sh\",\n  \"timeout\": 10\n}\n```\n\n**Defaults:** Command hooks (60s), Prompt hooks (30s)\n\n## Performance Considerations\n\n### Parallel Execution\n\nAll matching hooks run **in parallel**:\n\n```json\n{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write\",\n      \"hooks\": [\n        {\"type\": \"command\", \"command\": \"check1.sh\"},  // Parallel\n        {\"type\": \"command\", \"command\": \"check2.sh\"},  // Parallel\n        {\"type\": \"prompt\", \"prompt\": \"Validate...\"}   // Parallel\n      ]\n    }\n  ]\n}\n```\n\n**Design implications:**\n- Hooks don't see each other's output\n- Non-deterministic ordering\n- Design for independence\n\n### Optimization\n\n1. Use command hooks for quick deterministic checks\n2. Use prompt hooks for complex reasoning\n3. Cache validation results in temp files\n4. Minimize I/O in hot paths\n\n## Temporarily Active Hooks\n\nCreate hooks that activate conditionally by checking for a flag file or configuration:\n\n**Pattern: Flag file activation**\n```bash\n#!/bin/bash\n# Only active when flag file exists\nFLAG_FILE=\"$CLAUDE_PROJECT_DIR/.enable-strict-validation\"\n\nif [ ! -f \"$FLAG_FILE\" ]; then\n  # Flag not present, skip validation\n  exit 0\nfi\n\n# Flag present, run validation\ninput=$(cat)\n# ... validation logic ...\n```\n\n**Pattern: Configuration-based activation**\n```bash\n#!/bin/bash\n# Check configuration for activation\nCONFIG_FILE=\"$CLAUDE_PROJECT_DIR/.claude/plugin-config.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  enabled=$(jq -r '.strictMode // false' \"$CONFIG_FILE\")\n  if [ \"$enabled\" != \"true\" ]; then\n    exit 0  # Not enabled, skip\n  fi\nfi\n\n# Enabled, run hook logic\ninput=$(cat)\n# ... hook logic ...\n```\n\n**Use cases:**\n- Enable strict validation only when needed\n- Temporary debugging hooks\n- Project-specific hook behavior\n- Feature flags for hooks\n\n**Best practice:** Document activation mechanism in plugin README so users know how to enable/disable temporary hooks.\n\n## Hook Lifecycle and Limitations\n\n### Hooks Load at Session Start\n\n**Important:** Hooks are loaded when Claude Code session starts. Changes to hook configuration require restarting Claude Code.\n\n**Cannot hot-swap hooks:**\n- Editing `hooks/hooks.json` won't affect current session\n- Adding new hook scripts won't be recognized\n- Changing hook commands/prompts won't update\n- Must restart Claude Code: exit and run `claude` again\n\n**To test hook changes:**\n1. Edit hook configuration or scripts\n2. Exit Claude Code session\n3. Restart: `claude` or `cc`\n4. New hook configuration loads\n5. Test hooks with `claude --debug`\n\n### Hook Validation at Startup\n\nHooks are validated when Claude Code starts:\n- Invalid JSON in hooks.json causes loading failure\n- Missing scripts cause warnings\n- Syntax errors reported in debug mode\n\nUse `/hooks` command to review loaded hooks in current session.\n\n## Debugging Hooks\n\n### Enable Debug Mode\n\n```bash\nclaude --debug\n```\n\nLook for hook registration, execution logs, input/output JSON, and timing information.\n\n### Test Hook Scripts\n\nTest command hooks directly:\n\n```bash\necho '{\"tool_name\": \"Write\", \"tool_input\": {\"file_path\": \"/test\"}}' | \\\n  bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate.sh\n\necho \"Exit code: $?\"\n```\n\n### Validate JSON Output\n\nEnsure hooks output valid JSON:\n\n```bash\noutput=$(./your-hook.sh < test-input.json)\necho \"$output\" | jq .\n```\n\n## Quick Reference\n\n### Hook Events Summary\n\n| Event | When | Use For |\n|-------|------|---------|\n| PreToolUse | Before tool | Validation, modification |\n| PostToolUse | After tool | Feedback, logging |\n| UserPromptSubmit | User input | Context, validation |\n| Stop | Agent stopping | Completeness check |\n| SubagentStop | Subagent done | Task validation |\n| SessionStart | Session begins | Context loading |\n| SessionEnd | Session ends | Cleanup, logging |\n| PreCompact | Before compact | Preserve context |\n| Notification | User notified | Logging, reactions |\n\n### Best Practices\n\n**DO:**\n- âœ… Use prompt-based hooks for complex logic\n- âœ… Use ${CLAUDE_PLUGIN_ROOT} for portability\n- âœ… Validate all inputs in command hooks\n- âœ… Quote all bash variables\n- âœ… Set appropriate timeouts\n- âœ… Return structured JSON output\n- âœ… Test hooks thoroughly\n\n**DON'T:**\n- âŒ Use hardcoded paths\n- âŒ Trust user input without validation\n- âŒ Create long-running hooks\n- âŒ Rely on hook execution order\n- âŒ Modify global state unpredictably\n- âŒ Log sensitive information\n\n## Additional Resources\n\n### Reference Files\n\nFor detailed patterns and advanced techniques, consult:\n\n- **`references/patterns.md`** - Common hook patterns (8+ proven patterns)\n- **`references/migration.md`** - Migrating from basic to advanced hooks\n- **`references/advanced.md`** - Advanced use cases and techniques\n\n### Example Hook Scripts\n\nWorking examples in `examples/`:\n\n- **`validate-write.sh`** - File write validation example\n- **`validate-bash.sh`** - Bash command validation example\n- **`load-context.sh`** - SessionStart context loading example\n\n### Utility Scripts\n\nDevelopment tools in `scripts/`:\n\n- **`validate-hook-schema.sh`** - Validate hooks.json structure and syntax\n- **`test-hook.sh`** - Test hooks with sample input before deployment\n- **`hook-linter.sh`** - Check hook scripts for common issues and best practices\n\n### External Resources\n\n- **Official Docs**: https://docs.claude.com/en/docs/claude-code/hooks\n- **Examples**: See security-guidance plugin in marketplace\n- **Testing**: Use `claude --debug` for detailed logs\n- **Validation**: Use `jq` to validate hook JSON output\n\n## Implementation Workflow\n\nTo implement hooks in a plugin:\n\n1. Identify events to hook into (PreToolUse, Stop, SessionStart, etc.)\n2. Decide between prompt-based (flexible) or command (deterministic) hooks\n3. Write hook configuration in `hooks/hooks.json`\n4. For command hooks, create hook scripts\n5. Use ${CLAUDE_PLUGIN_ROOT} for all file references\n6. Validate configuration with `scripts/validate-hook-schema.sh hooks/hooks.json`\n7. Test hooks with `scripts/test-hook.sh` before deployment\n8. Test in Claude Code with `claude --debug`\n9. Document hooks in plugin README\n\nFocus on prompt-based hooks for most use cases. Reserve command hooks for performance-critical or deterministic checks.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/skills/hook-development/scripts/README.md","content":"# Hook Development Utility Scripts\n\nThese scripts help validate, test, and lint hook implementations before deployment.\n\n## validate-hook-schema.sh\n\nValidates `hooks.json` configuration files for correct structure and common issues.\n\n**Usage:**\n```bash\n./validate-hook-schema.sh path/to/hooks.json\n```\n\n**Checks:**\n- Valid JSON syntax\n- Required fields present\n- Valid hook event names\n- Proper hook types (command/prompt)\n- Timeout values in valid ranges\n- Hardcoded path detection\n- Prompt hook event compatibility\n\n**Example:**\n```bash\ncd my-plugin\n./validate-hook-schema.sh hooks/hooks.json\n```\n\n## test-hook.sh\n\nTests individual hook scripts with sample input before deploying to Claude Code.\n\n**Usage:**\n```bash\n./test-hook.sh [options] <hook-script> <test-input.json>\n```\n\n**Options:**\n- `-v, --verbose` - Show detailed execution information\n- `-t, --timeout N` - Set timeout in seconds (default: 60)\n- `--create-sample <event-type>` - Generate sample test input\n\n**Example:**\n```bash\n# Create sample test input\n./test-hook.sh --create-sample PreToolUse > test-input.json\n\n# Test a hook script\n./test-hook.sh my-hook.sh test-input.json\n\n# Test with verbose output and custom timeout\n./test-hook.sh -v -t 30 my-hook.sh test-input.json\n```\n\n**Features:**\n- Sets up proper environment variables (CLAUDE_PROJECT_DIR, CLAUDE_PLUGIN_ROOT)\n- Measures execution time\n- Validates output JSON\n- Shows exit codes and their meanings\n- Captures environment file output\n\n## hook-linter.sh\n\nChecks hook scripts for common issues and best practices violations.\n\n**Usage:**\n```bash\n./hook-linter.sh <hook-script.sh> [hook-script2.sh ...]\n```\n\n**Checks:**\n- Shebang presence\n- `set -euo pipefail` usage\n- Stdin input reading\n- Proper error handling\n- Variable quoting (injection prevention)\n- Exit code usage\n- Hardcoded paths\n- Long-running code detection\n- Error output to stderr\n- Input validation\n\n**Example:**\n```bash\n# Lint single script\n./hook-linter.sh ../examples/validate-write.sh\n\n# Lint multiple scripts\n./hook-linter.sh ../examples/*.sh\n```\n\n## Typical Workflow\n\n1. **Write your hook script**\n   ```bash\n   vim my-plugin/scripts/my-hook.sh\n   ```\n\n2. **Lint the script**\n   ```bash\n   ./hook-linter.sh my-plugin/scripts/my-hook.sh\n   ```\n\n3. **Create test input**\n   ```bash\n   ./test-hook.sh --create-sample PreToolUse > test-input.json\n   # Edit test-input.json as needed\n   ```\n\n4. **Test the hook**\n   ```bash\n   ./test-hook.sh -v my-plugin/scripts/my-hook.sh test-input.json\n   ```\n\n5. **Add to hooks.json**\n   ```bash\n   # Edit my-plugin/hooks/hooks.json\n   ```\n\n6. **Validate configuration**\n   ```bash\n   ./validate-hook-schema.sh my-plugin/hooks/hooks.json\n   ```\n\n7. **Test in Claude Code**\n   ```bash\n   claude --debug\n   ```\n\n## Tips\n\n- Always test hooks before deploying to avoid breaking user workflows\n- Use verbose mode (`-v`) to debug hook behavior\n- Check the linter output for security and best practice issues\n- Validate hooks.json after any changes\n- Create different test inputs for various scenarios (safe operations, dangerous operations, edge cases)\n\n## Common Issues\n\n### Hook doesn't execute\n\nCheck:\n- Script has shebang (`#!/bin/bash`)\n- Script is executable (`chmod +x`)\n- Path in hooks.json is correct (use `${CLAUDE_PLUGIN_ROOT}`)\n\n### Hook times out\n\n- Reduce timeout in hooks.json\n- Optimize hook script performance\n- Remove long-running operations\n\n### Hook fails silently\n\n- Check exit codes (should be 0 or 2)\n- Ensure errors go to stderr (`>&2`)\n- Validate JSON output structure\n\n### Injection vulnerabilities\n\n- Always quote variables: `\"$variable\"`\n- Use `set -euo pipefail`\n- Validate all input fields\n- Run the linter to catch issues\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/agents/plugin-validator.md","content":"---\nname: plugin-validator\ndescription: Use this agent when the user asks to \"validate my plugin\", \"check plugin structure\", \"verify plugin is correct\", \"validate plugin.json\", \"check plugin files\", or mentions plugin validation. Also trigger proactively after user creates or modifies plugin components. Examples:\n\n<example>\nContext: User finished creating a new plugin\nuser: \"I've created my first plugin with commands and hooks\"\nassistant: \"Great! Let me validate the plugin structure.\"\n<commentary>\nPlugin created, proactively validate to catch issues early.\n</commentary>\nassistant: \"I'll use the plugin-validator agent to check the plugin.\"\n</example>\n\n<example>\nContext: User explicitly requests validation\nuser: \"Validate my plugin before I publish it\"\nassistant: \"I'll use the plugin-validator agent to perform comprehensive validation.\"\n<commentary>\nExplicit validation request triggers the agent.\n</commentary>\n</example>\n\n<example>\nContext: User modified plugin.json\nuser: \"I've updated the plugin manifest\"\nassistant: \"Let me validate the changes.\"\n<commentary>\nManifest modified, validate to ensure correctness.\n</commentary>\nassistant: \"I'll use the plugin-validator agent to check the manifest.\"\n</example>\n\nmodel: inherit\ncolor: yellow\ntools: [\"Read\", \"Grep\", \"Glob\", \"Bash\"]\n---\n\nYou are an expert plugin validator specializing in comprehensive validation of Claude Code plugin structure, configuration, and components.\n\n**Your Core Responsibilities:**\n1. Validate plugin structure and organization\n2. Check plugin.json manifest for correctness\n3. Validate all component files (commands, agents, skills, hooks)\n4. Verify naming conventions and file organization\n5. Check for common issues and anti-patterns\n6. Provide specific, actionable recommendations\n\n**Validation Process:**\n\n1. **Locate Plugin Root**:\n   - Check for `.claude-plugin/plugin.json`\n   - Verify plugin directory structure\n   - Note plugin location (project vs marketplace)\n\n2. **Validate Manifest** (`.claude-plugin/plugin.json`):\n   - Check JSON syntax (use Bash with `jq` or Read + manual parsing)\n   - Verify required field: `name`\n   - Check name format (kebab-case, no spaces)\n   - Validate optional fields if present:\n     - `version`: Semantic versioning format (X.Y.Z)\n     - `description`: Non-empty string\n     - `author`: Valid structure\n     - `mcpServers`: Valid server configurations\n   - Check for unknown fields (warn but don't fail)\n\n3. **Validate Directory Structure**:\n   - Use Glob to find component directories\n   - Check standard locations:\n     - `commands/` for slash commands\n     - `agents/` for agent definitions\n     - `skills/` for skill directories\n     - `hooks/hooks.json` for hooks\n   - Verify auto-discovery works\n\n4. **Validate Commands** (if `commands/` exists):\n   - Use Glob to find `commands/**/*.md`\n   - For each command file:\n     - Check YAML frontmatter present (starts with `---`)\n     - Verify `description` field exists\n     - Check `argument-hint` format if present\n     - Validate `allowed-tools` is array if present\n     - Ensure markdown content exists\n   - Check for naming conflicts\n\n5. **Validate Agents** (if `agents/` exists):\n   - Use Glob to find `agents/**/*.md`\n   - For each agent file:\n     - Use the validate-agent.sh utility from agent-development skill\n     - Or manually check:\n       - Frontmatter with `name`, `description`, `model`, `color`\n       - Name format (lowercase, hyphens, 3-50 chars)\n       - Description includes `<example>` blocks\n       - Model is valid (inherit/sonnet/opus/haiku)\n       - Color is valid (blue/cyan/green/yellow/magenta/red)\n       - System prompt exists and is substantial (>20 chars)\n\n6. **Validate Skills** (if `skills/` exists):\n   - Use Glob to find `skills/*/SKILL.md`\n   - For each skill directory:\n     - Verify `SKILL.md` file exists\n     - Check YAML frontmatter with `name` and `description`\n     - Verify description is concise and clear\n     - Check for references/, examples/, scripts/ subdirectories\n     - Validate referenced files exist\n\n7. **Validate Hooks** (if `hooks/hooks.json` exists):\n   - Use the validate-hook-schema.sh utility from hook-development skill\n   - Or manually check:\n     - Valid JSON syntax\n     - Valid event names (PreToolUse, PostToolUse, Stop, etc.)\n     - Each hook has `matcher` and `hooks` array\n     - Hook type is `command` or `prompt`\n     - Commands reference existing scripts with ${CLAUDE_PLUGIN_ROOT}\n\n8. **Validate MCP Configuration** (if `.mcp.json` or `mcpServers` in manifest):\n   - Check JSON syntax\n   - Verify server configurations:\n     - stdio: has `command` field\n     - sse/http/ws: has `url` field\n     - Type-specific fields present\n   - Check ${CLAUDE_PLUGIN_ROOT} usage for portability\n\n9. **Check File Organization**:\n   - README.md exists and is comprehensive\n   - No unnecessary files (node_modules, .DS_Store, etc.)\n   - .gitignore present if needed\n   - LICENSE file present\n\n10. **Security Checks**:\n    - No hardcoded credentials in any files\n    - MCP servers use HTTPS/WSS not HTTP/WS\n    - Hooks don't have obvious security issues\n    - No secrets in example files\n\n**Quality Standards:**\n- All validation errors include file path and specific issue\n- Warnings distinguished from errors\n- Provide fix suggestions for each issue\n- Include positive findings for well-structured components\n- Categorize by severity (critical/major/minor)\n\n**Output Format:**\n## Plugin Validation Report\n\n### Plugin: [name]\nLocation: [path]\n\n### Summary\n[Overall assessment - pass/fail with key stats]\n\n### Critical Issues ([count])\n- `file/path` - [Issue] - [Fix]\n\n### Warnings ([count])\n- `file/path` - [Issue] - [Recommendation]\n\n### Component Summary\n- Commands: [count] found, [count] valid\n- Agents: [count] found, [count] valid\n- Skills: [count] found, [count] valid\n- Hooks: [present/not present], [valid/invalid]\n- MCP Servers: [count] configured\n\n### Positive Findings\n- [What's done well]\n\n### Recommendations\n1. [Priority recommendation]\n2. [Additional recommendation]\n\n### Overall Assessment\n[PASS/FAIL] - [Reasoning]\n\n**Edge Cases:**\n- Minimal plugin (just plugin.json): Valid if manifest correct\n- Empty directories: Warn but don't fail\n- Unknown fields in manifest: Warn but don't fail\n- Multiple validation errors: Group by file, prioritize critical\n- Plugin not found: Clear error message with guidance\n- Corrupted files: Skip and report, continue validation\n```\n\nExcellent work! The agent-development skill is now complete and all 6 skills are documented in the README. Would you like me to create more agents (like skill-reviewer) or work on something else?"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/agents/skill-reviewer.md","content":"---\nname: skill-reviewer\ndescription: Use this agent when the user has created or modified a skill and needs quality review, asks to \"review my skill\", \"check skill quality\", \"improve skill description\", or wants to ensure skill follows best practices. Trigger proactively after skill creation. Examples:\n\n<example>\nContext: User just created a new skill\nuser: \"I've created a PDF processing skill\"\nassistant: \"Great! Let me review the skill quality.\"\n<commentary>\nSkill created, proactively trigger skill-reviewer to ensure it follows best practices.\n</commentary>\nassistant: \"I'll use the skill-reviewer agent to review the skill.\"\n</example>\n\n<example>\nContext: User requests skill review\nuser: \"Review my skill and tell me how to improve it\"\nassistant: \"I'll use the skill-reviewer agent to analyze the skill quality.\"\n<commentary>\nExplicit skill review request triggers the agent.\n</commentary>\n</example>\n\n<example>\nContext: User modified skill description\nuser: \"I updated the skill description, does it look good?\"\nassistant: \"I'll use the skill-reviewer agent to review the changes.\"\n<commentary>\nSkill description modified, review for triggering effectiveness.\n</commentary>\n</example>\n\nmodel: inherit\ncolor: cyan\ntools: [\"Read\", \"Grep\", \"Glob\"]\n---\n\nYou are an expert skill architect specializing in reviewing and improving Claude Code skills for maximum effectiveness and reliability.\n\n**Your Core Responsibilities:**\n1. Review skill structure and organization\n2. Evaluate description quality and triggering effectiveness\n3. Assess progressive disclosure implementation\n4. Check adherence to skill-creator best practices\n5. Provide specific recommendations for improvement\n\n**Skill Review Process:**\n\n1. **Locate and Read Skill**:\n   - Find SKILL.md file (user should indicate path)\n   - Read frontmatter and body content\n   - Check for supporting directories (references/, examples/, scripts/)\n\n2. **Validate Structure**:\n   - Frontmatter format (YAML between `---`)\n   - Required fields: `name`, `description`\n   - Optional fields: `version`, `when_to_use` (note: deprecated, use description only)\n   - Body content exists and is substantial\n\n3. **Evaluate Description** (Most Critical):\n   - **Trigger Phrases**: Does description include specific phrases users would say?\n   - **Third Person**: Uses \"This skill should be used when...\" not \"Load this skill when...\"\n   - **Specificity**: Concrete scenarios, not vague\n   - **Length**: Appropriate (not too short <50 chars, not too long >500 chars for description)\n   - **Example Triggers**: Lists specific user queries that should trigger skill\n\n4. **Assess Content Quality**:\n   - **Word Count**: SKILL.md body should be 1,000-3,000 words (lean, focused)\n   - **Writing Style**: Imperative/infinitive form (\"To do X, do Y\" not \"You should do X\")\n   - **Organization**: Clear sections, logical flow\n   - **Specificity**: Concrete guidance, not vague advice\n\n5. **Check Progressive Disclosure**:\n   - **Core SKILL.md**: Essential information only\n   - **references/**: Detailed docs moved out of core\n   - **examples/**: Working code examples separate\n   - **scripts/**: Utility scripts if needed\n   - **Pointers**: SKILL.md references these resources clearly\n\n6. **Review Supporting Files** (if present):\n   - **references/**: Check quality, relevance, organization\n   - **examples/**: Verify examples are complete and correct\n   - **scripts/**: Check scripts are executable and documented\n\n7. **Identify Issues**:\n   - Categorize by severity (critical/major/minor)\n   - Note anti-patterns:\n     - Vague trigger descriptions\n     - Too much content in SKILL.md (should be in references/)\n     - Second person in description\n     - Missing key triggers\n     - No examples/references when they'd be valuable\n\n8. **Generate Recommendations**:\n   - Specific fixes for each issue\n   - Before/after examples when helpful\n   - Prioritized by impact\n\n**Quality Standards:**\n- Description must have strong, specific trigger phrases\n- SKILL.md should be lean (under 3,000 words ideally)\n- Writing style must be imperative/infinitive form\n- Progressive disclosure properly implemented\n- All file references work correctly\n- Examples are complete and accurate\n\n**Output Format:**\n## Skill Review: [skill-name]\n\n### Summary\n[Overall assessment and word counts]\n\n### Description Analysis\n**Current:** [Show current description]\n\n**Issues:**\n- [Issue 1 with description]\n- [Issue 2...]\n\n**Recommendations:**\n- [Specific fix 1]\n- Suggested improved description: \"[better version]\"\n\n### Content Quality\n\n**SKILL.md Analysis:**\n- Word count: [count] ([assessment: too long/good/too short])\n- Writing style: [assessment]\n- Organization: [assessment]\n\n**Issues:**\n- [Content issue 1]\n- [Content issue 2]\n\n**Recommendations:**\n- [Specific improvement 1]\n- Consider moving [section X] to references/[filename].md\n\n### Progressive Disclosure\n\n**Current Structure:**\n- SKILL.md: [word count]\n- references/: [count] files, [total words]\n- examples/: [count] files\n- scripts/: [count] files\n\n**Assessment:**\n[Is progressive disclosure effective?]\n\n**Recommendations:**\n[Suggestions for better organization]\n\n### Specific Issues\n\n#### Critical ([count])\n- [File/location]: [Issue] - [Fix]\n\n#### Major ([count])\n- [File/location]: [Issue] - [Recommendation]\n\n#### Minor ([count])\n- [File/location]: [Issue] - [Suggestion]\n\n### Positive Aspects\n- [What's done well 1]\n- [What's done well 2]\n\n### Overall Rating\n[Pass/Needs Improvement/Needs Major Revision]\n\n### Priority Recommendations\n1. [Highest priority fix]\n2. [Second priority]\n3. [Third priority]\n\n**Edge Cases:**\n- Skill with no description issues: Focus on content and organization\n- Very long skill (>5,000 words): Strongly recommend splitting into references\n- New skill (minimal content): Provide constructive building guidance\n- Perfect skill: Acknowledge quality and suggest minor enhancements only\n- Missing referenced files: Report errors clearly with paths\n```\n\nThis agent helps users create high-quality skills by applying the same standards used in plugin-dev's own skills.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/agents/agent-creator.md","content":"---\nname: agent-creator\ndescription: Use this agent when the user asks to \"create an agent\", \"generate an agent\", \"build a new agent\", \"make me an agent that...\", or describes agent functionality they need. Trigger when user wants to create autonomous agents for plugins. Examples:\n\n<example>\nContext: User wants to create a code review agent\nuser: \"Create an agent that reviews code for quality issues\"\nassistant: \"I'll use the agent-creator agent to generate the agent configuration.\"\n<commentary>\nUser requesting new agent creation, trigger agent-creator to generate it.\n</commentary>\n</example>\n\n<example>\nContext: User describes needed functionality\nuser: \"I need an agent that generates unit tests for my code\"\nassistant: \"I'll use the agent-creator agent to create a test generation agent.\"\n<commentary>\nUser describes agent need, trigger agent-creator to build it.\n</commentary>\n</example>\n\n<example>\nContext: User wants to add agent to plugin\nuser: \"Add an agent to my plugin that validates configurations\"\nassistant: \"I'll use the agent-creator agent to generate a configuration validator agent.\"\n<commentary>\nPlugin development with agent addition, trigger agent-creator.\n</commentary>\n</example>\n\nmodel: sonnet\ncolor: magenta\ntools: [\"Write\", \"Read\"]\n---\n\nYou are an elite AI agent architect specializing in crafting high-performance agent configurations. Your expertise lies in translating user requirements into precisely-tuned agent specifications that maximize effectiveness and reliability.\n\n**Important Context**: You may have access to project-specific instructions from CLAUDE.md files and other context that may include coding standards, project structure, and custom requirements. Consider this context when creating agents to ensure they align with the project's established patterns and practices.\n\nWhen a user describes what they want an agent to do, you will:\n\n1. **Extract Core Intent**: Identify the fundamental purpose, key responsibilities, and success criteria for the agent. Look for both explicit requirements and implicit needs. Consider any project-specific context from CLAUDE.md files. For agents that are meant to review code, you should assume that the user is asking to review recently written code and not the whole codebase, unless the user has explicitly instructed you otherwise.\n\n2. **Design Expert Persona**: Create a compelling expert identity that embodies deep domain knowledge relevant to the task. The persona should inspire confidence and guide the agent's decision-making approach.\n\n3. **Architect Comprehensive Instructions**: Develop a system prompt that:\n   - Establishes clear behavioral boundaries and operational parameters\n   - Provides specific methodologies and best practices for task execution\n   - Anticipates edge cases and provides guidance for handling them\n   - Incorporates any specific requirements or preferences mentioned by the user\n   - Defines output format expectations when relevant\n   - Aligns with project-specific coding standards and patterns from CLAUDE.md\n\n4. **Optimize for Performance**: Include:\n   - Decision-making frameworks appropriate to the domain\n   - Quality control mechanisms and self-verification steps\n   - Efficient workflow patterns\n   - Clear escalation or fallback strategies\n\n5. **Create Identifier**: Design a concise, descriptive identifier that:\n   - Uses lowercase letters, numbers, and hyphens only\n   - Is typically 2-4 words joined by hyphens\n   - Clearly indicates the agent's primary function\n   - Is memorable and easy to type\n   - Avoids generic terms like \"helper\" or \"assistant\"\n\n6. **Craft Triggering Examples**: Create 2-4 `<example>` blocks showing:\n   - Different phrasings for same intent\n   - Both explicit and proactive triggering\n   - Context, user message, assistant response, commentary\n   - Why the agent should trigger in each scenario\n   - Show assistant using the Agent tool to launch the agent\n\n**Agent Creation Process:**\n\n1. **Understand Request**: Analyze user's description of what agent should do\n\n2. **Design Agent Configuration**:\n   - **Identifier**: Create concise, descriptive name (lowercase, hyphens, 3-50 chars)\n   - **Description**: Write triggering conditions starting with \"Use this agent when...\"\n   - **Examples**: Create 2-4 `<example>` blocks with:\n     ```\n     <example>\n     Context: [Situation that should trigger agent]\n     user: \"[User message]\"\n     assistant: \"[Response before triggering]\"\n     <commentary>\n     [Why agent should trigger]\n     </commentary>\n     assistant: \"I'll use the [agent-name] agent to [what it does].\"\n     </example>\n     ```\n   - **System Prompt**: Create comprehensive instructions with:\n     - Role and expertise\n     - Core responsibilities (numbered list)\n     - Detailed process (step-by-step)\n     - Quality standards\n     - Output format\n     - Edge case handling\n\n3. **Select Configuration**:\n   - **Model**: Use `inherit` unless user specifies (sonnet for complex, haiku for simple)\n   - **Color**: Choose appropriate color:\n     - blue/cyan: Analysis, review\n     - green: Generation, creation\n     - yellow: Validation, caution\n     - red: Security, critical\n     - magenta: Transformation, creative\n   - **Tools**: Recommend minimal set needed, or omit for full access\n\n4. **Generate Agent File**: Use Write tool to create `agents/[identifier].md`:\n   ```markdown\n   ---\n   name: [identifier]\n   description: [Use this agent when... Examples: <example>...</example>]\n   model: inherit\n   color: [chosen-color]\n   tools: [\"Tool1\", \"Tool2\"]  # Optional\n   ---\n\n   [Complete system prompt]\n   ```\n\n5. **Explain to User**: Provide summary of created agent:\n   - What it does\n   - When it triggers\n   - Where it's saved\n   - How to test it\n   - Suggest running validation: `Use the plugin-validator agent to check the plugin structure`\n\n**Quality Standards:**\n- Identifier follows naming rules (lowercase, hyphens, 3-50 chars)\n- Description has strong trigger phrases and 2-4 examples\n- Examples show both explicit and proactive triggering\n- System prompt is comprehensive (500-3,000 words)\n- System prompt has clear structure (role, responsibilities, process, output)\n- Model choice is appropriate\n- Tool selection follows least privilege\n- Color choice matches agent purpose\n\n**Output Format:**\nCreate agent file, then provide summary:\n\n## Agent Created: [identifier]\n\n### Configuration\n- **Name:** [identifier]\n- **Triggers:** [When it's used]\n- **Model:** [choice]\n- **Color:** [choice]\n- **Tools:** [list or \"all tools\"]\n\n### File Created\n`agents/[identifier].md` ([word count] words)\n\n### How to Use\nThis agent will trigger when [triggering scenarios].\n\nTest it by: [suggest test scenario]\n\nValidate with: `scripts/validate-agent.sh agents/[identifier].md`\n\n### Next Steps\n[Recommendations for testing, integration, or improvements]\n\n**Edge Cases:**\n- Vague user request: Ask clarifying questions before generating\n- Conflicts with existing agents: Note conflict, suggest different scope/name\n- Very complex requirements: Break into multiple specialized agents\n- User wants specific tool access: Honor the request in agent configuration\n- User specifies model: Use specified model instead of inherit\n- First agent in plugin: Create agents/ directory first\n```\n\nThis agent automates agent creation using the proven patterns from Claude Code's internal implementation, making it easy for users to create high-quality autonomous agents.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/README.md","content":"# Plugin Development Toolkit\n\nA comprehensive toolkit for developing Claude Code plugins with expert guidance on hooks, MCP integration, plugin structure, and marketplace publishing.\n\n## Overview\n\nThe plugin-dev toolkit provides seven specialized skills to help you build high-quality Claude Code plugins:\n\n1. **Hook Development** - Advanced hooks API and event-driven automation\n2. **MCP Integration** - Model Context Protocol server integration\n3. **Plugin Structure** - Plugin organization and manifest configuration\n4. **Plugin Settings** - Configuration patterns using .claude/plugin-name.local.md files\n5. **Command Development** - Creating slash commands with frontmatter and arguments\n6. **Agent Development** - Creating autonomous agents with AI-assisted generation\n7. **Skill Development** - Creating skills with progressive disclosure and strong triggers\n\nEach skill follows best practices with progressive disclosure: lean core documentation, detailed references, working examples, and utility scripts.\n\n## Guided Workflow Command\n\n### /plugin-dev:create-plugin\n\nA comprehensive, end-to-end workflow command for creating plugins from scratch, similar to the feature-dev workflow.\n\n**8-Phase Process:**\n1. **Discovery** - Understand plugin purpose and requirements\n2. **Component Planning** - Determine needed skills, commands, agents, hooks, MCP\n3. **Detailed Design** - Specify each component and resolve ambiguities\n4. **Structure Creation** - Set up directories and manifest\n5. **Component Implementation** - Create each component using AI-assisted agents\n6. **Validation** - Run plugin-validator and component-specific checks\n7. **Testing** - Verify plugin works in Claude Code\n8. **Documentation** - Finalize README and prepare for distribution\n\n**Features:**\n- Asks clarifying questions at each phase\n- Loads relevant skills automatically\n- Uses agent-creator for AI-assisted agent generation\n- Runs validation utilities (validate-agent.sh, validate-hook-schema.sh, etc.)\n- Follows plugin-dev's own proven patterns\n- Guides through testing and verification\n\n**Usage:**\n```bash\n/plugin-dev:create-plugin [optional description]\n\n# Examples:\n/plugin-dev:create-plugin\n/plugin-dev:create-plugin A plugin for managing database migrations\n```\n\nUse this workflow for structured, high-quality plugin development from concept to completion.\n\n## Skills\n\n### 1. Hook Development\n\n**Trigger phrases:** \"create a hook\", \"add a PreToolUse hook\", \"validate tool use\", \"implement prompt-based hooks\", \"${CLAUDE_PLUGIN_ROOT}\", \"block dangerous commands\"\n\n**What it covers:**\n- Prompt-based hooks (recommended) with LLM decision-making\n- Command hooks for deterministic validation\n- All hook events: PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification\n- Hook output formats and JSON schemas\n- Security best practices and input validation\n- ${CLAUDE_PLUGIN_ROOT} for portable paths\n\n**Resources:**\n- Core SKILL.md (1,619 words)\n- 3 example hook scripts (validate-write, validate-bash, load-context)\n- 3 reference docs: patterns, migration, advanced techniques\n- 3 utility scripts: validate-hook-schema.sh, test-hook.sh, hook-linter.sh\n\n**Use when:** Creating event-driven automation, validating operations, or enforcing policies in your plugin.\n\n### 2. MCP Integration\n\n**Trigger phrases:** \"add MCP server\", \"integrate MCP\", \"configure .mcp.json\", \"Model Context Protocol\", \"stdio/SSE/HTTP server\", \"connect external service\"\n\n**What it covers:**\n- MCP server configuration (.mcp.json vs plugin.json)\n- All server types: stdio (local), SSE (hosted/OAuth), HTTP (REST), WebSocket (real-time)\n- Environment variable expansion (${CLAUDE_PLUGIN_ROOT}, user vars)\n- MCP tool naming and usage in commands/agents\n- Authentication patterns: OAuth, tokens, env vars\n- Integration patterns and performance optimization\n\n**Resources:**\n- Core SKILL.md (1,666 words)\n- 3 example configurations (stdio, SSE, HTTP)\n- 3 reference docs: server-types (~3,200w), authentication (~2,800w), tool-usage (~2,600w)\n\n**Use when:** Integrating external services, APIs, databases, or tools into your plugin.\n\n### 3. Plugin Structure\n\n**Trigger phrases:** \"plugin structure\", \"plugin.json manifest\", \"auto-discovery\", \"component organization\", \"plugin directory layout\"\n\n**What it covers:**\n- Standard plugin directory structure and auto-discovery\n- plugin.json manifest format and all fields\n- Component organization (commands, agents, skills, hooks)\n- ${CLAUDE_PLUGIN_ROOT} usage throughout\n- File naming conventions and best practices\n- Minimal, standard, and advanced plugin patterns\n\n**Resources:**\n- Core SKILL.md (1,619 words)\n- 3 example structures (minimal, standard, advanced)\n- 2 reference docs: component-patterns, manifest-reference\n\n**Use when:** Starting a new plugin, organizing components, or configuring the plugin manifest.\n\n### 4. Plugin Settings\n\n**Trigger phrases:** \"plugin settings\", \"store plugin configuration\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\"\n\n**What it covers:**\n- .claude/plugin-name.local.md pattern for configuration\n- YAML frontmatter + markdown body structure\n- Parsing techniques for bash scripts (sed, awk, grep patterns)\n- Temporarily active hooks (flag files and quick-exit)\n- Real-world examples from multi-agent-swarm and ralph-wiggum plugins\n- Atomic file updates and validation\n- Gitignore and lifecycle management\n\n**Resources:**\n- Core SKILL.md (1,623 words)\n- 3 examples (read-settings hook, create-settings command, templates)\n- 2 reference docs: parsing-techniques, real-world-examples\n- 2 utility scripts: validate-settings.sh, parse-frontmatter.sh\n\n**Use when:** Making plugins configurable, storing per-project state, or implementing user preferences.\n\n### 5. Command Development\n\n**Trigger phrases:** \"create a slash command\", \"add a command\", \"command frontmatter\", \"define command arguments\", \"organize commands\"\n\n**What it covers:**\n- Slash command structure and markdown format\n- YAML frontmatter fields (description, argument-hint, allowed-tools)\n- Dynamic arguments and file references\n- Bash execution for context\n- Command organization and namespacing\n- Best practices for command development\n\n**Resources:**\n- Core SKILL.md (1,535 words)\n- Examples and reference documentation\n- Command organization patterns\n\n**Use when:** Creating slash commands, defining command arguments, or organizing plugin commands.\n\n### 6. Agent Development\n\n**Trigger phrases:** \"create an agent\", \"add an agent\", \"write a subagent\", \"agent frontmatter\", \"when to use description\", \"agent examples\", \"autonomous agent\"\n\n**What it covers:**\n- Agent file structure (YAML frontmatter + system prompt)\n- All frontmatter fields (name, description, model, color, tools)\n- Description format with <example> blocks for reliable triggering\n- System prompt design patterns (analysis, generation, validation, orchestration)\n- AI-assisted agent generation using Claude Code's proven prompt\n- Validation rules and best practices\n- Complete production-ready agent examples\n\n**Resources:**\n- Core SKILL.md (1,438 words)\n- 2 examples: agent-creation-prompt (AI-assisted workflow), complete-agent-examples (4 full agents)\n- 3 reference docs: agent-creation-system-prompt (from Claude Code), system-prompt-design (~4,000w), triggering-examples (~2,500w)\n- 1 utility script: validate-agent.sh\n\n**Use when:** Creating autonomous agents, defining agent behavior, or implementing AI-assisted agent generation.\n\n### 7. Skill Development\n\n**Trigger phrases:** \"create a skill\", \"add a skill to plugin\", \"write a new skill\", \"improve skill description\", \"organize skill content\"\n\n**What it covers:**\n- Skill structure (SKILL.md with YAML frontmatter)\n- Progressive disclosure principle (metadata â†’ SKILL.md â†’ resources)\n- Strong trigger descriptions with specific phrases\n- Writing style (imperative/infinitive form, third person)\n- Bundled resources organization (references/, examples/, scripts/)\n- Skill creation workflow\n- Based on skill-creator methodology adapted for Claude Code plugins\n\n**Resources:**\n- Core SKILL.md (1,232 words)\n- References: skill-creator methodology, plugin-dev patterns\n- Examples: Study plugin-dev's own skills as templates\n\n**Use when:** Creating new skills for plugins or improving existing skill quality.\n\n\n## Installation\n\nInstall from claude-code-marketplace:\n\n```bash\n/plugin install plugin-dev@claude-code-marketplace\n```\n\nOr for development, use directly:\n\n```bash\ncc --plugin-dir /path/to/plugin-dev\n```\n\n## Quick Start\n\n### Creating Your First Plugin\n\n1. **Plan your plugin structure:**\n   - Ask: \"What's the best directory structure for a plugin with commands and MCP integration?\"\n   - The plugin-structure skill will guide you\n\n2. **Add MCP integration (if needed):**\n   - Ask: \"How do I add an MCP server for database access?\"\n   - The mcp-integration skill provides examples and patterns\n\n3. **Implement hooks (if needed):**\n   - Ask: \"Create a PreToolUse hook that validates file writes\"\n   - The hook-development skill gives working examples and utilities\n\n\n## Development Workflow\n\nThe plugin-dev toolkit supports your entire plugin development lifecycle:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Design Structure   â”‚  â†’ plugin-structure skill\nâ”‚  (manifest, layout) â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n           â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Add Components     â”‚\nâ”‚  (commands, agents, â”‚  â†’ All skills provide guidance\nâ”‚   skills, hooks)    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n           â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Integrate Services â”‚  â†’ mcp-integration skill\nâ”‚  (MCP servers)      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n           â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Add Automation     â”‚  â†’ hook-development skill\nâ”‚  (hooks, validation)â”‚     + utility scripts\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n           â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Test & Validate    â”‚  â†’ hook-development utilities\nâ”‚                     â”‚     validate-hook-schema.sh\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     test-hook.sh\n           â”‚                 hook-linter.sh\n```\n\n## Features\n\n### Progressive Disclosure\n\nEach skill uses a three-level disclosure system:\n1. **Metadata** (always loaded): Concise descriptions with strong triggers\n2. **Core SKILL.md** (when triggered): Essential API reference (~1,500-2,000 words)\n3. **References/Examples** (as needed): Detailed guides, patterns, and working code\n\nThis keeps Claude Code's context focused while providing deep knowledge when needed.\n\n### Utility Scripts\n\nThe hook-development skill includes production-ready utilities:\n\n```bash\n# Validate hooks.json structure\n./validate-hook-schema.sh hooks/hooks.json\n\n# Test hooks before deployment\n./test-hook.sh my-hook.sh test-input.json\n\n# Lint hook scripts for best practices\n./hook-linter.sh my-hook.sh\n```\n\n### Working Examples\n\nEvery skill provides working examples:\n- **Hook Development**: 3 complete hook scripts (bash, write validation, context loading)\n- **MCP Integration**: 3 server configurations (stdio, SSE, HTTP)\n- **Plugin Structure**: 3 plugin layouts (minimal, standard, advanced)\n- **Plugin Settings**: 3 examples (read-settings hook, create-settings command, templates)\n- **Command Development**: 10 complete command examples (review, test, deploy, docs, etc.)\n\n## Documentation Standards\n\nAll skills follow consistent standards:\n- Third-person descriptions (\"This skill should be used when...\")\n- Strong trigger phrases for reliable loading\n- Imperative/infinitive form throughout\n- Based on official Claude Code documentation\n- Security-first approach with best practices\n\n## Total Content\n\n- **Core Skills**: ~11,065 words across 7 SKILL.md files\n- **Reference Docs**: ~10,000+ words of detailed guides\n- **Examples**: 12+ working examples (hook scripts, MCP configs, plugin layouts, settings files)\n- **Utilities**: 6 production-ready validation/testing/parsing scripts\n\n## Use Cases\n\n### Building a Database Plugin\n\n```\n1. \"What's the structure for a plugin with MCP integration?\"\n   â†’ plugin-structure skill provides layout\n\n2. \"How do I configure an stdio MCP server for PostgreSQL?\"\n   â†’ mcp-integration skill shows configuration\n\n3. \"Add a Stop hook to ensure connections close properly\"\n   â†’ hook-development skill provides pattern\n\n```\n\n### Creating a Validation Plugin\n\n```\n1. \"Create hooks that validate all file writes for security\"\n   â†’ hook-development skill with examples\n\n2. \"Test my hooks before deploying\"\n   â†’ Use validate-hook-schema.sh and test-hook.sh\n\n3. \"Organize my hooks and configuration files\"\n   â†’ plugin-structure skill shows best practices\n\n```\n\n### Integrating External Services\n\n```\n1. \"Add Asana MCP server with OAuth\"\n   â†’ mcp-integration skill covers SSE servers\n\n2. \"Use Asana tools in my commands\"\n   â†’ mcp-integration tool-usage reference\n\n3. \"Structure my plugin with commands and MCP\"\n   â†’ plugin-structure skill provides patterns\n```\n\n## Best Practices\n\nAll skills emphasize:\n\nâœ… **Security First**\n- Input validation in hooks\n- HTTPS/WSS for MCP servers\n- Environment variables for credentials\n- Principle of least privilege\n\nâœ… **Portability**\n- Use ${CLAUDE_PLUGIN_ROOT} everywhere\n- Relative paths only\n- Environment variable substitution\n\nâœ… **Testing**\n- Validate configurations before deployment\n- Test hooks with sample inputs\n- Use debug mode (`claude --debug`)\n\nâœ… **Documentation**\n- Clear README files\n- Documented environment variables\n- Usage examples\n\n## Contributing\n\nThis plugin is part of the claude-code-marketplace. To contribute improvements:\n\n1. Fork the marketplace repository\n2. Make changes to plugin-dev/\n3. Test locally with `cc --plugin-dir`\n4. Create PR following marketplace-publishing guidelines\n\n## Version\n\n0.1.0 - Initial release with seven comprehensive skills and three validation agents\n\n## Author\n\nDaisy Hollman (daisy@anthropic.com)\n\n## License\n\nMIT License - See repository for details\n\n---\n\n**Note:** This toolkit is designed to help you build high-quality plugins. The skills load automatically when you ask relevant questions, providing expert guidance exactly when you need it.\n"}
{"source":"github","repo":"claude-code","path":"plugins/plugin-dev/commands/create-plugin.md","content":"---\ndescription: Guided end-to-end plugin creation workflow with component design, implementation, and validation\nargument-hint: Optional plugin description\nallowed-tools: [\"Read\", \"Write\", \"Grep\", \"Glob\", \"Bash\", \"TodoWrite\", \"AskUserQuestion\", \"Skill\", \"Task\"]\n---\n\n# Plugin Creation Workflow\n\nGuide the user through creating a complete, high-quality Claude Code plugin from initial concept to tested implementation. Follow a systematic approach: understand requirements, design components, clarify details, implement following best practices, validate, and test.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities about plugin purpose, triggering, scope, and components. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation.\n- **Load relevant skills**: Use the Skill tool to load plugin-dev skills when needed (plugin-structure, hook-development, agent-development, etc.)\n- **Use specialized agents**: Leverage agent-creator, plugin-validator, and skill-reviewer agents for AI-assisted development\n- **Follow best practices**: Apply patterns from plugin-dev's own implementation\n- **Progressive disclosure**: Create lean skills with references/examples\n- **Use TodoWrite**: Track all progress throughout all phases\n\n**Initial request:** $ARGUMENTS\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what plugin needs to be built and what problem it solves\n\n**Actions**:\n1. Create todo list with all 7 phases\n2. If plugin purpose is clear from arguments:\n   - Summarize understanding\n   - Identify plugin type (integration, workflow, analysis, toolkit, etc.)\n3. If plugin purpose is unclear, ask user:\n   - What problem does this plugin solve?\n   - Who will use it and when?\n   - What should it do?\n   - Any similar plugins to reference?\n4. Summarize understanding and confirm with user before proceeding\n\n**Output**: Clear statement of plugin purpose and target users\n\n---\n\n## Phase 2: Component Planning\n\n**Goal**: Determine what plugin components are needed\n\n**MUST load plugin-structure skill** using Skill tool before this phase.\n\n**Actions**:\n1. Load plugin-structure skill to understand component types\n2. Analyze plugin requirements and determine needed components:\n   - **Skills**: Does it need specialized knowledge? (hooks API, MCP patterns, etc.)\n   - **Commands**: User-initiated actions? (deploy, configure, analyze)\n   - **Agents**: Autonomous tasks? (validation, generation, analysis)\n   - **Hooks**: Event-driven automation? (validation, notifications)\n   - **MCP**: External service integration? (databases, APIs)\n   - **Settings**: User configuration? (.local.md files)\n3. For each component type needed, identify:\n   - How many of each type\n   - What each one does\n   - Rough triggering/usage patterns\n4. Present component plan to user as table:\n   ```\n   | Component Type | Count | Purpose |\n   |----------------|-------|---------|\n   | Skills         | 2     | Hook patterns, MCP usage |\n   | Commands       | 3     | Deploy, configure, validate |\n   | Agents         | 1     | Autonomous validation |\n   | Hooks          | 0     | Not needed |\n   | MCP            | 1     | Database integration |\n   ```\n5. Get user confirmation or adjustments\n\n**Output**: Confirmed list of components to create\n\n---\n\n## Phase 3: Detailed Design & Clarifying Questions\n\n**Goal**: Specify each component in detail and resolve all ambiguities\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. For each component in the plan, identify underspecified aspects:\n   - **Skills**: What triggers them? What knowledge do they provide? How detailed?\n   - **Commands**: What arguments? What tools? Interactive or automated?\n   - **Agents**: When to trigger (proactive/reactive)? What tools? Output format?\n   - **Hooks**: Which events? Prompt or command based? Validation criteria?\n   - **MCP**: What server type? Authentication? Which tools?\n   - **Settings**: What fields? Required vs optional? Defaults?\n\n2. **Present all questions to user in organized sections** (one section per component type)\n\n3. **Wait for answers before proceeding to implementation**\n\n4. If user says \"whatever you think is best\", provide specific recommendations and get explicit confirmation\n\n**Example questions for a skill**:\n- What specific user queries should trigger this skill?\n- Should it include utility scripts? What functionality?\n- How detailed should the core SKILL.md be vs references/?\n- Any real-world examples to include?\n\n**Example questions for an agent**:\n- Should this agent trigger proactively after certain actions, or only when explicitly requested?\n- What tools does it need (Read, Write, Bash, etc.)?\n- What should the output format be?\n- Any specific quality standards to enforce?\n\n**Output**: Detailed specification for each component\n\n---\n\n## Phase 4: Plugin Structure Creation\n\n**Goal**: Create plugin directory structure and manifest\n\n**Actions**:\n1. Determine plugin name (kebab-case, descriptive)\n2. Choose plugin location:\n   - Ask user: \"Where should I create the plugin?\"\n   - Offer options: current directory, ../new-plugin-name, custom path\n3. Create directory structure using bash:\n   ```bash\n   mkdir -p plugin-name/.claude-plugin\n   mkdir -p plugin-name/skills     # if needed\n   mkdir -p plugin-name/commands   # if needed\n   mkdir -p plugin-name/agents     # if needed\n   mkdir -p plugin-name/hooks      # if needed\n   ```\n4. Create plugin.json manifest using Write tool:\n   ```json\n   {\n     \"name\": \"plugin-name\",\n     \"version\": \"0.1.0\",\n     \"description\": \"[brief description]\",\n     \"author\": {\n       \"name\": \"[author from user or default]\",\n       \"email\": \"[email or default]\"\n     }\n   }\n   ```\n5. Create README.md template\n6. Create .gitignore if needed (for .claude/*.local.md, etc.)\n7. Initialize git repo if creating new directory\n\n**Output**: Plugin directory structure created and ready for components\n\n---\n\n## Phase 5: Component Implementation\n\n**Goal**: Create each component following best practices\n\n**LOAD RELEVANT SKILLS** before implementing each component type:\n- Skills: Load skill-development skill\n- Commands: Load command-development skill\n- Agents: Load agent-development skill\n- Hooks: Load hook-development skill\n- MCP: Load mcp-integration skill\n- Settings: Load plugin-settings skill\n\n**Actions for each component**:\n\n### For Skills:\n1. Load skill-development skill using Skill tool\n2. For each skill:\n   - Ask user for concrete usage examples (or use from Phase 3)\n   - Plan resources (scripts/, references/, examples/)\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with specific trigger phrases\n     - Lean body (1,500-2,000 words) in imperative form\n     - References to supporting files\n   - Create reference files for detailed content\n   - Create example files for working code\n   - Create utility scripts if needed\n3. Use skill-reviewer agent to validate each skill\n\n### For Commands:\n1. Load command-development skill using Skill tool\n2. For each command:\n   - Write command markdown with frontmatter\n   - Include clear description and argument-hint\n   - Specify allowed-tools (minimal necessary)\n   - Write instructions FOR Claude (not TO user)\n   - Provide usage examples and tips\n   - Reference relevant skills if applicable\n\n### For Agents:\n1. Load agent-development skill using Skill tool\n2. For each agent, use agent-creator agent:\n   - Provide description of what agent should do\n   - Agent-creator generates: identifier, whenToUse with examples, systemPrompt\n   - Create agent markdown file with frontmatter and system prompt\n   - Add appropriate model, color, and tools\n   - Validate with validate-agent.sh script\n\n### For Hooks:\n1. Load hook-development skill using Skill tool\n2. For each hook:\n   - Create hooks/hooks.json with hook configuration\n   - Prefer prompt-based hooks for complex logic\n   - Use ${CLAUDE_PLUGIN_ROOT} for portability\n   - Create hook scripts if needed (in examples/ not scripts/)\n   - Test with validate-hook-schema.sh and test-hook.sh utilities\n\n### For MCP:\n1. Load mcp-integration skill using Skill tool\n2. Create .mcp.json configuration with:\n   - Server type (stdio for local, SSE for hosted)\n   - Command and args (with ${CLAUDE_PLUGIN_ROOT})\n   - extensionToLanguage mapping if LSP\n   - Environment variables as needed\n3. Document required env vars in README\n4. Provide setup instructions\n\n### For Settings:\n1. Load plugin-settings skill using Skill tool\n2. Create settings template in README\n3. Create example .claude/plugin-name.local.md file (as documentation)\n4. Implement settings reading in hooks/commands as needed\n5. Add to .gitignore: `.claude/*.local.md`\n\n**Progress tracking**: Update todos as each component is completed\n\n**Output**: All plugin components implemented\n\n---\n\n## Phase 6: Validation & Quality Check\n\n**Goal**: Ensure plugin meets quality standards and works correctly\n\n**Actions**:\n1. **Run plugin-validator agent**:\n   - Use plugin-validator agent to comprehensively validate plugin\n   - Check: manifest, structure, naming, components, security\n   - Review validation report\n\n2. **Fix critical issues**:\n   - Address any critical errors from validation\n   - Fix any warnings that indicate real problems\n\n3. **Review with skill-reviewer** (if plugin has skills):\n   - For each skill, use skill-reviewer agent\n   - Check description quality, progressive disclosure, writing style\n   - Apply recommendations\n\n4. **Test agent triggering** (if plugin has agents):\n   - For each agent, verify <example> blocks are clear\n   - Check triggering conditions are specific\n   - Run validate-agent.sh on agent files\n\n5. **Test hook configuration** (if plugin has hooks):\n   - Run validate-hook-schema.sh on hooks/hooks.json\n   - Test hook scripts with test-hook.sh\n   - Verify ${CLAUDE_PLUGIN_ROOT} usage\n\n6. **Present findings**:\n   - Summary of validation results\n   - Any remaining issues\n   - Overall quality assessment\n\n7. **Ask user**: \"Validation complete. Issues found: [count critical], [count warnings]. Would you like me to fix them now, or proceed to testing?\"\n\n**Output**: Plugin validated and ready for testing\n\n---\n\n## Phase 7: Testing & Verification\n\n**Goal**: Test that plugin works correctly in Claude Code\n\n**Actions**:\n1. **Installation instructions**:\n   - Show user how to test locally:\n     ```bash\n     cc --plugin-dir /path/to/plugin-name\n     ```\n   - Or copy to `.claude-plugin/` for project testing\n\n2. **Verification checklist** for user to perform:\n   - [ ] Skills load when triggered (ask questions with trigger phrases)\n   - [ ] Commands appear in `/help` and execute correctly\n   - [ ] Agents trigger on appropriate scenarios\n   - [ ] Hooks activate on events (if applicable)\n   - [ ] MCP servers connect (if applicable)\n   - [ ] Settings files work (if applicable)\n\n3. **Testing recommendations**:\n   - For skills: Ask questions using trigger phrases from descriptions\n   - For commands: Run `/plugin-name:command-name` with various arguments\n   - For agents: Create scenarios matching agent examples\n   - For hooks: Use `claude --debug` to see hook execution\n   - For MCP: Use `/mcp` to verify servers and tools\n\n4. **Ask user**: \"I've prepared the plugin for testing. Would you like me to guide you through testing each component, or do you want to test it yourself?\"\n\n5. **If user wants guidance**, walk through testing each component with specific test cases\n\n**Output**: Plugin tested and verified working\n\n---\n\n## Phase 8: Documentation & Next Steps\n\n**Goal**: Ensure plugin is well-documented and ready for distribution\n\n**Actions**:\n1. **Verify README completeness**:\n   - Check README has: overview, features, installation, prerequisites, usage\n   - For MCP plugins: Document required environment variables\n   - For hook plugins: Explain hook activation\n   - For settings: Provide configuration templates\n\n2. **Add marketplace entry** (if publishing):\n   - Show user how to add to marketplace.json\n   - Help draft marketplace description\n   - Suggest category and tags\n\n3. **Create summary**:\n   - Mark all todos complete\n   - List what was created:\n     - Plugin name and purpose\n     - Components created (X skills, Y commands, Z agents, etc.)\n     - Key files and their purposes\n     - Total file count and structure\n   - Next steps:\n     - Testing recommendations\n     - Publishing to marketplace (if desired)\n     - Iteration based on usage\n\n4. **Suggest improvements** (optional):\n   - Additional components that could enhance plugin\n   - Integration opportunities\n   - Testing strategies\n\n**Output**: Complete, documented plugin ready for use or publication\n\n---\n\n## Important Notes\n\n### Throughout All Phases\n\n- **Use TodoWrite** to track progress at every phase\n- **Load skills with Skill tool** when working on specific component types\n- **Use specialized agents** (agent-creator, plugin-validator, skill-reviewer)\n- **Ask for user confirmation** at key decision points\n- **Follow plugin-dev's own patterns** as reference examples\n- **Apply best practices**:\n  - Third-person descriptions for skills\n  - Imperative form in skill bodies\n  - Commands written FOR Claude\n  - Strong trigger phrases\n  - ${CLAUDE_PLUGIN_ROOT} for portability\n  - Progressive disclosure\n  - Security-first (HTTPS, no hardcoded credentials)\n\n### Key Decision Points (Wait for User)\n\n1. After Phase 1: Confirm plugin purpose\n2. After Phase 2: Approve component plan\n3. After Phase 3: Proceed to implementation\n4. After Phase 6: Fix issues or proceed\n5. After Phase 7: Continue to documentation\n\n### Skills to Load by Phase\n\n- **Phase 2**: plugin-structure\n- **Phase 5**: skill-development, command-development, agent-development, hook-development, mcp-integration, plugin-settings (as needed)\n- **Phase 6**: (agents will use skills automatically)\n\n### Quality Standards\n\nEvery component must meet these standards:\n- âœ… Follows plugin-dev's proven patterns\n- âœ… Uses correct naming conventions\n- âœ… Has strong trigger conditions (skills/agents)\n- âœ… Includes working examples\n- âœ… Properly documented\n- âœ… Validated with utilities\n- âœ… Tested in Claude Code\n\n---\n\n## Example Workflow\n\n### User Request\n\"Create a plugin for managing database migrations\"\n\n### Phase 1: Discovery\n- Understand: Migration management, database schema versioning\n- Confirm: User wants to create, run, rollback migrations\n\n### Phase 2: Component Planning\n- Skills: 1 (migration best practices)\n- Commands: 3 (create-migration, run-migrations, rollback)\n- Agents: 1 (migration-validator)\n- MCP: 1 (database connection)\n\n### Phase 3: Clarifying Questions\n- Which databases? (PostgreSQL, MySQL, etc.)\n- Migration file format? (SQL, code-based?)\n- Should agent validate before applying?\n- What MCP tools needed? (query, execute, schema)\n\n### Phase 4-8: Implementation, Validation, Testing, Documentation\n\n---\n\n**Begin with Phase 1: Discovery**\n"}
{"source":"github","repo":"claude-code","path":"plugins/ralph-wiggum/README.md","content":"# Ralph Wiggum Plugin\n\nImplementation of the Ralph Wiggum technique for iterative, self-referential AI development loops in Claude Code.\n\n## What is Ralph?\n\nRalph is a development methodology based on continuous AI agent loops. As Geoffrey Huntley describes it: **\"Ralph is a Bash loop\"** - a simple `while true` that repeatedly feeds an AI agent a prompt file, allowing it to iteratively improve its work until completion.\n\nThe technique is named after Ralph Wiggum from The Simpsons, embodying the philosophy of persistent iteration despite setbacks.\n\n### Core Concept\n\nThis plugin implements Ralph using a **Stop hook** that intercepts Claude's exit attempts:\n\n```bash\n# You run ONCE:\n/ralph-loop \"Your task description\" --completion-promise \"DONE\"\n\n# Then Claude Code automatically:\n# 1. Works on the task\n# 2. Tries to exit\n# 3. Stop hook blocks exit\n# 4. Stop hook feeds the SAME prompt back\n# 5. Repeat until completion\n```\n\nThe loop happens **inside your current session** - you don't need external bash loops. The Stop hook in `hooks/stop-hook.sh` creates the self-referential feedback loop by blocking normal session exit.\n\nThis creates a **self-referential feedback loop** where:\n- The prompt never changes between iterations\n- Claude's previous work persists in files\n- Each iteration sees modified files and git history\n- Claude autonomously improves by reading its own past work in files\n\n## Quick Start\n\n```bash\n/ralph-loop \"Build a REST API for todos. Requirements: CRUD operations, input validation, tests. Output <promise>COMPLETE</promise> when done.\" --completion-promise \"COMPLETE\" --max-iterations 50\n```\n\nClaude will:\n- Implement the API iteratively\n- Run tests and see failures\n- Fix bugs based on test output\n- Iterate until all requirements met\n- Output the completion promise when done\n\n## Commands\n\n### /ralph-loop\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```bash\n/ralph-loop \"<prompt>\" --max-iterations <n> --completion-promise \"<text>\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Stop after N iterations (default: unlimited)\n- `--completion-promise <text>` - Phrase that signals completion\n\n### /cancel-ralph\n\nCancel the active Ralph loop.\n\n**Usage:**\n```bash\n/cancel-ralph\n```\n\n## Prompt Writing Best Practices\n\n### 1. Clear Completion Criteria\n\nâŒ Bad: \"Build a todo API and make it good.\"\n\nâœ… Good:\n```markdown\nBuild a REST API for todos.\n\nWhen complete:\n- All CRUD endpoints working\n- Input validation in place\n- Tests passing (coverage > 80%)\n- README with API docs\n- Output: <promise>COMPLETE</promise>\n```\n\n### 2. Incremental Goals\n\nâŒ Bad: \"Create a complete e-commerce platform.\"\n\nâœ… Good:\n```markdown\nPhase 1: User authentication (JWT, tests)\nPhase 2: Product catalog (list/search, tests)\nPhase 3: Shopping cart (add/remove, tests)\n\nOutput <promise>COMPLETE</promise> when all phases done.\n```\n\n### 3. Self-Correction\n\nâŒ Bad: \"Write code for feature X.\"\n\nâœ… Good:\n```markdown\nImplement feature X following TDD:\n1. Write failing tests\n2. Implement feature\n3. Run tests\n4. If any fail, debug and fix\n5. Refactor if needed\n6. Repeat until all green\n7. Output: <promise>COMPLETE</promise>\n```\n\n### 4. Escape Hatches\n\nAlways use `--max-iterations` as a safety net to prevent infinite loops on impossible tasks:\n\n```bash\n# Recommended: Always set a reasonable iteration limit\n/ralph-loop \"Try to implement feature X\" --max-iterations 20\n\n# In your prompt, include what to do if stuck:\n# \"After 15 iterations, if not complete:\n#  - Document what's blocking progress\n#  - List what was attempted\n#  - Suggest alternative approaches\"\n```\n\n**Note**: The `--completion-promise` uses exact string matching, so you cannot use it for multiple completion conditions (like \"SUCCESS\" vs \"BLOCKED\"). Always rely on `--max-iterations` as your primary safety mechanism.\n\n## Philosophy\n\nRalph embodies several key principles:\n\n### 1. Iteration > Perfection\nDon't aim for perfect on first try. Let the loop refine the work.\n\n### 2. Failures Are Data\n\"Deterministically bad\" means failures are predictable and informative. Use them to tune prompts.\n\n### 3. Operator Skill Matters\nSuccess depends on writing good prompts, not just having a good model.\n\n### 4. Persistence Wins\nKeep trying until success. The loop handles retry logic automatically.\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement (e.g., getting tests to pass)\n- Greenfield projects where you can walk away\n- Tasks with automatic verification (tests, linters)\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Production debugging (use targeted debugging instead)\n\n## Real-World Results\n\n- Successfully generated 6 repositories overnight in Y Combinator hackathon testing\n- One $50k contract completed for $297 in API costs\n- Created entire programming language (\"cursed\") over 3 months using this approach\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator\n\n## For Help\n\nRun `/help` in Claude Code for detailed command reference and examples.\n"}
{"source":"github","repo":"claude-code","path":"plugins/ralph-wiggum/commands/help.md","content":"---\ndescription: \"Explain Ralph Wiggum technique and available commands\"\n---\n\n# Ralph Wiggum Plugin Help\n\nPlease explain the following to the user:\n\n## What is the Ralph Wiggum Technique?\n\nThe Ralph Wiggum technique is an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator\n"}
{"source":"github","repo":"claude-code","path":"plugins/ralph-wiggum/commands/ralph-loop.md","content":"---\ndescription: \"Start Ralph Wiggum loop in current session\"\nargument-hint: \"PROMPT [--max-iterations N] [--completion-promise TEXT]\"\nallowed-tools: [\"Bash(${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh)\"]\nhide-from-slash-command-tool: \"true\"\n---\n\n# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop:\n\n```!\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n\n# Extract and display completion promise if set\nif [ -f .claude/ralph-loop.local.md ]; then\n  PROMISE=$(grep '^completion_promise:' .claude/ralph-loop.local.md | sed 's/completion_promise: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n  if [ -n \"$PROMISE\" ] && [ \"$PROMISE\" != \"null\" ]; then\n    echo \"\"\n    echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo \"CRITICAL - Ralph Loop Completion Promise\"\n    echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n    echo \"\"\n    echo \"To complete this loop, output this EXACT text:\"\n    echo \"  <promise>$PROMISE</promise>\"\n    echo \"\"\n    echo \"STRICT REQUIREMENTS (DO NOT VIOLATE):\"\n    echo \"  âœ“ Use <promise> XML tags EXACTLY as shown above\"\n    echo \"  âœ“ The statement MUST be completely and unequivocally TRUE\"\n    echo \"  âœ“ Do NOT output false statements to exit the loop\"\n    echo \"  âœ“ Do NOT lie even if you think you should exit\"\n    echo \"\"\n    echo \"IMPORTANT - Do not circumvent the loop:\"\n    echo \"  Even if you believe you're stuck, the task is impossible,\"\n    echo \"  or you've been running too long - you MUST NOT output a\"\n    echo \"  false promise statement. The loop is designed to continue\"\n    echo \"  until the promise is GENUINELY TRUE. Trust the process.\"\n    echo \"\"\n    echo \"  If the loop should stop, the promise statement will become\"\n    echo \"  true naturally. Do not force it by lying.\"\n    echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\n  fi\nfi\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion.\n"}
{"source":"github","repo":"claude-code","path":"plugins/ralph-wiggum/commands/cancel-ralph.md","content":"---\ndescription: \"Cancel active Ralph Wiggum loop\"\nallowed-tools: [\"Bash\"]\nhide-from-slash-command-tool: \"true\"\n---\n\n# Cancel Ralph\n\n```!\nif [[ -f .claude/ralph-loop.local.md ]]; then\n  ITERATION=$(grep '^iteration:' .claude/ralph-loop.local.md | sed 's/iteration: *//')\n  echo \"FOUND_LOOP=true\"\n  echo \"ITERATION=$ITERATION\"\nelse\n  echo \"FOUND_LOOP=false\"\nfi\n```\n\nCheck the output above:\n\n1. **If FOUND_LOOP=false**:\n   - Say \"No active Ralph loop found.\"\n\n2. **If FOUND_LOOP=true**:\n   - Use Bash: `rm .claude/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop (was at iteration N)\" where N is the ITERATION value from above.\n"}
{"source":"github","repo":"claude-code","path":"plugins/explanatory-output-style/README.md","content":"# Explanatory Output Style Plugin\n\nThis plugin recreates the deprecated Explanatory output style as a SessionStart\nhook.\n\nWARNING: Do not install this plugin unless you are fine with incurring the token\ncost of this plugin's additional instructions and output.\n\n## What it does\n\nWhen enabled, this plugin automatically adds instructions at the start of each\nsession that encourage Claude to:\n\n1. Provide educational insights about implementation choices\n2. Explain codebase patterns and decisions\n3. Balance task completion with learning opportunities\n\n## How it works\n\nThe plugin uses a SessionStart hook to inject additional context into every\nsession. This context instructs Claude to provide brief educational explanations\nbefore and after writing code, formatted as:\n\n```\n`â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`\n[2-3 key educational points]\n`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`\n```\n\n## Usage\n\nOnce installed, the plugin activates automatically at the start of every\nsession. No additional configuration is needed.\n\nThe insights focus on:\n\n- Specific implementation choices for your codebase\n- Patterns and conventions in your code\n- Trade-offs and design decisions\n- Codebase-specific details rather than general programming concepts\n\n## Migration from Output Styles\n\nThis plugin replaces the deprecated \"Explanatory\" output style setting. If you\npreviously used:\n\n```json\n{\n  \"outputStyle\": \"Explanatory\"\n}\n```\n\nYou can now achieve the same behavior by installing this plugin instead.\n\nMore generally, this SessionStart hook pattern is roughly equivalent to\nCLAUDE.md, but it is more flexible and allows for distribution through plugins.\n\nNote: Output styles that involve tasks besides software development, are better\nexpressed as\n[subagents](https://docs.claude.com/en/docs/claude-code/sub-agents), not as\nSessionStart hooks. Subagents change the system prompt while SessionStart hooks\nadd to the default system prompt.\n\n## Managing changes\n\n- Disable the plugin - keep the code installed on your device\n- Uninstall the plugin - remove the code from your device\n- Update the plugin - create a local copy of this plugin to personalize this\n  plugin\n  - Hint: Ask Claude to read\n    https://docs.claude.com/en/docs/claude-code/plugins.md and set it up for\n    you!\n"}
{"source":"github","repo":"claude-code","path":"plugins/README.md","content":"# Claude Code Plugins\n\nThis directory contains some official Claude Code plugins that extend functionality through custom commands, agents, and workflows. These are examples of what's possible with the Claude Code plugin systemâ€”many more plugins are available through community marketplaces.\n\n## What are Claude Code Plugins?\n\nClaude Code plugins are extensions that enhance Claude Code with custom slash commands, specialized agents, hooks, and MCP servers. Plugins can be shared across projects and teams, providing consistent tooling and workflows.\n\nLearn more in the [official plugins documentation](https://docs.claude.com/en/docs/claude-code/plugins).\n\n## Plugins in This Directory\n\n| Name | Description | Contents |\n|------|-------------|----------|\n| [agent-sdk-dev](./agent-sdk-dev/) | Development kit for working with the Claude Agent SDK | **Command:** `/new-sdk-app` - Interactive setup for new Agent SDK projects<br>**Agents:** `agent-sdk-verifier-py`, `agent-sdk-verifier-ts` - Validate SDK applications against best practices |\n| [claude-opus-4-5-migration](./claude-opus-4-5-migration/) | Migrate code and prompts from Sonnet 4.x and Opus 4.1 to Opus 4.5 | **Skill:** `claude-opus-4-5-migration` - Automated migration of model strings, beta headers, and prompt adjustments |\n| [code-review](./code-review/) | Automated PR code review using multiple specialized agents with confidence-based scoring to filter false positives | **Command:** `/code-review` - Automated PR review workflow<br>**Agents:** 5 parallel Sonnet agents for CLAUDE.md compliance, bug detection, historical context, PR history, and code comments |\n| [commit-commands](./commit-commands/) | Git workflow automation for committing, pushing, and creating pull requests | **Commands:** `/commit`, `/commit-push-pr`, `/clean_gone` - Streamlined git operations |\n| [explanatory-output-style](./explanatory-output-style/) | Adds educational insights about implementation choices and codebase patterns (mimics the deprecated Explanatory output style) | **Hook:** SessionStart - Injects educational context at the start of each session |\n| [feature-dev](./feature-dev/) | Comprehensive feature development workflow with a structured 7-phase approach | **Command:** `/feature-dev` - Guided feature development workflow<br>**Agents:** `code-explorer`, `code-architect`, `code-reviewer` - For codebase analysis, architecture design, and quality review |\n| [frontend-design](./frontend-design/) | Create distinctive, production-grade frontend interfaces that avoid generic AI aesthetics | **Skill:** `frontend-design` - Auto-invoked for frontend work, providing guidance on bold design choices, typography, animations, and visual details |\n| [hookify](./hookify/) | Easily create custom hooks to prevent unwanted behaviors by analyzing conversation patterns or explicit instructions | **Commands:** `/hookify`, `/hookify:list`, `/hookify:configure`, `/hookify:help`<br>**Agent:** `conversation-analyzer` - Analyzes conversations for problematic behaviors<br>**Skill:** `writing-rules` - Guidance on hookify rule syntax |\n| [learning-output-style](./learning-output-style/) | Interactive learning mode that requests meaningful code contributions at decision points (mimics the unshipped Learning output style) | **Hook:** SessionStart - Encourages users to write meaningful code (5-10 lines) at decision points while receiving educational insights |\n| [plugin-dev](./plugin-dev/) | Comprehensive toolkit for developing Claude Code plugins with 7 expert skills and AI-assisted creation | **Command:** `/plugin-dev:create-plugin` - 8-phase guided workflow for building plugins<br>**Agents:** `agent-creator`, `plugin-validator`, `skill-reviewer`<br>**Skills:** Hook development, MCP integration, plugin structure, settings, commands, agents, and skill development |\n| [pr-review-toolkit](./pr-review-toolkit/) | Comprehensive PR review agents specializing in comments, tests, error handling, type design, code quality, and code simplification | **Command:** `/pr-review-toolkit:review-pr` - Run with optional review aspects (comments, tests, errors, types, code, simplify, all)<br>**Agents:** `comment-analyzer`, `pr-test-analyzer`, `silent-failure-hunter`, `type-design-analyzer`, `code-reviewer`, `code-simplifier` |\n| [ralph-wiggum](./ralph-wiggum/) | Interactive self-referential AI loops for iterative development. Claude works on the same task repeatedly until completion | **Commands:** `/ralph-loop`, `/cancel-ralph` - Start/stop autonomous iteration loops<br>**Hook:** Stop - Intercepts exit attempts to continue iteration |\n| [security-guidance](./security-guidance/) | Security reminder hook that warns about potential security issues when editing files | **Hook:** PreToolUse - Monitors 9 security patterns including command injection, XSS, eval usage, dangerous HTML, pickle deserialization, and os.system calls |\n\n## Installation\n\nThese plugins are included in the Claude Code repository. To use them in your own projects:\n\n1. Install Claude Code globally:\n```bash\nnpm install -g @anthropic-ai/claude-code\n```\n\n2. Navigate to your project and run Claude Code:\n```bash\nclaude\n```\n\n3. Use the `/plugin` command to install plugins from marketplaces, or configure them in your project's `.claude/settings.json`.\n\nFor detailed plugin installation and configuration, see the [official documentation](https://docs.claude.com/en/docs/claude-code/plugins).\n\n## Plugin Structure\n\nEach plugin follows the standard Claude Code plugin structure:\n\n```\nplugin-name/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Plugin metadata\nâ”œâ”€â”€ commands/                # Slash commands (optional)\nâ”œâ”€â”€ agents/                  # Specialized agents (optional)\nâ”œâ”€â”€ skills/                  # Agent Skills (optional)\nâ”œâ”€â”€ hooks/                   # Event handlers (optional)\nâ”œâ”€â”€ .mcp.json                # External tool configuration (optional)\nâ””â”€â”€ README.md                # Plugin documentation\n```\n\n## Contributing\n\nWhen adding new plugins to this directory:\n\n1. Follow the standard plugin structure\n2. Include a comprehensive README.md\n3. Add plugin metadata in `.claude-plugin/plugin.json`\n4. Document all commands and agents\n5. Provide usage examples\n\n## Learn More\n\n- [Claude Code Documentation](https://docs.claude.com/en/docs/claude-code/overview)\n- [Plugin System Documentation](https://docs.claude.com/en/docs/claude-code/plugins)\n- [Agent SDK Documentation](https://docs.claude.com/en/api/agent-sdk/overview)\n"}
{"source":"github","repo":"claude-code","path":"plugins/code-review/README.md","content":"# Code Review Plugin\n\nAutomated code review for pull requests using multiple specialized agents with confidence-based scoring to filter false positives.\n\n## Overview\n\nThe Code Review Plugin automates pull request review by launching multiple agents in parallel to independently audit changes from different perspectives. It uses confidence scoring to filter out false positives, ensuring only high-quality, actionable feedback is posted.\n\n## Commands\n\n### `/code-review`\n\nPerforms automated code review on a pull request using multiple specialized agents.\n\n**What it does:**\n1. Checks if review is needed (skips closed, draft, trivial, or already-reviewed PRs)\n2. Gathers relevant CLAUDE.md guideline files from the repository\n3. Summarizes the pull request changes\n4. Launches 4 parallel agents to independently review:\n   - **Agents #1 & #2**: Audit for CLAUDE.md compliance\n   - **Agent #3**: Scan for obvious bugs in changes\n   - **Agent #4**: Analyze git blame/history for context-based issues\n5. Scores each issue 0-100 for confidence level\n6. Filters out issues below 80 confidence threshold\n7. Posts review comment with high-confidence issues only\n\n**Usage:**\n```bash\n/code-review\n```\n\n**Example workflow:**\n```bash\n# On a PR branch, run:\n/code-review\n\n# Claude will:\n# - Launch 4 review agents in parallel\n# - Score each issue for confidence\n# - Post comment with issues â‰¥80 confidence\n# - Skip posting if no high-confidence issues found\n```\n\n**Features:**\n- Multiple independent agents for comprehensive review\n- Confidence-based scoring reduces false positives (threshold: 80)\n- CLAUDE.md compliance checking with explicit guideline verification\n- Bug detection focused on changes (not pre-existing issues)\n- Historical context analysis via git blame\n- Automatic skipping of closed, draft, or already-reviewed PRs\n- Links directly to code with full SHA and line ranges\n\n**Review comment format:**\n```markdown\n## Code review\n\nFound 3 issues:\n\n1. Missing error handling for OAuth callback (CLAUDE.md says \"Always handle OAuth errors\")\n\nhttps://github.com/owner/repo/blob/abc123.../src/auth.ts#L67-L72\n\n2. Memory leak: OAuth state not cleaned up (bug due to missing cleanup in finally block)\n\nhttps://github.com/owner/repo/blob/abc123.../src/auth.ts#L88-L95\n\n3. Inconsistent naming pattern (src/conventions/CLAUDE.md says \"Use camelCase for functions\")\n\nhttps://github.com/owner/repo/blob/abc123.../src/utils.ts#L23-L28\n```\n\n**Confidence scoring:**\n- **0**: Not confident, false positive\n- **25**: Somewhat confident, might be real\n- **50**: Moderately confident, real but minor\n- **75**: Highly confident, real and important\n- **100**: Absolutely certain, definitely real\n\n**False positives filtered:**\n- Pre-existing issues not introduced in PR\n- Code that looks like a bug but isn't\n- Pedantic nitpicks\n- Issues linters will catch\n- General quality issues (unless in CLAUDE.md)\n- Issues with lint ignore comments\n\n## Installation\n\nThis plugin is included in the Claude Code repository. The command is automatically available when using Claude Code.\n\n## Best Practices\n\n### Using `/code-review`\n- Maintain clear CLAUDE.md files for better compliance checking\n- Trust the 80+ confidence threshold - false positives are filtered\n- Run on all non-trivial pull requests\n- Review agent findings as a starting point for human review\n- Update CLAUDE.md based on recurring review patterns\n\n### When to use\n- All pull requests with meaningful changes\n- PRs touching critical code paths\n- PRs from multiple contributors\n- PRs where guideline compliance matters\n\n### When not to use\n- Closed or draft PRs (automatically skipped anyway)\n- Trivial automated PRs (automatically skipped)\n- Urgent hotfixes requiring immediate merge\n- PRs already reviewed (automatically skipped)\n\n## Workflow Integration\n\n### Standard PR review workflow:\n```bash\n# Create PR with changes\n/code-review\n\n# Review the automated feedback\n# Make any necessary fixes\n# Merge when ready\n```\n\n### As part of CI/CD:\n```bash\n# Trigger on PR creation or update\n# Automatically posts review comments\n# Skip if review already exists\n```\n\n## Requirements\n\n- Git repository with GitHub integration\n- GitHub CLI (`gh`) installed and authenticated\n- CLAUDE.md files (optional but recommended for guideline checking)\n\n## Troubleshooting\n\n### Review takes too long\n\n**Issue**: Agents are slow on large PRs\n\n**Solution**:\n- Normal for large changes - agents run in parallel\n- 4 independent agents ensure thoroughness\n- Consider splitting large PRs into smaller ones\n\n### Too many false positives\n\n**Issue**: Review flags issues that aren't real\n\n**Solution**:\n- Default threshold is 80 (already filters most false positives)\n- Make CLAUDE.md more specific about what matters\n- Consider if the flagged issue is actually valid\n\n### No review comment posted\n\n**Issue**: `/code-review` runs but no comment appears\n\n**Solution**:\nCheck if:\n- PR is closed (reviews skipped)\n- PR is draft (reviews skipped)\n- PR is trivial/automated (reviews skipped)\n- PR already has review (reviews skipped)\n- No issues scored â‰¥80 (no comment needed)\n\n### Link formatting broken\n\n**Issue**: Code links don't render correctly in GitHub\n\n**Solution**:\nLinks must follow this exact format:\n```\nhttps://github.com/owner/repo/blob/[full-sha]/path/file.ext#L[start]-L[end]\n```\n- Must use full SHA (not abbreviated)\n- Must use `#L` notation\n- Must include line range with at least 1 line of context\n\n### GitHub CLI not working\n\n**Issue**: `gh` commands fail\n\n**Solution**:\n- Install GitHub CLI: `brew install gh` (macOS) or see [GitHub CLI installation](https://cli.github.com/)\n- Authenticate: `gh auth login`\n- Verify repository has GitHub remote\n\n## Tips\n\n- **Write specific CLAUDE.md files**: Clear guidelines = better reviews\n- **Include context in PRs**: Helps agents understand intent\n- **Use confidence scores**: Issues â‰¥80 are usually correct\n- **Iterate on guidelines**: Update CLAUDE.md based on patterns\n- **Review automatically**: Set up as part of PR workflow\n- **Trust the filtering**: Threshold prevents noise\n\n## Configuration\n\n### Adjusting confidence threshold\n\nThe default threshold is 80. To adjust, modify the command file at `commands/code-review.md`:\n```markdown\nFilter out any issues with a score less than 80.\n```\n\nChange `80` to your preferred threshold (0-100).\n\n### Customizing review focus\n\nEdit `commands/code-review.md` to add or modify agent tasks:\n- Add security-focused agents\n- Add performance analysis agents\n- Add accessibility checking agents\n- Add documentation quality checks\n\n## Technical Details\n\n### Agent architecture\n- **2x CLAUDE.md compliance agents**: Redundancy for guideline checks\n- **1x bug detector**: Focused on obvious bugs in changes only\n- **1x history analyzer**: Context from git blame and history\n- **Nx confidence scorers**: One per issue for independent scoring\n\n### Scoring system\n- Each issue independently scored 0-100\n- Scoring considers evidence strength and verification\n- Threshold (default 80) filters low-confidence issues\n- For CLAUDE.md issues: verifies guideline explicitly mentions it\n\n### GitHub integration\nUses `gh` CLI for:\n- Viewing PR details and diffs\n- Fetching repository data\n- Reading git blame and history\n- Posting review comments\n\n## Author\n\nBoris Cherny (boris@anthropic.com)\n\n## Version\n\n1.0.0\n"}
{"source":"github","repo":"claude-code","path":"plugins/code-review/commands/code-review.md","content":"---\nallowed-tools: Bash(gh issue view:*), Bash(gh search:*), Bash(gh issue list:*), Bash(gh pr comment:*), Bash(gh pr diff:*), Bash(gh pr view:*), Bash(gh pr list:*)\ndescription: Code review a pull request\n---\n\nProvide a code review for the given pull request.\n\nTo do this, follow these steps precisely:\n\n1. Launch a haiku agent to check if any of the following are true:\n   - The pull request is closed\n   - The pull request is a draft\n   - The pull request does not need code review (e.g. automated PR, trivial change that is obviously correct)\n   - You have already submitted a code review on this pull request\n\n   If any condition is true, stop and do not proceed.\n\nNote: Still review Claude generated PR's.\n\n2. Launch a haiku agent to return a list of file paths (not their contents) for all relevant CLAUDE.md files including:\n   - The root CLAUDE.md file, if it exists\n   - Any CLAUDE.md files in directories containing files modified by the pull request\n\n3. Launch a sonnet agent to view the pull request and return a summary of the changes\n\n4. Launch 4 agents in parallel to independently review the changes. Each agent should return the list of issues, where each issue includes a description and the reason it was flagged (e.g. \"CLAUDE.md adherence\", \"bug\"). The agents should do the following:\n\n   Agents 1 + 2: CLAUDE.md compliance sonnet agents\n   Audit changes for CLAUDE.md compliance in parallel. Note: When evaluating CLAUDE.md compliance for a file, you should only consider CLAUDE.md files that share a file path with the file or parents.\n\n   Agent 3: Opus bug agent (parallel subagent with agent 4)\n   Scan for obvious bugs. Focus only on the diff itself without reading extra context. Flag only significant bugs; ignore nitpicks and likely false positives. Do not flag issues that you cannot validate without looking at context outside of the git diff.\n\n   Agent 4: Opus bug agent (parallel subagent with agent 3)\n   Look for problems that exist in the introduced code. This could be security issues, incorrect logic, etc. Only look for issues that fall within the changed code.\n\n   **CRITICAL: We only want HIGH SIGNAL issues.** This means:\n   - Objective bugs that will cause incorrect behavior at runtime\n   - Clear, unambiguous CLAUDE.md violations where you can quote the exact rule being broken\n\n   We do NOT want:\n   - Subjective concerns or \"suggestions\"\n   - Style preferences not explicitly required by CLAUDE.md\n   - Potential issues that \"might\" be problems\n   - Anything requiring interpretation or judgment calls\n\n   If you are not certain an issue is real, do not flag it. False positives erode trust and waste reviewer time.\n\n   In addition to the above, each subagent should be told the PR title and description. This will help provide context regarding the author's intent.\n\n5. For each issue found in the previous step by agents 3 and 4, launch parallel subagents to validate the issue. These subagents should get the PR title and description along with a description of the issue. The agent's job is to review the issue to validate that the stated issue is truly an issue with high confidence. For example, if an issue such as \"variable is not defined\" was flagged, the subagent's job would be to validate that is actually true in the code. Another example would be CLAUDE.md issues. The agent should validate that the CLAUDE.md rule that was violated is scoped for this file and is actually violated. Use Opus subagents for bugs and logic issues, and sonnet agents for CLAUDE.md violations.\n\n6. Filter out any issues that were not validated in step 5. This step will give us our list of high signal issues for our review.\n\n7. Finally, comment on the pull request.\n   When writing your comment, follow these guidelines:\n   a. Keep your output brief\n   b. Avoid emojis\n   c. Link and cite relevant code, files, and URLs for each issue\n   d. When citing CLAUDE.md violations, you MUST quote the exact text from CLAUDE.md that is being violated (e.g., CLAUDE.md says: \"Use snake_case for variable names\")\n\nUse this list when evaluating issues in Steps 4 and 5 (these are false positives, do NOT flag):\n\n- Pre-existing issues\n- Something that appears to be a bug but is actually correct\n- Pedantic nitpicks that a senior engineer would not flag\n- Issues that a linter will catch (do not run the linter to verify)\n- General code quality concerns (e.g., lack of test coverage, general security issues) unless explicitly required in CLAUDE.md\n- Issues mentioned in CLAUDE.md but explicitly silenced in the code (e.g., via a lint ignore comment)\n\nNotes:\n\n- Use gh CLI to interact with GitHub (e.g., fetch pull requests, create comments). Do not use web fetch.\n- Create a todo list before starting.\n- You must cite and link each issue (e.g., if referring to a CLAUDE.md, include a link to it).\n- For your final comment, follow the following format precisely (assuming for this example that you found 3 issues):\n\n---\n\n## Code review\n\nFound 3 issues:\n\n1. <brief description of bug> (CLAUDE.md says: \"<exact quote from CLAUDE.md>\")\n\n<link to file and line with full sha1 + line range for context, eg. https://github.com/anthropics/claude-code/blob/1d54823877c4de72b2316a64032a54afc404e619/README.md#L13-L17>\n\n2. <brief description of bug> (some/other/CLAUDE.md says: \"<exact quote from CLAUDE.md>\")\n\n<link to file and line with full sha1 + line range for context>\n\n3. <brief description of bug> (bug due to <file and code snippet>)\n\n<link to file and line with full sha1 + line range for context>\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n\n<sub>- If this code review was useful, please react with ðŸ‘. Otherwise, react with ðŸ‘Ž.</sub>\n\n---\n\n- Or, if you found no issues:\n\n---\n\n## Auto code review\n\nNo issues found. Checked for bugs and CLAUDE.md compliance.\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\n---\n\n- When linking to code, follow the following format precisely, otherwise the Markdown preview won't render correctly: https://github.com/anthropics/claude-code/blob/c21d3c10bc8e898b7ac1a2d745bdc9bc4e423afe/package.json#L10-L15\n  - Requires full git sha\n  - You must provide the full sha. Commands like `https://github.com/owner/repo/blob/$(git rev-parse HEAD)/foo/bar` will not work, since your comment will be directly rendered in Markdown.\n  - Repo name must match the repo you're code reviewing\n  - # sign after the file name\n  - Line range format is L[start]-L[end]\n  - Provide at least 1 line of context before and after, centered on the line you are commenting about (eg. if you are commenting about lines 5-6, you should link to `L4-7`)\n"}
{"source":"github","repo":"claude-code","path":"plugins/frontend-design/skills/frontend-design/SKILL.md","content":"---\nname: frontend-design\ndescription: Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.\nlicense: Complete terms in LICENSE.txt\n---\n\nThis skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\nFocus on:\n- **Typography**: Choose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial and Inter; opt instead for distinctive choices that elevate the frontend's aesthetics; unexpected, characterful font choices. Pair a distinctive display font with a refined body font.\n- **Color & Theme**: Commit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes.\n- **Motion**: Use animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available. Focus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n- **Spatial Composition**: Unexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n- **Backgrounds & Visual Details**: Create atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic. Apply creative forms like gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, custom cursors, and grain overlays.\n\nNEVER use generic AI-generated aesthetics like overused font families (Inter, Roboto, Arial, system fonts), cliched color schemes (particularly purple gradients on white backgrounds), predictable layouts and component patterns, and cookie-cutter design that lacks context-specific character.\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics. NEVER converge on common choices (Space Grotesk, for example) across generations.\n\n**IMPORTANT**: Match implementation complexity to the aesthetic vision. Maximalist designs need elaborate code with extensive animations and effects. Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details. Elegance comes from executing the vision well.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back, show what can truly be created when thinking outside the box and committing fully to a distinctive vision."}
{"source":"github","repo":"claude-code","path":"plugins/frontend-design/README.md","content":"# Frontend Design Plugin\n\nGenerates distinctive, production-grade frontend interfaces that avoid generic AI aesthetics.\n\n## What It Does\n\nClaude automatically uses this skill for frontend work. Creates production-ready code with:\n\n- Bold aesthetic choices\n- Distinctive typography and color palettes\n- High-impact animations and visual details\n- Context-aware implementation\n\n## Usage\n\n```\n\"Create a dashboard for a music streaming app\"\n\"Build a landing page for an AI security startup\"\n\"Design a settings panel with dark mode\"\n```\n\nClaude will choose a clear aesthetic direction and implement production code with meticulous attention to detail.\n\n## Learn More\n\nSee the [Frontend Aesthetics Cookbook](https://github.com/anthropics/claude-cookbooks/blob/main/coding/prompting_for_frontend_aesthetics.ipynb) for detailed guidance on prompting for high-quality frontend design.\n\n## Authors\n\nPrithvi Rajasekaran (prithvi@anthropic.com)\nAlexander Bricken (alexander@anthropic.com)\n"}
{"source":"github","repo":"claude-code","path":"LICENSE.md","content":"Â© Anthropic PBC. All rights reserved. Use is subject to Anthropic's [Commercial Terms of Service](https://www.anthropic.com/legal/commercial-terms).\n"}
{"source":"github","repo":"claude-code","path":"README.md","content":"# Claude Code\n\n![](https://img.shields.io/badge/Node.js-18%2B-brightgreen?style=flat-square) [![npm]](https://www.npmjs.com/package/@anthropic-ai/claude-code)\n\n[npm]: https://img.shields.io/npm/v/@anthropic-ai/claude-code.svg?style=flat-square\n\nClaude Code is an agentic coding tool that lives in your terminal, understands your codebase, and helps you code faster by executing routine tasks, explaining complex code, and handling git workflows -- all through natural language commands. Use it in your terminal, IDE, or tag @claude on Github.\n\n**Learn more in the [official documentation](https://docs.anthropic.com/en/docs/claude-code/overview)**.\n\n<img src=\"./demo.gif\" />\n\n## Get started\n\n1. Install Claude Code:\n\n**MacOS/Linux:**\n```bash\ncurl -fsSL https://claude.ai/install.sh | bash\n```\n\n**Homebrew (MacOS):**\n```bash\nbrew install --cask claude-code\n```\n\n**Windows:**\n```powershell\nirm https://claude.ai/install.ps1 | iex\n```\n\n**NPM:**\n```bash\nnpm install -g @anthropic-ai/claude-code\n```\n\nNOTE: If installing with NPM, you also need to install [Node.js 18+](https://nodejs.org/en/download/)\n\n2. Navigate to your project directory and run `claude`.\n\n## Plugins\n\nThis repository includes several Claude Code plugins that extend functionality with custom commands and agents. See the [plugins directory](./plugins/README.md) for detailed documentation on available plugins.\n\n## Reporting Bugs\n\nWe welcome your feedback. Use the `/bug` command to report issues directly within Claude Code, or file a [GitHub issue](https://github.com/anthropics/claude-code/issues).\n\n## Connect on Discord\n\nJoin the [Claude Developers Discord](https://anthropic.com/discord) to connect with other developers using Claude Code. Get help, share feedback, and discuss your projects with the community.\n\n## Data collection, usage, and retention\n\nWhen you use Claude Code, we collect feedback, which includes usage data (such as code acceptance or rejections), associated conversation data, and user feedback submitted via the `/bug` command.\n\n### How we use your data\n\nSee our [data usage policies](https://docs.anthropic.com/en/docs/claude-code/data-usage).\n\n### Privacy safeguards\n\nWe have implemented several safeguards to protect your data, including limited retention periods for sensitive information, restricted access to user session data, and clear policies against using feedback for model training.\n\nFor full details, please review our [Commercial Terms of Service](https://www.anthropic.com/legal/commercial-terms) and [Privacy Policy](https://www.anthropic.com/legal/privacy).\n"}
