
{"source":"github","repo":"mcp-typescript-sdk","path":"CLAUDE.md","content":"# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Build & Test Commands\n\n```sh\nnpm run build        # Build ESM and CJS versions\nnpm run lint         # Run ESLint and Prettier check\nnpm run lint:fix     # Auto-fix lint and formatting issues\nnpm test             # Run all tests (vitest)\nnpm run test:watch   # Run tests in watch mode\nnpx vitest path/to/file.test.ts  # Run specific test file\nnpx vitest -t \"test name\"        # Run tests matching pattern\nnpm run typecheck    # Type-check without emitting\n```\n\n## Code Style Guidelines\n\n- **TypeScript**: Strict type checking, ES modules, explicit return types\n- **Naming**: PascalCase for classes/types, camelCase for functions/variables\n- **Files**: Lowercase with hyphens, test files with `.test.ts` suffix\n- **Imports**: ES module style, include `.js` extension, group imports logically\n- **Formatting**: 2-space indentation, semicolons required, single quotes preferred\n- **Testing**: Co-locate tests with source files, use descriptive test names\n- **Comments**: JSDoc for public APIs, inline comments for complex logic\n\n## Architecture Overview\n\n### Core Layers\n\nThe SDK is organized into three main layers:\n\n1. **Types Layer** (`src/types.ts`) - Protocol types generated from the MCP specification. All JSON-RPC message types, schemas, and protocol constants are defined here using Zod v4.\n\n2. **Protocol Layer** (`src/shared/protocol.ts`) - The abstract `Protocol` class that handles JSON-RPC message routing, request/response correlation, capability negotiation, and transport management. Both `Client` and `Server` extend this class.\n\n3. **High-Level APIs**:\n    - `Client` (`src/client/index.ts`) - Low-level client extending Protocol with typed methods for all MCP operations\n    - `Server` (`src/server/index.ts`) - Low-level server extending Protocol with request handler registration\n    - `McpServer` (`src/server/mcp.ts`) - High-level server API with simplified resource/tool/prompt registration\n\n### Transport System\n\nTransports (`src/shared/transport.ts`) provide the communication layer:\n\n- **Streamable HTTP** (`src/server/streamableHttp.ts`, `src/client/streamableHttp.ts`) - Recommended transport for remote servers, supports SSE for streaming\n- **SSE** (`src/server/sse.ts`, `src/client/sse.ts`) - Legacy HTTP+SSE transport for backwards compatibility\n- **stdio** (`src/server/stdio.ts`, `src/client/stdio.ts`) - For local process-spawned integrations\n\n### Server-Side Features\n\n- **Tools/Resources/Prompts**: Registered via `McpServer.tool()`, `.resource()`, `.prompt()` methods\n- **OAuth/Auth**: Full OAuth 2.0 server implementation in `src/server/auth/`\n- **Completions**: Auto-completion support via `src/server/completable.ts`\n\n### Client-Side Features\n\n- **Auth**: OAuth client support in `src/client/auth.ts` and `src/client/auth-extensions.ts`\n- **Middleware**: Request middleware in `src/client/middleware.ts`\n- **Sampling**: Clients can handle `sampling/createMessage` requests from servers (LLM completions)\n- **Elicitation**: Clients can handle `elicitation/create` requests for user input (form or URL mode)\n- **Roots**: Clients can expose filesystem roots to servers via `roots/list`\n\n### Experimental Features\n\nLocated in `src/experimental/`:\n\n- **Tasks**: Long-running task support with polling/resumption (`src/experimental/tasks/`)\n\n### Zod Compatibility\n\nThe SDK uses `zod/v4` internally but supports both v3 and v4 APIs. Compatibility utilities:\n\n- `src/server/zod-compat.ts` - Schema parsing helpers that work across versions\n- `src/server/zod-json-schema-compat.ts` - Converts Zod schemas to JSON Schema\n\n### Validation\n\nPluggable JSON Schema validation (`src/validation/`):\n\n- `ajv-provider.ts` - Default Ajv-based validator\n- `cfworker-provider.ts` - Cloudflare Workers-compatible alternative\n\n### Examples\n\nRunnable examples in `src/examples/`:\n\n- `server/` - Various server configurations (stateful, stateless, OAuth, etc.)\n- `client/` - Client examples (basic, OAuth, parallel calls, etc.)\n- `shared/` - Shared utilities like in-memory event store\n\n## Message Flow (Bidirectional Protocol)\n\nMCP is bidirectional: both client and server can send requests. Understanding this flow is essential when implementing new request types.\n\n### Class Hierarchy\n\n```\nProtocol (abstract base)\n├── Client (src/client/index.ts)     - can send requests TO server, handle requests FROM server\n└── Server (src/server/index.ts)     - can send requests TO client, handle requests FROM client\n    └── McpServer (src/server/mcp.ts) - high-level wrapper around Server\n```\n\n### Outbound Flow: Sending Requests\n\nWhen code calls `client.callTool()` or `server.createMessage()`:\n\n1. **High-level method** (e.g., `Client.callTool()`) calls `this.request()`\n2. **`Protocol.request()`**:\n    - Assigns unique message ID\n    - Checks capabilities via `assertCapabilityForMethod()` (abstract, implemented by Client/Server)\n    - Creates response handler promise\n    - Calls `transport.send()` with JSON-RPC request\n    - Waits for response handler to resolve\n3. **Transport** serializes and sends over wire (HTTP, stdio, etc.)\n4. **`Protocol._onresponse()`** resolves the promise when response arrives\n\n### Inbound Flow: Handling Requests\n\nWhen a request arrives from the remote side:\n\n1. **Transport** receives message, calls `transport.onmessage()`\n2. **`Protocol.connect()`** routes to `_onrequest()`, `_onresponse()`, or `_onnotification()`\n3. **`Protocol._onrequest()`**:\n    - Looks up handler in `_requestHandlers` map (keyed by method name)\n    - Creates `RequestHandlerExtra` with `signal`, `sessionId`, `sendNotification`, `sendRequest`\n    - Invokes handler, sends JSON-RPC response back via transport\n4. **Handler** was registered via `setRequestHandler(Schema, handler)`\n\n### Handler Registration\n\n```typescript\n// In Client (for server→client requests like sampling, elicitation)\nclient.setRequestHandler(CreateMessageRequestSchema, async (request, extra) => {\n  // Handle sampling request from server\n  return { role: \"assistant\", content: {...}, model: \"...\" };\n});\n\n// In Server (for client→server requests like tools/call)\nserver.setRequestHandler(CallToolRequestSchema, async (request, extra) => {\n  // Handle tool call from client\n  return { content: [...] };\n});\n```\n\n### Request Handler Extra\n\nThe `extra` parameter in handlers (`RequestHandlerExtra`) provides:\n\n- `signal`: AbortSignal for cancellation\n- `sessionId`: Transport session identifier\n- `authInfo`: Validated auth token info (if authenticated)\n- `requestId`: JSON-RPC message ID\n- `sendNotification(notification)`: Send related notification back\n- `sendRequest(request, schema)`: Send related request (for bidirectional flows)\n- `taskStore`: Task storage interface (if tasks enabled)\n\n### Capability Checking\n\nBoth sides declare capabilities during initialization. The SDK enforces these:\n\n- **Client→Server**: `Client.assertCapabilityForMethod()` checks `_serverCapabilities`\n- **Server→Client**: `Server.assertCapabilityForMethod()` checks `_clientCapabilities`\n- **Handler registration**: `assertRequestHandlerCapability()` validates local capabilities\n\n### Adding a New Request Type\n\n1. **Define schema** in `src/types.ts` (request params, result schema)\n2. **Add capability** to `ClientCapabilities` or `ServerCapabilities` in types\n3. **Implement sender** method in Client or Server class\n4. **Add capability check** in the appropriate `assertCapabilityForMethod()`\n5. **Register handler** on the receiving side with `setRequestHandler()`\n6. **For McpServer**: Add high-level wrapper method if needed\n\n### Server-Initiated Requests (Sampling, Elicitation)\n\nServer can request actions from client (requires client capability):\n\n```typescript\n// Server sends sampling request to client\nconst result = await server.createMessage({\n  messages: [...],\n  maxTokens: 100\n});\n\n// Client must have registered handler:\nclient.setRequestHandler(CreateMessageRequestSchema, async (request, extra) => {\n  // Client-side LLM call\n  return { role: \"assistant\", content: {...} };\n});\n```\n\n## Key Patterns\n\n### Request Handler Registration (Low-Level Server)\n\n```typescript\nserver.setRequestHandler(SomeRequestSchema, async (request, extra) => {\n    // extra contains sessionId, authInfo, sendNotification, etc.\n    return {\n        /* result */\n    };\n});\n```\n\n### Tool Registration (High-Level McpServer)\n\n```typescript\nmcpServer.tool('tool-name', { param: z.string() }, async ({ param }, extra) => {\n    return { content: [{ type: 'text', text: 'result' }] };\n});\n```\n\n### Transport Connection\n\n```typescript\n// Server\nconst transport = new StreamableHTTPServerTransport({ sessionIdGenerator: () => randomUUID() });\nawait server.connect(transport);\n\n// Client\nconst transport = new StreamableHTTPClientTransport(new URL('http://localhost:3000/mcp'));\nawait client.connect(transport);\n```\n"}
{"source":"github","repo":"mcp-typescript-sdk","path":"src/examples/server/README-simpleTaskInteractive.md","content":"# Simple Task Interactive Example\n\nThis example demonstrates the MCP Tasks message queue pattern with interactive server-to-client requests (elicitation and sampling).\n\n## Overview\n\nThe example consists of two components:\n\n1. **Server** (`simpleTaskInteractive.ts`) - Exposes two task-based tools that require client interaction:\n    - `confirm_delete` - Uses elicitation to ask the user for confirmation before \"deleting\" a file\n    - `write_haiku` - Uses sampling to request an LLM to generate a haiku on a topic\n\n2. **Client** (`simpleTaskInteractiveClient.ts`) - Connects to the server and handles:\n    - Elicitation requests with simple y/n terminal prompts\n    - Sampling requests with a mock haiku generator\n\n## Key Concepts\n\n### Task-Based Execution\n\nBoth tools use `execution.taskSupport: 'required'`, meaning they follow the \"call-now, fetch-later\" pattern:\n\n1. Client calls tool with `task: { ttl: 60000 }` parameter\n2. Server creates a task and returns `CreateTaskResult` immediately\n3. Client polls via `tasks/result` to get the final result\n4. Server sends elicitation/sampling requests through the task message queue\n5. Client handles requests and returns responses\n6. Server completes the task with the final result\n\n### Message Queue Pattern\n\nWhen a tool needs to interact with the client (elicitation or sampling), it:\n\n1. Updates task status to `input_required`\n2. Enqueues the request in the task message queue\n3. Waits for the response via a Resolver\n4. Updates task status back to `working`\n5. Continues processing\n\nThe `TaskResultHandler` dequeues messages when the client calls `tasks/result` and routes responses back to waiting Resolvers.\n\n## Running the Example\n\n### Start the Server\n\n```bash\n# From the SDK root directory\nnpx tsx src/examples/server/simpleTaskInteractive.ts\n\n# Or with a custom port\nPORT=9000 npx tsx src/examples/server/simpleTaskInteractive.ts\n```\n\nThe server will start on http://localhost:8000/mcp (or your custom port).\n\n### Run the Client\n\n```bash\n# From the SDK root directory\nnpx tsx src/examples/client/simpleTaskInteractiveClient.ts\n\n# Or connect to a different server\nnpx tsx src/examples/client/simpleTaskInteractiveClient.ts --url http://localhost:9000/mcp\n```\n\n## Expected Output\n\n### Server Output\n\n```\nStarting server on http://localhost:8000/mcp\n\nAvailable tools:\n  - confirm_delete: Demonstrates elicitation (asks user y/n)\n  - write_haiku: Demonstrates sampling (requests LLM completion)\n\n[Server] confirm_delete called, task created: task-abc123\n[Server] confirm_delete: asking about 'important.txt'\n[Server] Sending elicitation request to client...\n[Server] tasks/result called for task task-abc123\n[Server] Delivering queued request message for task task-abc123\n[Server] Received elicitation response: action=accept, content={\"confirm\":true}\n[Server] Completing task with result: Deleted 'important.txt'\n\n[Server] write_haiku called, task created: task-def456\n[Server] write_haiku: topic 'autumn leaves'\n[Server] Sending sampling request to client...\n[Server] tasks/result called for task task-def456\n[Server] Delivering queued request message for task task-def456\n[Server] Received sampling response: Cherry blossoms fall...\n[Server] Completing task with haiku\n```\n\n### Client Output\n\n```\nSimple Task Interactive Client\n==============================\nConnecting to http://localhost:8000/mcp...\nConnected!\n\nAvailable tools: confirm_delete, write_haiku\n\n--- Demo 1: Elicitation ---\nCalling confirm_delete tool...\nTask created: task-abc123\nTask status: working\n\n[Elicitation] Server asks: Are you sure you want to delete 'important.txt'?\nYour response (y/n): y\n[Elicitation] Responding with: confirm=true\nTask status: input_required\nTask status: completed\nResult: Deleted 'important.txt'\n\n--- Demo 2: Sampling ---\nCalling write_haiku tool...\nTask created: task-def456\nTask status: working\n\n[Sampling] Server requests LLM completion for: Write a haiku about autumn leaves\n[Sampling] Responding with haiku\nTask status: input_required\nTask status: completed\nResult:\nHaiku:\nCherry blossoms fall\nSoftly on the quiet pond\nSpring whispers goodbye\n\nDemo complete. Closing connection...\n```\n\n## Implementation Details\n\n### Server Components\n\n- **Resolver**: Promise-like class for passing results between async operations\n- **TaskMessageQueueWithResolvers**: Extended message queue that tracks pending requests with their Resolvers\n- **TaskStoreWithNotifications**: Extended task store with notification support for status changes\n- **TaskResultHandler**: Handles `tasks/result` requests by dequeuing messages and routing responses\n- **TaskSession**: Wraps the server to enqueue requests during task execution\n\n### Client Capabilities\n\nThe client declares these capabilities during initialization:\n\n```typescript\ncapabilities: {\n    elicitation: { form: {} },\n    sampling: {}\n}\n```\n\nThis tells the server that the client can handle both form-based elicitation and sampling requests.\n\n## Related Files\n\n- `src/shared/task.ts` - Core task interfaces (TaskStore, TaskMessageQueue)\n- `src/examples/shared/inMemoryTaskStore.ts` - In-memory implementations\n- `src/types.ts` - Task-related types (Task, CreateTaskResult, GetTaskRequestSchema, etc.)\n"}
{"source":"github","repo":"mcp-typescript-sdk","path":"src/examples/README.md","content":"# MCP TypeScript SDK Examples\n\nThis directory contains example implementations of MCP clients and servers using the TypeScript SDK. For a high-level index of scenarios and where they live, see the **Examples** table in the root `README.md`.\n\n## Table of Contents\n\n- [Client Implementations](#client-implementations)\n    - [Streamable HTTP Client](#streamable-http-client)\n    - [Backwards Compatible Client](#backwards-compatible-client)\n    - [URL Elicitation Example Client](#url-elicitation-example-client)\n- [Server Implementations](#server-implementations)\n    - [Single Node Deployment](#single-node-deployment)\n        - [Streamable HTTP Transport](#streamable-http-transport)\n        - [Deprecated SSE Transport](#deprecated-sse-transport)\n        - [Backwards Compatible Server](#streamable-http-backwards-compatible-server-with-sse)\n        - [Form Elicitation Example](#form-elicitation-example)\n        - [URL Elicitation Example](#url-elicitation-example)\n    - [Multi-Node Deployment](#multi-node-deployment)\n- [Backwards Compatibility](#testing-streamable-http-backwards-compatibility-with-sse)\n\n## Client Implementations\n\n### Streamable HTTP Client\n\nA full-featured interactive client that connects to a Streamable HTTP server, demonstrating how to:\n\n- Establish and manage a connection to an MCP server\n- List and call tools with arguments\n- Handle notifications through the SSE stream\n- List and get prompts with arguments\n- List available resources\n- Handle session termination and reconnection\n- Support for resumability with Last-Event-ID tracking\n\n```bash\nnpx tsx src/examples/client/simpleStreamableHttp.ts\n```\n\nExample client with OAuth:\n\n```bash\nnpx tsx src/examples/client/simpleOAuthClient.ts <optional-server-url> <optional-client-metadata-url>\n```\n\nClient credentials (machine-to-machine) example:\n\n```bash\nnpx tsx src/examples/client/simpleClientCredentials.ts\n```\n\n### Backwards Compatible Client\n\nA client that implements backwards compatibility according to the [MCP specification](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#backwards-compatibility), allowing it to work with both new and legacy servers. This client demonstrates:\n\n- The client first POSTs an initialize request to the server URL:\n    - If successful, it uses the Streamable HTTP transport\n    - If it fails with a 4xx status, it attempts a GET request to establish an SSE stream\n\n```bash\nnpx tsx src/examples/client/streamableHttpWithSseFallbackClient.ts\n```\n\n### URL Elicitation Example Client\n\nA client that demonstrates how to use URL elicitation to securely collect _sensitive_ user input or perform secure third-party flows.\n\n```bash\n# First, run the server:\nnpx tsx src/examples/server/elicitationUrlExample.ts\n\n# Then, run the client:\nnpx tsx src/examples/client/elicitationUrlExample.ts\n\n```\n\n## Server Implementations\n\n### Single Node Deployment\n\nThese examples demonstrate how to set up an MCP server on a single node with different transport options.\n\n#### Streamable HTTP Transport\n\n##### Simple Streamable HTTP Server\n\nA server that implements the Streamable HTTP transport (protocol version 2025-03-26).\n\n- Basic server setup with Express and the Streamable HTTP transport\n- Session management with an in-memory event store for resumability\n- Tool implementation with the `greet` and `multi-greet` tools\n- Prompt implementation with the `greeting-template` prompt\n- Static resource exposure\n- Support for notifications via SSE stream established by GET requests\n- Session termination via DELETE requests\n\n```bash\nnpx tsx src/examples/server/simpleStreamableHttp.ts\n\n# To add a demo of authentication to this example, use:\nnpx tsx src/examples/server/simpleStreamableHttp.ts --oauth\n\n# To mitigate impersonation risks, enable strict Resource Identifier verification:\nnpx tsx src/examples/server/simpleStreamableHttp.ts --oauth --oauth-strict\n```\n\n##### JSON Response Mode Server\n\nA server that uses Streamable HTTP transport with JSON response mode enabled (no SSE).\n\n- Streamable HTTP with JSON response mode, which returns responses directly in the response body\n- Limited support for notifications (since SSE is disabled)\n- Proper response handling according to the MCP specification for servers that don't support SSE\n- Returning appropriate HTTP status codes for unsupported methods\n\n```bash\nnpx tsx src/examples/server/jsonResponseStreamableHttp.ts\n```\n\n##### Streamable HTTP with server notifications\n\nA server that demonstrates server notifications using Streamable HTTP.\n\n- Resource list change notifications with dynamically added resources\n- Automatic resource creation on a timed interval\n\n```bash\nnpx tsx src/examples/server/standaloneSseWithGetStreamableHttp.ts\n```\n\n##### Form Elicitation Example\n\nA server that demonstrates using form elicitation to collect _non-sensitive_ user input.\n\n```bash\nnpx tsx src/examples/server/elicitationFormExample.ts\n```\n\n##### URL Elicitation Example\n\nA comprehensive example demonstrating URL mode elicitation in a server protected by MCP authorization. This example shows:\n\n- SSE-driven URL elicitation of an API Key on session initialization: obtain sensitive user input at session init\n- Tools that require direct user interaction via URL elicitation (for payment confirmation and for third-party OAuth tokens)\n- Completion notifications for URL elicitation\n\nTo run this example:\n\n```bash\n# Start the server\nnpx tsx src/examples/server/elicitationUrlExample.ts\n\n# In a separate terminal, start the client\nnpx tsx src/examples/client/elicitationUrlExample.ts\n```\n\n#### Deprecated SSE Transport\n\nA server that implements the deprecated HTTP+SSE transport (protocol version 2024-11-05). This example is only used for testing backwards compatibility for clients.\n\n- Two separate endpoints: `/mcp` for the SSE stream (GET) and `/messages` for client messages (POST)\n- Tool implementation with a `start-notification-stream` tool that demonstrates sending periodic notifications\n\n```bash\nnpx tsx src/examples/server/simpleSseServer.ts\n```\n\n#### Streamable Http Backwards Compatible Server with SSE\n\nA server that supports both Streamable HTTP and SSE transports, adhering to the [MCP specification for backwards compatibility](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#backwards-compatibility).\n\n- Single MCP server instance with multiple transport options\n- Support for Streamable HTTP requests at `/mcp` endpoint (GET/POST/DELETE)\n- Support for deprecated SSE transport with `/sse` (GET) and `/messages` (POST)\n- Session type tracking to avoid mixing transport types\n- Notifications and tool execution across both transport types\n\n```bash\nnpx tsx src/examples/server/sseAndStreamableHttpCompatibleServer.ts\n```\n\n### Multi-Node Deployment\n\nWhen deploying MCP servers in a horizontally scaled environment (multiple server instances), there are a few different options that can be useful for different use cases:\n\n- **Stateless mode** - No need to maintain state between calls to MCP servers. Useful for simple API wrapper servers.\n- **Persistent storage mode** - No local state needed, but session data is stored in a database. Example: an MCP server for online ordering where the shopping cart is stored in a database.\n- **Local state with message routing** - Local state is needed, and all requests for a session must be routed to the correct node. This can be done with a message queue and pub/sub system.\n\n#### Stateless Mode\n\nThe Streamable HTTP transport can be configured to operate without tracking sessions. This is perfect for simple API proxies or when each request is completely independent.\n\n##### Implementation\n\nTo enable stateless mode, configure the `StreamableHTTPServerTransport` with:\n\n```typescript\nsessionIdGenerator: undefined;\n```\n\nThis disables session management entirely, and the server won't generate or expect session IDs.\n\n- No session ID headers are sent or expected\n- Any server node can process any request\n- No state is preserved between requests\n- Perfect for RESTful or stateless API scenarios\n- Simplest deployment model with minimal infrastructure requirements\n\n```\n┌─────────────────────────────────────────────┐\n│                  Client                     │\n└─────────────────────────────────────────────┘\n                     │\n                     ▼\n┌─────────────────────────────────────────────┐\n│                Load Balancer                │\n└─────────────────────────────────────────────┘\n          │                       │\n          ▼                       ▼\n┌─────────────────┐     ┌─────────────────────┐\n│  MCP Server #1  │     │    MCP Server #2    │\n│ (Node.js)       │     │  (Node.js)          │\n└─────────────────┘     └─────────────────────┘\n```\n\n#### Persistent Storage Mode\n\nFor cases where you need session continuity but don't need to maintain in-memory state on specific nodes, you can use a database to persist session data while still allowing any node to handle requests.\n\n##### Implementation\n\nConfigure the transport with session management, but retrieve and store all state in an external persistent storage:\n\n```typescript\nsessionIdGenerator: () => randomUUID(),\neventStore: databaseEventStore\n```\n\nAll session state is stored in the database, and any node can serve any client by retrieving the state when needed.\n\n- Maintains sessions with unique IDs\n- Stores all session data in an external database\n- Provides resumability through the database-backed EventStore\n- Any node can handle any request for the same session\n- No node-specific memory state means no need for message routing\n- Good for applications where state can be fully externalized\n- Somewhat higher latency due to database access for each request\n\n```\n┌─────────────────────────────────────────────┐\n│                  Client                     │\n└─────────────────────────────────────────────┘\n                     │\n                     ▼\n┌─────────────────────────────────────────────┐\n│                Load Balancer                │\n└─────────────────────────────────────────────┘\n          │                       │\n          ▼                       ▼\n┌─────────────────┐     ┌─────────────────────┐\n│  MCP Server #1  │     │    MCP Server #2    │\n│ (Node.js)       │     │  (Node.js)          │\n└─────────────────┘     └─────────────────────┘\n          │                       │\n          │                       │\n          ▼                       ▼\n┌─────────────────────────────────────────────┐\n│           Database (PostgreSQL)             │\n│                                             │\n│  • Session state                            │\n│  • Event storage for resumability           │\n└─────────────────────────────────────────────┘\n```\n\n#### Streamable HTTP with Distributed Message Routing\n\nFor scenarios where local in-memory state must be maintained on specific nodes (such as Computer Use or complex session state), the Streamable HTTP transport can be combined with a pub/sub system to route messages to the correct node handling each session.\n\n1. **Bidirectional Message Queue Integration**:\n    - All nodes both publish to and subscribe from the message queue\n    - Each node registers the sessions it's actively handling\n    - Messages are routed based on session ownership\n\n2. **Request Handling Flow**:\n    - When a client connects to Node A with an existing `mcp-session-id`\n    - If Node A doesn't own this session, it:\n        - Establishes and maintains the SSE connection with the client\n        - Publishes the request to the message queue with the session ID\n        - Node B (which owns the session) receives the request from the queue\n        - Node B processes the request with its local session state\n        - Node B publishes responses/notifications back to the queue\n        - Node A subscribes to the response channel and forwards to the client\n\n3. **Channel Identification**:\n    - Each message channel combines both `mcp-session-id` and `stream-id`\n    - This ensures responses are correctly routed back to the originating connection\n\n```\n┌─────────────────────────────────────────────┐\n│                  Client                     │\n└─────────────────────────────────────────────┘\n                     │\n                     ▼\n┌─────────────────────────────────────────────┐\n│                Load Balancer                │\n└─────────────────────────────────────────────┘\n          │                       │\n          ▼                       ▼\n┌─────────────────┐     ┌─────────────────────┐\n│  MCP Server #1  │◄───►│    MCP Server #2    │\n│ (Has Session A) │     │  (Has Session B)    │\n└─────────────────┘     └─────────────────────┘\n          ▲│                     ▲│\n          │▼                     │▼\n┌─────────────────────────────────────────────┐\n│         Message Queue / Pub-Sub             │\n│                                             │\n│  • Session ownership registry               │\n│  • Bidirectional message routing            │\n│  • Request/response forwarding              │\n└─────────────────────────────────────────────┘\n```\n\n- Maintains session affinity for stateful operations without client redirection\n- Enables horizontal scaling while preserving complex in-memory state\n- Provides fault tolerance through the message queue as intermediary\n\n## Backwards Compatibility\n\n### Testing Streamable HTTP Backwards Compatibility with SSE\n\nTo test the backwards compatibility features:\n\n1. Start one of the server implementations:\n\n    ```bash\n    # Legacy SSE server (protocol version 2024-11-05)\n    npx tsx src/examples/server/simpleSseServer.ts\n\n    # Streamable HTTP server (protocol version 2025-03-26)\n    npx tsx src/examples/server/simpleStreamableHttp.ts\n\n    # Backwards compatible server (supports both protocols)\n    npx tsx src/examples/server/sseAndStreamableHttpCompatibleServer.ts\n    ```\n\n2. Then run the backwards compatible client:\n    ```bash\n    npx tsx src/examples/client/streamableHttpWithSseFallbackClient.ts\n    ```\n\nThis demonstrates how the MCP ecosystem ensures interoperability between clients and servers regardless of which protocol version they were built for.\n"}
{"source":"github","repo":"mcp-typescript-sdk","path":"SECURITY.md","content":"# Security Policy\n\nThank you for helping us keep the SDKs and systems they interact with secure.\n\n## Reporting Security Issues\n\nThis SDK is maintained by [Anthropic](https://www.anthropic.com/) as part of the Model Context Protocol project.\n\nThe security of our systems and user data is Anthropic’s top priority. We appreciate the work of security researchers acting in good faith in identifying and reporting potential vulnerabilities.\n\nOur security program is managed on HackerOne and we ask that any validated vulnerability in this functionality be reported through their [submission form](https://hackerone.com/anthropic-vdp/reports/new?type=team&report_type=vulnerability).\n\n## Vulnerability Disclosure Program\n\nOur Vulnerability Program Guidelines are defined on our [HackerOne program page](https://hackerone.com/anthropic-vdp).\n"}
{"source":"github","repo":"mcp-typescript-sdk","path":"CODE_OF_CONDUCT.md","content":"# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience,\neducation, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our community include:\n\n- Demonstrating empathy and kindness toward other people\n- Being respectful of differing opinions, viewpoints, and experiences\n- Giving and gracefully accepting constructive feedback\n- Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\n- Focusing on what is best not just for us as individuals, but for the overall community\n\nExamples of unacceptable behavior include:\n\n- The use of sexualized language or imagery, and sexual attention or advances of any kind\n- Trolling, insulting or derogatory comments, and personal or political attacks\n- Public or private harassment\n- Publishing others' private information, such as a physical or email address, without their explicit permission\n- Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account,\nor acting as an appointed representative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at <mcp-coc@anthropic.com>. All complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the reporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series of actions.\n\n**Consequence**: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as\nwell as external channels like social media. Violating these terms may lead to a temporary or permanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including sustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is\nallowed during this period. Violating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within the community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at <https://www.contributor-covenant.org/version/2/0/code_of_conduct.html>.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct enforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at <https://www.contributor-covenant.org/faq>. Translations are available at <https://www.contributor-covenant.org/translations>.\n"}
{"source":"github","repo":"mcp-typescript-sdk","path":"CONTRIBUTING.md","content":"# Contributing to MCP TypeScript SDK\n\nWe welcome contributions to the Model Context Protocol TypeScript SDK! This document outlines the process for contributing to the project.\n\n## Getting Started\n\n1. Fork the repository\n2. Clone your fork: `git clone https://github.com/YOUR-USERNAME/typescript-sdk.git`\n3. Install dependencies: `npm install`\n4. Build the project: `npm run build`\n5. Run tests: `npm test`\n\n## Development Process\n\n1. Create a new branch for your changes\n2. Make your changes\n3. Run `npm run lint` to ensure code style compliance\n4. Run `npm test` to verify all tests pass\n5. Submit a pull request\n\n## Pull Request Guidelines\n\n- Follow the existing code style\n- Include tests for new functionality\n- Update documentation as needed\n- Keep changes focused and atomic\n- Provide a clear description of changes\n\n## Running Examples\n\n- Start the server: `npm run server`\n- Run the client: `npm run client`\n\n## Code of Conduct\n\nThis project follows our [Code of Conduct](CODE_OF_CONDUCT.md). Please review it before contributing.\n\n## Reporting Issues\n\n- Use the [GitHub issue tracker](https://github.com/modelcontextprotocol/typescript-sdk/issues)\n- Search existing issues before creating a new one\n- Provide clear reproduction steps\n\n## Security Issues\n\nPlease review our [Security Policy](SECURITY.md) for reporting security vulnerabilities.\n\n## License\n\nBy contributing, you agree that your contributions will be licensed under the MIT License.\n"}
{"source":"github","repo":"mcp-typescript-sdk","path":"README.md","content":"# MCP TypeScript SDK ![NPM Version](https://img.shields.io/npm/v/%40modelcontextprotocol%2Fsdk) ![MIT licensed](https://img.shields.io/npm/l/%40modelcontextprotocol%2Fsdk)\n\n<details>\n<summary>Table of Contents</summary>\n\n- [Overview](#overview)\n- [Installation](#installation)\n- [Quick Start](#quick-start)\n- [Core Concepts](#core-concepts)\n- [Examples](#examples)\n- [Documentation](#documentation)\n- [Contributing](#contributing)\n- [License](#license)\n\n</details>\n\n## Overview\n\nThe Model Context Protocol allows applications to provide context for LLMs in a standardized way, separating the concerns of providing context from the actual LLM interaction. This TypeScript SDK implements\n[the full MCP specification](https://modelcontextprotocol.io/specification/draft), making it easy to:\n\n- Create MCP servers that expose resources, prompts and tools\n- Build MCP clients that can connect to any MCP server\n- Use standard transports like stdio and Streamable HTTP\n\n## Installation\n\n```bash\nnpm install @modelcontextprotocol/sdk zod\n```\n\nThis SDK has a **required peer dependency** on `zod` for schema validation. The SDK internally imports from `zod/v4`, but maintains backwards compatibility with projects using Zod v3.25 or later. You can use either API in your code by importing from `zod/v3` or `zod/v4`:\n\n## Quick Start\n\nTo see the SDK in action end-to-end, start from the runnable examples in `src/examples`:\n\n1. **Install dependencies** (from the SDK repo root):\n\n    ```bash\n    npm install\n    ```\n\n2. **Run the example Streamable HTTP server**:\n\n    ```bash\n    npx tsx src/examples/server/simpleStreamableHttp.ts\n    ```\n\n3. **Run the interactive client in another terminal**:\n\n    ```bash\n    npx tsx src/examples/client/simpleStreamableHttp.ts\n    ```\n\nThis pair of examples demonstrates tools, resources, prompts, sampling, elicitation, tasks and logging. For a guided walkthrough and variations (stateless servers, JSON-only responses, SSE compatibility, OAuth, etc.), see [docs/server.md](docs/server.md) and\n[docs/client.md](docs/client.md).\n\n## Core Concepts\n\n### Servers and transports\n\nAn MCP server is typically created with `McpServer` and connected to a transport such as Streamable HTTP or stdio. The SDK supports:\n\n- **Streamable HTTP** for remote servers (recommended).\n- **HTTP + SSE** for backwards compatibility only.\n- **stdio** for local, process-spawned integrations.\n\nRunnable server examples live under `src/examples/server` and are documented in [docs/server.md](docs/server.md).\n\n### Tools, resources, prompts\n\n- **Tools** let LLMs ask your server to take actions (computation, side effects, network calls).\n- **Resources** expose read-only data that clients can surface to users or models.\n- **Prompts** are reusable templates that help users talk to models in a consistent way.\n\nThe detailed APIs, including `ResourceTemplate`, completions, and display-name metadata, are covered in [docs/server.md](docs/server.md#tools-resources-and-prompts), with runnable implementations in [`simpleStreamableHttp.ts`](src/examples/server/simpleStreamableHttp.ts).\n\n### Capabilities: sampling, elicitation, and tasks\n\nThe SDK includes higher-level capabilities for richer workflows:\n\n- **Sampling**: server-side tools can ask connected clients to run LLM completions.\n- **Form elicitation**: tools can request non-sensitive input via structured forms.\n- **URL elicitation**: servers can ask users to complete secure flows in a browser (e.g., API key entry, payments, OAuth).\n- **Tasks (experimental)**: long-running tool calls can be turned into tasks that you poll or resume later.\n\nConceptual overviews and links to runnable examples are in:\n\n- [docs/capabilities.md](docs/capabilities.md)\n\nKey example servers include:\n\n- [`toolWithSampleServer.ts`](src/examples/server/toolWithSampleServer.ts)\n- [`elicitationFormExample.ts`](src/examples/server/elicitationFormExample.ts)\n- [`elicitationUrlExample.ts`](src/examples/server/elicitationUrlExample.ts)\n\n### Clients\n\nThe high-level `Client` class connects to MCP servers over different transports and exposes helpers like `listTools`, `callTool`, `listResources`, `readResource`, `listPrompts`, and `getPrompt`.\n\nRunnable clients live under `src/examples/client` and are described in [docs/client.md](docs/client.md), including:\n\n- Interactive Streamable HTTP client ([`simpleStreamableHttp.ts`](src/examples/client/simpleStreamableHttp.ts))\n- Streamable HTTP client with SSE fallback ([`streamableHttpWithSseFallbackClient.ts`](src/examples/client/streamableHttpWithSseFallbackClient.ts))\n- OAuth-enabled clients and polling/parallel examples\n\n### Node.js Web Crypto (globalThis.crypto) compatibility\n\nSome parts of the SDK (for example, JWT-based client authentication in `auth-extensions.ts` via `jose`) rely on the Web Crypto API exposed as `globalThis.crypto`.\n\nSee [docs/faq.md](docs/faq.md) for details on supported Node.js versions and how to polyfill `globalThis.crypto` when running on older Node.js runtimes.\n\n## Examples\n\nThe SDK ships runnable examples under `src/examples`. Use these tables to find the scenario you care about and jump straight to the corresponding code and docs.\n\n### Server examples\n\n| Scenario                                            | Description                                                                                       | Example file(s)                                                                                          | Related docs                                                             |\n| --------------------------------------------------- | ------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |\n| Streamable HTTP server (stateful)                   | Feature-rich server with tools, resources, prompts, logging, tasks, sampling, and optional OAuth. | [`simpleStreamableHttp.ts`](src/examples/server/simpleStreamableHttp.ts)                                 | [`server.md`](docs/server.md), [`capabilities.md`](docs/capabilities.md) |\n| Streamable HTTP server (stateless)                  | No session tracking; good for simple API-style servers.                                           | [`simpleStatelessStreamableHttp.ts`](src/examples/server/simpleStatelessStreamableHttp.ts)               | [`server.md`](docs/server.md)                                            |\n| JSON response mode (no SSE)                         | Streamable HTTP with JSON responses only and limited notifications.                               | [`jsonResponseStreamableHttp.ts`](src/examples/server/jsonResponseStreamableHttp.ts)                     | [`server.md`](docs/server.md)                                            |\n| Server notifications over Streamable HTTP           | Demonstrates server-initiated notifications using SSE with Streamable HTTP.                       | [`standaloneSseWithGetStreamableHttp.ts`](src/examples/server/standaloneSseWithGetStreamableHttp.ts)     | [`server.md`](docs/server.md)                                            |\n| Deprecated HTTP+SSE server                          | Legacy HTTP+SSE transport for backwards-compatibility testing.                                    | [`simpleSseServer.ts`](src/examples/server/simpleSseServer.ts)                                           | [`server.md`](docs/server.md)                                            |\n| Backwards-compatible server (Streamable HTTP + SSE) | Single server that supports both Streamable HTTP and legacy SSE clients.                          | [`sseAndStreamableHttpCompatibleServer.ts`](src/examples/server/sseAndStreamableHttpCompatibleServer.ts) | [`server.md`](docs/server.md)                                            |\n| Form elicitation server                             | Uses form elicitation to collect non-sensitive user input.                                        | [`elicitationFormExample.ts`](src/examples/server/elicitationFormExample.ts)                             | [`capabilities.md`](docs/capabilities.md#elicitation)                    |\n| URL elicitation server                              | Demonstrates URL-mode elicitation in an OAuth-protected server.                                   | [`elicitationUrlExample.ts`](src/examples/server/elicitationUrlExample.ts)                               | [`capabilities.md`](docs/capabilities.md#elicitation)                    |\n| Sampling and tasks server                           | Combines tools, logging, sampling, and experimental task-based execution.                         | [`toolWithSampleServer.ts`](src/examples/server/toolWithSampleServer.ts)                                 | [`capabilities.md`](docs/capabilities.md)                                |\n| OAuth demo authorization server                     | In-memory OAuth provider used with the example servers.                                           | [`demoInMemoryOAuthProvider.ts`](src/examples/server/demoInMemoryOAuthProvider.ts)                       | [`server.md`](docs/server.md)                                            |\n\n### Client examples\n\n| Scenario                                            | Description                                                                        | Example file(s)                                                                                                                                                                                                                        | Related docs                                                 |\n| --------------------------------------------------- | ---------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |\n| Interactive Streamable HTTP client                  | CLI client that exercises tools, resources, prompts, elicitation, and tasks.       | [`simpleStreamableHttp.ts`](src/examples/client/simpleStreamableHttp.ts)                                                                                                                                                               | [`client.md`](docs/client.md)                                |\n| Backwards-compatible client (Streamable HTTP → SSE) | Tries Streamable HTTP first, then falls back to SSE on 4xx responses.              | [`streamableHttpWithSseFallbackClient.ts`](src/examples/client/streamableHttpWithSseFallbackClient.ts)                                                                                                                                 | [`client.md`](docs/client.md), [`server.md`](docs/server.md) |\n| SSE polling client                                  | Polls a legacy SSE server and demonstrates notification handling.                  | [`ssePollingClient.ts`](src/examples/client/ssePollingClient.ts)                                                                                                                                                                       | [`client.md`](docs/client.md)                                |\n| Parallel tool calls client                          | Shows how to run multiple tool calls in parallel.                                  | [`parallelToolCallsClient.ts`](src/examples/client/parallelToolCallsClient.ts)                                                                                                                                                         | [`client.md`](docs/client.md)                                |\n| Multiple clients in parallel                        | Demonstrates connecting multiple clients concurrently to the same server.          | [`multipleClientsParallel.ts`](src/examples/client/multipleClientsParallel.ts)                                                                                                                                                         | [`client.md`](docs/client.md)                                |\n| OAuth clients                                       | Examples of client_credentials (basic and private_key_jwt) and reusable providers. | [`simpleOAuthClient.ts`](src/examples/client/simpleOAuthClient.ts), [`simpleOAuthClientProvider.ts`](src/examples/client/simpleOAuthClientProvider.ts), [`simpleClientCredentials.ts`](src/examples/client/simpleClientCredentials.ts) | [`client.md`](docs/client.md)                                |\n| URL elicitation client                              | Works with the URL elicitation server to drive secure browser flows.               | [`elicitationUrlExample.ts`](src/examples/client/elicitationUrlExample.ts)                                                                                                                                                             | [`capabilities.md`](docs/capabilities.md#elicitation)        |\n\nShared utilities:\n\n- In-memory event store for resumability: [`inMemoryEventStore.ts`](src/examples/shared/inMemoryEventStore.ts) (see [`server.md`](docs/server.md)).\n\nFor more details on how to run these examples (including recommended commands and deployment diagrams), see `src/examples/README.md`.\n\n## Documentation\n\n- Local SDK docs:\n    - [docs/server.md](docs/server.md) – building and running MCP servers, transports, tools/resources/prompts, CORS, DNS rebinding, and multi-node deployment.\n    - [docs/client.md](docs/client.md) – using the high-level client, transports, backwards compatibility, and OAuth helpers.\n    - [docs/capabilities.md](docs/capabilities.md) – sampling, elicitation (form and URL), and experimental task-based execution.\n    - [docs/faq.md](docs/faq.md) – environment and troubleshooting FAQs (including Node.js Web Crypto support).\n- External references:\n    - [Model Context Protocol documentation](https://modelcontextprotocol.io)\n    - [MCP Specification](https://spec.modelcontextprotocol.io)\n    - [Example Servers](https://github.com/modelcontextprotocol/servers)\n\n## Contributing\n\nIssues and pull requests are welcome on GitHub at <https://github.com/modelcontextprotocol/typescript-sdk>.\n\n## License\n\nThis project is licensed under the MIT License—see the [LICENSE](LICENSE) file for details.\n"}
{"source":"github","repo":"mcp-typescript-sdk","path":"docs/faq.md","content":"## FAQ\n\n<details>\n<summary>Table of Contents</summary>\n\n- [General](#general)\n- [Clients](#clients)\n- [Servers](#servers)\n\n</details>\n\n## General\n\n### Why do I see `TS2589: Type instantiation is excessively deep and possibly infinite` after upgrading the SDK?\n\nThis TypeScript error can appear when upgrading to newer SDK versions that support Zod v4 (for example, from `@modelcontextprotocol/sdk` `1.22.0` to `1.23.0`) **and** your project ends up with multiple `zod` versions in the dependency tree.\n\nWhen there are multiple copies or versions of `zod`, TypeScript may try to instantiate very complex, cross-version types and hit its recursion limits, resulting in `TS2589`. This scenario is discussed in GitHub issue\n[#1180](https://github.com/modelcontextprotocol/typescript-sdk/issues/1180#event-21236550401).\n\nTo diagnose and fix this:\n\n- **Inspect your installed `zod` versions**:\n    - Run `npm ls zod` or `npm explain zod`, `pnpm list zod` or `pnpm why zod`, or `yarn why zod` and check whether more than one version is installed.\n- **Align on a single `zod` version**:\n    - Make sure all packages that depend on `zod` use a compatible version range so that your package manager can hoist a single copy.\n    - In monorepos, consider declaring `zod` at the workspace root and using compatible ranges in individual packages.\n- **Use overrides/resolutions if necessary**:\n    - With npm, Yarn, or pnpm, you can use `overrides` / `resolutions` to force a single `zod` version if some transitive dependencies pull in a different one.\n\nOnce your project is using a single, compatible `zod` version, the `TS2589` error should no longer occur.\n\n## Clients\n\n### How do I enable Web Crypto (`globalThis.crypto`) for client authentication in older Node.js versions?\n\nThe SDK’s OAuth client authentication helpers (for example, those in `src/client/auth-extensions.ts` that use `jose`) rely on the Web Crypto API exposed as `globalThis.crypto`. This is especially important for **client credentials** and **JWT-based** authentication flows used by\nMCP clients.\n\n- **Node.js v19.0.0 and later**: `globalThis.crypto` is available by default.\n- **Node.js v18.x**: `globalThis.crypto` may not be defined by default. In this repository we polyfill it for tests (see `vitest.setup.ts`), and you should do the same in your app if it is missing – or alternatively, run Node with `--experimental-global-webcrypto` as per your\n  Node version documentation. (See https://nodejs.org/dist/latest-v18.x/docs/api/globals.html#crypto )\n\nIf you run clients on Node.js versions where `globalThis.crypto` is missing, you can polyfill it using the built-in `node:crypto` module, similar to the SDK's own `vitest.setup.ts`:\n\n```typescript\nimport { webcrypto } from 'node:crypto';\n\nif (typeof globalThis.crypto === 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (globalThis as any).crypto = webcrypto as unknown as Crypto;\n}\n```\n\nFor production use, you can either:\n\n- Run clients on a Node.js version where `globalThis.crypto` is available by default (recommended), or\n- Apply a similar polyfill early in your client's startup code when targeting older Node.js runtimes, so that OAuth client authentication works reliably.\n\n## Servers\n\n### Where can I find runnable server examples?\n\nThe SDK ships several runnable server examples under `src/examples/server`. The root `README.md` contains a curated **Server examples** table that links to each scenario (stateful/stateless Streamable HTTP, JSON-only mode, SSE/backwards compatibility, elicitation, sampling,\ntasks, and OAuth demos), and `src/examples/README.md` includes commands and deployment diagrams for running them.\n"}
{"source":"github","repo":"mcp-typescript-sdk","path":"docs/capabilities.md","content":"## Sampling\n\nMCP servers can request LLM completions from connected clients that support the sampling capability. This lets your tools offload summarisation or generation to the client’s model.\n\nFor a runnable server that combines tools, logging and tasks, see:\n\n- [`toolWithSampleServer.ts`](../src/examples/server/toolWithSampleServer.ts)\n\nIn practice you will:\n\n- Declare the sampling capability on the client.\n- Call `server.server.createMessage(...)` from within a tool handler.\n- Return the model’s response as structured content and/or text.\n\nRefer to the MCP spec’s sampling section for full request/response details.\n\n## Elicitation\n\n### Form elicitation\n\nForm elicitation lets a tool ask the user for additional, **non‑sensitive** information via a schema‑driven form. The server sends a schema and message, and the client is responsible for collecting and returning the data.\n\nRunnable example:\n\n- Server: [`elicitationFormExample.ts`](../src/examples/server/elicitationFormExample.ts)\n- Client‑side handling: [`simpleStreamableHttp.ts`](../src/examples/client/simpleStreamableHttp.ts)\n\nThe `simpleStreamableHttp` server also includes a `collect-user-info` tool that demonstrates how to drive elicitation from a tool and handle the response.\n\n### URL elicitation\n\nURL elicitation is designed for sensitive data and secure web‑based flows (e.g., collecting an API key, confirming a payment, or doing third‑party OAuth). Instead of returning form data, the server asks the client to open a URL and the rest of the flow happens in the browser.\n\nRunnable example:\n\n- Server: [`elicitationUrlExample.ts`](../src/examples/server/elicitationUrlExample.ts)\n- Client: [`elicitationUrlExample.ts`](../src/examples/client/elicitationUrlExample.ts)\n\nKey points:\n\n- Use `mode: 'url'` when calling `server.server.elicitInput(...)`.\n- Implement a client‑side handler for `ElicitRequestSchema` that:\n    - Shows the full URL and reason to the user.\n    - Asks for explicit consent.\n    - Opens the URL in the system browser.\n\nSensitive information **must not** be collected via form elicitation; always use URL elicitation or out‑of‑band flows for secrets.\n\n## Task-based execution (experimental)\n\nTask-based execution enables “call-now, fetch-later” patterns for long-running operations. Instead of returning a result immediately, a tool creates a task that can be polled or resumed later.\n\nThe APIs live under the experimental `.experimental.tasks` namespace and may change without notice.\n\n### Server-side concepts\n\nOn the server you will:\n\n- Provide a `TaskStore` implementation that persists task metadata and results.\n- Enable the `tasks` capability when constructing the server.\n- Register tools with `server.experimental.tasks.registerToolTask(...)`.\n\nFor a runnable example that uses the in-memory store shipped with the SDK, see:\n\n- [`toolWithSampleServer.ts`](../src/examples/server/toolWithSampleServer.ts)\n- `src/experimental/tasks/stores/in-memory.ts`\n\n### Client-side usage\n\nOn the client, you use:\n\n- `client.experimental.tasks.callToolStream(...)` to start a tool call that may create a task and emit status updates over time.\n- `client.getTask(...)` and `client.getTaskResult(...)` to check status and fetch results after reconnecting.\n\nThe interactive client in:\n\n- [`simpleStreamableHttp.ts`](../src/examples/client/simpleStreamableHttp.ts)\n\nincludes commands to demonstrate calling tools that support tasks and handling their lifecycle.\n\nSee the MCP spec’s tasks section and the example server/client above for a full walkthrough of the task status lifecycle and TTL handling.\n"}
{"source":"github","repo":"mcp-typescript-sdk","path":"docs/server.md","content":"## Server overview\n\nThis SDK lets you build MCP servers in TypeScript and connect them to different transports. For most use cases you will use `McpServer` from `@modelcontextprotocol/sdk/server/mcp.js` and choose one of:\n\n- **Streamable HTTP** (recommended for remote servers)\n- **HTTP + SSE** (deprecated, for backwards compatibility only)\n- **stdio** (for local, process‑spawned integrations)\n\nFor a complete, runnable example server, see:\n\n- [`simpleStreamableHttp.ts`](../src/examples/server/simpleStreamableHttp.ts) – feature‑rich Streamable HTTP server\n- [`jsonResponseStreamableHttp.ts`](../src/examples/server/jsonResponseStreamableHttp.ts) – Streamable HTTP with JSON response mode\n- [`simpleStatelessStreamableHttp.ts`](../src/examples/server/simpleStatelessStreamableHttp.ts) – stateless Streamable HTTP server\n- [`simpleSseServer.ts`](../src/examples/server/simpleSseServer.ts) – deprecated HTTP+SSE transport\n- [`sseAndStreamableHttpCompatibleServer.ts`](../src/examples/server/sseAndStreamableHttpCompatibleServer.ts) – backwards‑compatible server for old and new clients\n\n## Transports\n\n### Streamable HTTP\n\nStreamable HTTP is the modern, fully featured transport. It supports:\n\n- Request/response over HTTP POST\n- Server‑to‑client notifications over SSE (when enabled)\n- Optional JSON‑only response mode with no SSE\n- Session management and resumability\n\nKey examples:\n\n- [`simpleStreamableHttp.ts`](../src/examples/server/simpleStreamableHttp.ts) – sessions, logging, tasks, elicitation, auth hooks\n- [`jsonResponseStreamableHttp.ts`](../src/examples/server/jsonResponseStreamableHttp.ts) – `enableJsonResponse: true`, no SSE\n- [`standaloneSseWithGetStreamableHttp.ts`](../src/examples/server/standaloneSseWithGetStreamableHttp.ts) – notifications with Streamable HTTP GET + SSE\n\nSee the MCP spec for full transport details:  \n`https://modelcontextprotocol.io/specification/2025-03-26/basic/transports`\n\n### Stateless vs stateful sessions\n\nStreamable HTTP can run:\n\n- **Stateless** – no session tracking, ideal for simple API‑style servers.\n- **Stateful** – sessions have IDs, and you can enable resumability and advanced features.\n\nExamples:\n\n- Stateless Streamable HTTP: [`simpleStatelessStreamableHttp.ts`](../src/examples/server/simpleStatelessStreamableHttp.ts)\n- Stateful with resumability: [`simpleStreamableHttp.ts`](../src/examples/server/simpleStreamableHttp.ts)\n\n### Deprecated HTTP + SSE\n\nThe older HTTP+SSE transport (protocol version 2024‑11‑05) is supported only for backwards compatibility. New implementations should prefer Streamable HTTP.\n\nExamples:\n\n- Legacy SSE server: [`simpleSseServer.ts`](../src/examples/server/simpleSseServer.ts)\n- Backwards‑compatible server (Streamable HTTP + SSE):  \n  [`sseAndStreamableHttpCompatibleServer.ts`](../src/examples/server/sseAndStreamableHttpCompatibleServer.ts)\n\n## Running your server\n\nFor a minimal “getting started” experience:\n\n1. Start from [`simpleStreamableHttp.ts`](../src/examples/server/simpleStreamableHttp.ts).\n2. Remove features you do not need (tasks, advanced logging, OAuth, etc.).\n3. Register your own tools, resources and prompts.\n\nFor more detailed patterns (stateless vs stateful, JSON response mode, CORS, DNS rebind protection), see the examples above and the MCP spec sections on transports.\n\n## DNS rebinding protection\n\nMCP servers running on localhost are vulnerable to DNS rebinding attacks. Use `createMcpExpressApp()` to create an Express app with DNS rebinding protection enabled by default:\n\n```typescript\nimport { createMcpExpressApp } from '@modelcontextprotocol/sdk/server/express.js';\n\n// Protection auto-enabled (default host is 127.0.0.1)\nconst app = createMcpExpressApp();\n\n// Protection auto-enabled for localhost\nconst app = createMcpExpressApp({ host: 'localhost' });\n\n// No auto protection when binding to all interfaces\nconst app = createMcpExpressApp({ host: '0.0.0.0' });\n```\n\nFor custom host validation, use the middleware directly:\n\n```typescript\nimport express from 'express';\nimport { hostHeaderValidation } from '@modelcontextprotocol/sdk/server/middleware/hostHeaderValidation.js';\n\nconst app = express();\napp.use(express.json());\napp.use(hostHeaderValidation(['localhost', '127.0.0.1', 'myhost.local']));\n```\n\n## Tools, resources, and prompts\n\n### Tools\n\nTools let MCP clients ask your server to take actions. They are usually the main way that LLMs call into your application.\n\nA typical registration with `registerTool` looks like this:\n\n```typescript\nserver.registerTool(\n    'calculate-bmi',\n    {\n        title: 'BMI Calculator',\n        description: 'Calculate Body Mass Index',\n        inputSchema: {\n            weightKg: z.number(),\n            heightM: z.number()\n        },\n        outputSchema: { bmi: z.number() }\n    },\n    async ({ weightKg, heightM }) => {\n        const output = { bmi: weightKg / (heightM * heightM) };\n        return {\n            content: [{ type: 'text', text: JSON.stringify(output) }],\n            structuredContent: output\n        };\n    }\n);\n```\n\nThis snippet is illustrative only; for runnable servers that expose tools, see:\n\n- [`simpleStreamableHttp.ts`](../src/examples/server/simpleStreamableHttp.ts)\n- [`toolWithSampleServer.ts`](../src/examples/server/toolWithSampleServer.ts)\n\n#### ResourceLink outputs\n\nTools can return `resource_link` content items to reference large resources without embedding them directly, allowing clients to fetch only what they need.\n\nThe README’s `list-files` example shows the pattern conceptually; for concrete usage, see the Streamable HTTP examples in `src/examples/server`.\n\n### Resources\n\nResources expose data to clients, but should not perform heavy computation or side‑effects. They are ideal for configuration, documents, or other reference data.\n\nConceptually, you might register resources like:\n\n```typescript\nserver.registerResource(\n    'config',\n    'config://app',\n    {\n        title: 'Application Config',\n        description: 'Application configuration data',\n        mimeType: 'text/plain'\n    },\n    async uri => ({\n        contents: [{ uri: uri.href, text: 'App configuration here' }]\n    })\n);\n```\n\nDynamic resources use `ResourceTemplate` and can support completions on path parameters. For full runnable examples of resources:\n\n- [`simpleStreamableHttp.ts`](../src/examples/server/simpleStreamableHttp.ts)\n\n### Prompts\n\nPrompts are reusable templates that help humans (or client UIs) talk to models in a consistent way. They are declared on the server and listed through MCP.\n\nA minimal prompt:\n\n```typescript\nserver.registerPrompt(\n    'review-code',\n    {\n        title: 'Code Review',\n        description: 'Review code for best practices and potential issues',\n        argsSchema: { code: z.string() }\n    },\n    ({ code }) => ({\n        messages: [\n            {\n                role: 'user',\n                content: {\n                    type: 'text',\n                    text: `Please review this code:\\n\\n${code}`\n                }\n            }\n        ]\n    })\n);\n```\n\nFor prompts integrated into a full server, see:\n\n- [`simpleStreamableHttp.ts`](../src/examples/server/simpleStreamableHttp.ts)\n\n### Completions\n\nBoth prompts and resources can support argument completions. On the client side, you use `client.complete()` with a reference to the prompt or resource and the partially‑typed argument.\n\nSee the MCP spec sections on prompts and resources for complete details, and [`simpleStreamableHttp.ts`](../src/examples/client/simpleStreamableHttp.ts) for client‑side usage patterns.\n\n### Display names and metadata\n\nTools, resources and prompts support a `title` field for human‑readable names. Older APIs can also attach `annotations.title`. To compute the correct display name on the client, use:\n\n- `getDisplayName` from `@modelcontextprotocol/sdk/shared/metadataUtils.js`\n\n## Multi‑node deployment patterns\n\nThe SDK supports multi‑node deployments using Streamable HTTP. The high‑level patterns are documented in [`README.md`](../src/examples/README.md):\n\n- Stateless mode (any node can handle any request)\n- Persistent storage mode (shared database for session state)\n- Local state with message routing (message queue + pub/sub)\n\nThose deployment diagrams are kept in [`README.md`](../src/examples/README.md) so the examples and documentation stay aligned.\n\n## Backwards compatibility\n\nTo handle both modern and legacy clients:\n\n- Run a backwards‑compatible server:\n    - [`sseAndStreamableHttpCompatibleServer.ts`](../src/examples/server/sseAndStreamableHttpCompatibleServer.ts)\n- Use a client that falls back from Streamable HTTP to SSE:\n    - [`streamableHttpWithSseFallbackClient.ts`](../src/examples/client/streamableHttpWithSseFallbackClient.ts)\n\nFor the detailed protocol rules, see the “Backwards compatibility” section of the MCP spec.\n"}
{"source":"github","repo":"mcp-typescript-sdk","path":"docs/client.md","content":"## Client overview\n\nThe SDK provides a high-level `Client` class that connects to MCP servers over different transports:\n\n- `StdioClientTransport` – for local processes you spawn.\n- `StreamableHTTPClientTransport` – for remote HTTP servers.\n- `SSEClientTransport` – for legacy HTTP+SSE servers (deprecated).\n\nRunnable client examples live under:\n\n- [`simpleStreamableHttp.ts`](../src/examples/client/simpleStreamableHttp.ts)\n- [`streamableHttpWithSseFallbackClient.ts`](../src/examples/client/streamableHttpWithSseFallbackClient.ts)\n- [`ssePollingClient.ts`](../src/examples/client/ssePollingClient.ts)\n- [`multipleClientsParallel.ts`](../src/examples/client/multipleClientsParallel.ts)\n- [`parallelToolCallsClient.ts`](../src/examples/client/parallelToolCallsClient.ts)\n\n## Connecting and basic operations\n\nA typical flow:\n\n1. Construct a `Client` with name, version and capabilities.\n2. Create a transport and call `client.connect(transport)`.\n3. Use high-level helpers:\n    - `listTools`, `callTool`\n    - `listPrompts`, `getPrompt`\n    - `listResources`, `readResource`\n\nSee [`simpleStreamableHttp.ts`](../src/examples/client/simpleStreamableHttp.ts) for an interactive CLI client that exercises these methods and shows how to handle notifications, elicitation and tasks.\n\n## Transports and backwards compatibility\n\nTo support both modern Streamable HTTP and legacy SSE servers, use a client that:\n\n1. Tries `StreamableHTTPClientTransport`.\n2. Falls back to `SSEClientTransport` on a 4xx response.\n\nRunnable example:\n\n- [`streamableHttpWithSseFallbackClient.ts`](../src/examples/client/streamableHttpWithSseFallbackClient.ts)\n\n## OAuth client authentication helpers\n\nFor OAuth-secured MCP servers, the client `auth` module exposes:\n\n- `ClientCredentialsProvider`\n- `PrivateKeyJwtProvider`\n- `StaticPrivateKeyJwtProvider`\n\nExamples:\n\n- [`simpleOAuthClient.ts`](../src/examples/client/simpleOAuthClient.ts)\n- [`simpleOAuthClientProvider.ts`](../src/examples/client/simpleOAuthClientProvider.ts)\n- [`simpleClientCredentials.ts`](../src/examples/client/simpleClientCredentials.ts)\n- Server-side auth demo: [`demoInMemoryOAuthProvider.ts`](../src/examples/server/demoInMemoryOAuthProvider.ts) (tests live under `test/examples/server/demoInMemoryOAuthProvider.test.ts`)\n\nThese examples show how to:\n\n- Perform dynamic client registration if needed.\n- Acquire access tokens.\n- Attach OAuth credentials to Streamable HTTP requests.\n"}
