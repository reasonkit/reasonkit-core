//! # VIBE Protocol Validation System
//!
//! Revolutionary "Agent-as-a-Verifier" paradigm for comprehensive protocol validation
//! across multiple platforms and environments.
//!
//! ## Overview
//!
//! VIBE (Validation of Intelligent Binary Evaluation) implements MiniMax M2's
//! breakthrough "Agent-as-a-Verifier" methodology to automatically validate
//! protocols generated by ReasonKit's ThinkTools.
//!
//! ### Core Validation Subsets
//!
//! - **Web Validation**: UI/UX quality, interaction logic, responsiveness
//! - **Simulation Validation**: Logic flow, decision trees, state management
//! - **Android Validation**: Mobile-specific validation, touch interactions, screen adaptation
//! - **iOS Validation**: iOS-specific validation, gestures, Apple design guidelines
//! - **Backend Validation**: API validation, data flow, performance, security
//!
//! ### Architecture
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────┐
//! │                    VIBE Engine                          │
//! │                (Agent-as-Verifier)                     │
//! ├─────────────────────────────────────────────────────────┤
//! │  Web  │  Simulation  │  Android  │  iOS   │  Backend   │
//! │Valid. │   Validation  │ Validation│Valid. │ Validation │
//! └─────────────────────────────────────────────────────────┘
//!                 │         │         │         │         │
//!                 ▼         ▼         ▼         ▼         ▼
//! ┌─────────────────────────────────────────────────────────┐
//! │               Real Runtime Environment                   │
//! │    Automated Assessment & Visual Aesthetics             │
//! └─────────────────────────────────────────────────────────┘
//! ```
//!
//! ## Usage
//!
//! ```rust
//! use reasonkit::vibe::{VIBEEngine, ValidationConfig, Platform};
//!
//! #[tokio::main]
//! async fn main() -> Result<(), Box<dyn std::error::Error>> {
//!     let engine = VIBEEngine::new();
//!     let config = ValidationConfig::default()
//!         .with_platforms(vec![Platform::Web, Platform::Backend]);
//!
//!     // Validate a protocol
//!     let protocol = "My Protocol Content";
//!     let result = engine.validate_protocol(protocol, config).await?;
//!     println!("VIBE Score: {}/100", result.overall_score);
//!
//!     Ok(())
//! }
//! ```
//!

pub mod adapters;
pub mod benchmarking;
pub mod multi_model_validator;
pub mod platforms;
pub mod scoring;
pub mod validation;
pub mod validation_config;

// Integration and demo modules
pub mod demo;
pub mod integration_examples;

// Re-export main types
pub use adapters::{CrossPlatformValidator, ValidationAdapter, ValidationSuite};
pub use benchmarking::{BenchmarkSuite, PerformanceMetrics};
pub use multi_model_validator::{
    CostAnalysis, MultiModelConfig, MultiModelValidationResult, MultiModelValidator,
    PerformanceMetrics as MultiModelPerformanceMetrics, ValidationStrategy,
};
pub use platforms::{Platform, PlatformValidator, ValidationEnvironment};
pub use scoring::{ScoreBreakdown, ScoringCriteria, VIBEScore};
pub use validation::{VIBEEngine, ValidationResult};
pub use validation_config::ValidationConfig;

// Re-export demo functionality
pub use demo::{run_vibe_demo, VIBEDemo};

// Re-export integration examples
pub use integration_examples::{IntegratedValidationResult, ThinkToolVIBEIntegration};

// Core VIBE types
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

/// VIBE Protocol Validation Request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationRequest {
    pub protocol_id: Uuid,
    pub protocol_content: String,
    pub protocol_type: ProtocolType,
    pub target_platforms: Vec<Platform>,
    pub validation_criteria: ValidationCriteria,
    pub environment_config: EnvironmentConfig,
}

/// Protocol Types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ProtocolType {
    ThinkToolChain,
    DecisionFramework,
    ReasoningProcess,
    ValidationMethod,
    LogicFlow,
    CustomProtocol,
}

/// Validation Criteria
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationCriteria {
    pub logical_consistency: bool,
    pub practical_applicability: bool,
    pub platform_compatibility: bool,
    pub performance_requirements: bool,
    pub security_considerations: bool,
    pub user_experience: bool,
    pub custom_metrics: HashMap<String, f32>,
}

/// Environment Configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentConfig {
    pub timeout_ms: u64,
    pub resource_limits: ResourceLimits,
    pub network_conditions: NetworkConditions,
    pub browser_settings: Option<BrowserSettings>,
    pub mobile_settings: Option<MobileSettings>,
}

/// Resource Limits
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceLimits {
    pub max_memory_mb: u64,
    pub max_cpu_percent: f32,
    pub max_disk_usage_mb: u64,
    pub max_network_requests: u32,
}

/// Network Conditions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkConditions {
    pub latency_ms: u32,
    pub bandwidth_mbps: f32,
    pub packet_loss_percent: f32,
    pub connection_type: ConnectionType,
}

/// Connection Types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ConnectionType {
    Wifi,
    Cellular4G,
    Cellular5G,
    Ethernet,
    Satellite,
}

/// Browser Settings
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BrowserSettings {
    pub browser_type: BrowserType,
    pub viewport_size: ViewportSize,
    pub device_pixel_ratio: f32,
    pub touch_enabled: bool,
}

/// Browser Types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum BrowserType {
    Chrome,
    Firefox,
    Safari,
    Edge,
}

/// Viewport Sizes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ViewportSize {
    pub width: u32,
    pub height: u32,
}

/// Mobile Settings
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MobileSettings {
    pub device_type: DeviceType,
    pub screen_size: ScreenSize,
    pub os_version: String,
    pub orientation: Orientation,
}

/// Device Types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum DeviceType {
    Phone,
    Tablet,
    Watch,
}

/// Screen Sizes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScreenSize {
    pub width: u32,
    pub height: u32,
    pub density: f32,
}

/// Screen Orientations
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Orientation {
    Portrait,
    Landscape,
}

/// VIBE System Statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VIBEStats {
    pub total_validations: u64,
    pub average_score: f32,
    pub success_rate: f32,
    pub platform_distribution: HashMap<Platform, u32>,
    pub validation_trends: Vec<ScoreTrend>,
}

/// Score Trends
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScoreTrend {
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub score: f32,
    pub platform: Platform,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validation_request_creation() {
        let request = ValidationRequest {
            protocol_id: Uuid::new_v4(),
            protocol_content: "Test protocol".to_string(),
            protocol_type: ProtocolType::ThinkToolChain,
            target_platforms: vec![Platform::Web],
            validation_criteria: ValidationCriteria {
                logical_consistency: true,
                practical_applicability: true,
                platform_compatibility: true,
                performance_requirements: false,
                security_considerations: false,
                user_experience: true,
                custom_metrics: HashMap::new(),
            },
            environment_config: EnvironmentConfig {
                timeout_ms: 30000,
                resource_limits: ResourceLimits {
                    max_memory_mb: 512,
                    max_cpu_percent: 80.0,
                    max_disk_usage_mb: 1024,
                    max_network_requests: 100,
                },
                network_conditions: NetworkConditions {
                    latency_ms: 50,
                    bandwidth_mbps: 10.0,
                    packet_loss_percent: 0.0,
                    connection_type: ConnectionType::Wifi,
                },
                browser_settings: None,
                mobile_settings: None,
            },
        };

        assert_eq!(request.protocol_type, ProtocolType::ThinkToolChain);
        assert!(request.validation_criteria.logical_consistency);
    }
}
